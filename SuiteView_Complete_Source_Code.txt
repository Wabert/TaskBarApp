
================================================================================
                    SUITEVIEW TASKBAR APPLICATION
                         COMPLETE SOURCE CODE
================================================================================

Export Information:
    Generated on: 2025-06-25 13:59:30
    Project Directory: C:\Users\rober\Documents\Code\TaskBarApp
    Export Tool: SuiteView Code Exporter v1.0

Description:
    This file contains the complete source code for the SuiteView Taskbar 
    Application - a customizable Windows taskbar replacement with quick links
    functionality, drag-and-drop support, and modern UI components.

Project Structure:
    • Main Application Files: main.py, taskbar.py
    • UI Components: ui_components.py, quick_links.py
    • Data Management: links_manager.py, config.py
    • Utilities: utils.py, browse_choice_dialog.py, restore_deskop.py
    • Configuration: requirements.txt, README.md

================================================================================


────────────────────────────────────────────────────────────────────────────────
FILE: README.md
────────────────────────────────────────────────────────────────────────────────
Path: README.md
Size: 718.0 B
Lines: 31 total, 26 non-empty
Characters: 688
Type: Project documentation and setup instructions
────────────────────────────────────────────────────────────────────────────────

# SuiteView Taskbar App

A simple, customizable taskbar app for Windows 11, built with PySide2.

## Features
- Always-on-top, borderless taskbar bar
- Two-tone green theme
- System tray integration
- Easy to extend with new buttons and features

## Setup
1. Install Python 3.8+
2. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```
3. Run the app:
   ```bash
   python main.py
   ```

## Packaging (Optional)
To create a standalone executable, install PyInstaller:
```bash
pip install pyinstaller
pyinstaller --onefile --windowed main.py
```

## Customization
- Add new buttons and features by editing `main.py`.
- Update colors and styles in the code as desired. 

────────────────────────────────────────────────────────────────────────────────
FILE: browse_choice_dialog.py
────────────────────────────────────────────────────────────────────────────────
Path: browse_choice_dialog.py
Size: 7.0 KB
Lines: 187 total, 153 non-empty
Characters: 6,939
Type: File/folder selection dialog
────────────────────────────────────────────────────────────────────────────────

   1: # browse_choice_dialog.py
   2: """
   3: Custom dialog for choosing between file and folder browsing
   4: Replaces messagebox with properly styled, topmost dialog
   5: """
   6: 
   7: import tkinter as tk
   8: from tkinter import filedialog
   9: from config import Colors, Fonts, Dimensions
  10: from ui_components import CustomDialog
  11: 
  12: class BrowseChoiceDialog(CustomDialog):
  13:     """Custom dialog for choosing between File or Folder browsing"""
  14:     
  15:     def __init__(self, parent):
  16:         super().__init__(parent, "Browse Type", width=350, height=350)
  17:         
  18:         self.choice_result = None  # Will store 'file', 'folder', or None
  19:         self.selected_path = None  # Will store the selected path
  20:         
  21:         # Make sure dialog stays on top of everything
  22:         self.attributes('-topmost', True)
  23:         self.lift()
  24:         self.focus_force()
  25:         
  26:         self.create_content()
  27:         self.create_buttons()
  28:         
  29:         # Bind keyboard shortcuts
  30:         self.bind('<F>', lambda e: self.choose_file())
  31:         self.bind('<f>', lambda e: self.choose_file())
  32:         self.bind('<D>', lambda e: self.choose_folder())
  33:         self.bind('<d>', lambda e: self.choose_folder())
  34:         self.bind('<Escape>', lambda e: self.cancel())
  35:     
  36:     def create_content(self):
  37:         """Create the dialog content"""
  38:         # Icon
  39:         icon_label = tk.Label(self.dialog_content, text="📁", bg=Colors.LIGHT_GREEN,
  40:                              fg=Colors.DARK_GREEN, font=('Arial', 24))
  41:         icon_label.pack(pady=10)
  42:         
  43:         # Main message
  44:         message_label = tk.Label(self.dialog_content, 
  45:                                text="What would you like to browse for?", 
  46:                                bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
  47:                                font=Fonts.DIALOG_LABEL, wraplength=300)
  48:         message_label.pack(pady=5)
  49:         
  50:         # Instructions
  51:         instruction_label = tk.Label(self.dialog_content, 
  52:                                    text="Choose File for documents, applications, etc.\nChoose Folder for directories", 
  53:                                    bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
  54:                                    font=(Fonts.DIALOG_LABEL[0], Fonts.DIALOG_LABEL[1] - 1),
  55:                                    justify=tk.CENTER)
  56:         instruction_label.pack(pady=5)
  57:     
  58:     def create_buttons(self):
  59:         """Create the choice buttons"""
  60:         # Make sure button frame is visible and has proper height
  61:         self.button_frame.configure(height=80)
  62:         self.button_frame.pack_propagate(False)
  63:         
  64:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
  65:         button_container.pack(expand=True, fill=tk.BOTH, pady=10)
  66:         
  67:         # File button (primary choice)
  68:         file_btn = tk.Button(button_container, text="File", 
  69:                            bg=Colors.DARK_GREEN, fg=Colors.WHITE,
  70:                            command=self.choose_file, 
  71:                            width=10, height=20,
  72:                            font=Fonts.DIALOG_BUTTON, 
  73:                            relief=tk.RAISED, bd=2,
  74:                            cursor='hand2')
  75:         file_btn.pack(side=tk.LEFT, padx=15, pady=10)
  76:         
  77:         # Folder button
  78:         folder_btn = tk.Button(button_container, text="Folder", 
  79:                              bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
  80:                              command=self.choose_folder, 
  81:                              width=10, height=20,
  82:                              font=Fonts.DIALOG_BUTTON, 
  83:                              relief=tk.RAISED, bd=2,
  84:                              cursor='hand2')
  85:         folder_btn.pack(side=tk.LEFT, padx=15, pady=10)
  86:         
  87:         # Cancel button
  88:         cancel_btn = tk.Button(button_container, text="Cancel", 
  89:                              bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
  90:                              command=self.cancel, 
  91:                              width=8, height=20,
  92:                              font=Fonts.DIALOG_BUTTON, 
  93:                              relief=tk.RAISED, bd=1)
  94:         cancel_btn.pack(side=tk.LEFT, padx=15, pady=10)
  95:         
  96:         # Set focus on File button (most common choice)
  97:         file_btn.focus_set()
  98:     
  99:     def choose_file(self):
 100:         """Handle file selection"""
 101:         self.choice_result = 'file'
 102:         
 103:         # Disable topmost and hide this dialog temporarily
 104:         self.attributes('-topmost', False)
 105:         self.withdraw()  # Hide this dialog temporarily
 106:         
 107:         # Use the parent window for the file dialog
 108:         try:
 109:             path = filedialog.askopenfilename(
 110:                 parent=self.parent,
 111:                 title="Select File",
 112:                 filetypes=[
 113:                     ("All Files", "*.*"),
 114:                     ("Executables", "*.exe"),
 115:                     ("Documents", "*.pdf;*.doc;*.docx;*.txt"),
 116:                     ("Spreadsheets", "*.xls;*.xlsx;*.csv"),
 117:                     ("Images", "*.png;*.jpg;*.jpeg;*.gif;*.bmp")
 118:                 ]
 119:             )
 120:             
 121:             if path:
 122:                 self.selected_path = path
 123:                 self.result = True
 124:             else:
 125:                 self.result = None
 126:                 
 127:         except Exception as e:
 128:             print(f"Error in file dialog: {e}")
 129:             self.result = None
 130:         
 131:         self.destroy()
 132:     
 133:     def choose_folder(self):
 134:         """Handle folder selection"""
 135:         self.choice_result = 'folder'
 136:                 
 137:         # Disable topmost and hide this dialog temporarily
 138:         self.attributes('-topmost', False)
 139:         self.withdraw()  # Hide this dialog temporarily
 140:         
 141:         # Use the parent window for the folder dialog
 142:         try:
 143:             path = filedialog.askdirectory(
 144:                 parent=self.parent,
 145:                 title="Select Folder"
 146:             )
 147:             
 148:             if path:
 149:                 self.selected_path = path
 150:                 self.result = True
 151:             else:
 152:                 self.result = None
 153:                 
 154:         except Exception as e:
 155:             print(f"Error in folder dialog: {e}")
 156:             self.result = None
 157:         
 158:         self.destroy()
 159:     
 160:     def cancel(self):
 161:         """Cancel the dialog"""
 162:         self.choice_result = None
 163:         self.selected_path = None
 164:         self.result = None
 165:         self.destroy()
 166:     
 167:     @classmethod
 168:     def get_path(cls, parent):
 169:         """
 170:         Show the browse choice dialog and return the selected path
 171:         
 172:         Returns:
 173:             tuple: (choice_type, selected_path) where choice_type is 'file', 'folder', or None
 174:         """
 175:         dialog = cls(parent)
 176:         
 177:         # Ensure dialog is visible and on top
 178:         dialog.deiconify()
 179:         dialog.lift()
 180:         dialog.attributes('-topmost', True)
 181:         dialog.focus_force()
 182:         dialog.grab_set()
 183:         
 184:         # Wait for dialog to complete
 185:         parent.wait_window(dialog)
 186:         
 187:         return dialog.choice_result, dialog.selected_path

────────────────────────────────────────────────────────────────────────────────
FILE: config.py
────────────────────────────────────────────────────────────────────────────────
Path: config.py
Size: 2.7 KB
Lines: 86 total, 74 non-empty
Characters: 2,682
Type: Application configuration and constants
────────────────────────────────────────────────────────────────────────────────

   1: # config.py
   2: """
   3: Configuration constants for SuiteView Taskbar Application
   4: Contains colors, sizes, paths, and other application settings
   5: """
   6: 
   7: from pathlib import Path
   8: 
   9: # Color Scheme (Two-Tone Green)
  10: class Colors:
  11:     DARK_GREEN = '#006600'      # Main taskbar, headers, borders
  12:     MEDIUM_GREEN = '#00AA00'    # Menu backgrounds, inactive elements  
  13:     LIGHT_GREEN = '#B3FFB3'     # Input fields, hover states, active elements (lighter green)
  14:     #LIGHT_GREEN = '#00CC00'
  15:     HOVER_GREEN = '#008800'     # Hover effects
  16:     INACTIVE_GRAY = '#666666'   # Cancel buttons, disabled elements
  17:     WHITE = '#FFFFFF'
  18:     BLACK = '#000000'
  19: 
  20:     WINDOW_HIDDEN = '#FF6666'      # Red tint for hidden windows
  21:     WINDOW_VISIBLE = '#66FF66'     # Green tint for visible windows
  22:     PINNED_SECTION_BG = '#004400'  # Darker green for pinned section
  23:     PIN_BUTTON_COLOR = '#FFFF00'   # Yellow for pin buttons
  24: 
  25: # Font Settings
  26: class Fonts:
  27:     TASKBAR_TITLE = ('Arial', 14, 'bold italic')
  28:     TASKBAR_BUTTON = ('Arial', 10)
  29:     MENU_HEADER = ('Arial', 10, 'bold')
  30:     MENU_ITEM = ('Arial', 8)
  31:     DIALOG_TITLE = ('Arial', 10, 'bold')
  32:     DIALOG_LABEL = ('Arial', 9)
  33:     DIALOG_BUTTON = ('Arial', 9)
  34:     WARNING_ICON = ('Arial', 20)
  35: 
  36: # Window Dimensions
  37: class Dimensions:
  38:     TASKBAR_HEIGHT = 40
  39:     MENU_MIN_WIDTH = 400
  40:     MENU_MIN_HEIGHT = 100
  41:     DIALOG_BUTTON_WIDTH = 8
  42:     DIALOG_PADDING = 10
  43: 
  44: # File Paths
  45: class Paths:
  46:     CONFIG_DIR = Path.home() / '.suiteview'
  47:     LINKS_FILE = CONFIG_DIR / 'links.json'
  48:     
  49:     @classmethod
  50:     def ensure_config_dir(cls):
  51:         """Ensure configuration directory exists"""
  52:         cls.CONFIG_DIR.mkdir(exist_ok=True)
  53:     
  54:     @classmethod
  55:     def get_config_dir_str(cls):
  56:         """Get configuration directory as normalized Windows path string"""
  57:         import os
  58:         return os.path.normpath(str(cls.CONFIG_DIR))
  59:     
  60:     @classmethod
  61:     def get_links_file_str(cls):
  62:         """Get links file path as normalized Windows path string"""
  63:         import os
  64:         return os.path.normpath(str(cls.LINKS_FILE))
  65: 
  66: # Windows API Constants
  67: class WindowsAPI:
  68:     SPI_SETWORKAREA = 0x002F
  69:     SPI_GETWORKAREA = 0x0030
  70:     HWND_TOPMOST = -1
  71:     SWP_NOMOVE = 0x0002
  72:     SWP_NOSIZE = 0x0001
  73:     SPIF_SENDCHANGE = 0x0002
  74: 
  75: # Default Categories for Links
  76: DEFAULT_CATEGORIES = ["Quick Links", "Applications", "Folders", "Websites"]
  77: 
  78: # Application Settings
  79: class Settings:
  80:     APP_NAME = "SuiteView"
  81:     VERSION = "2.0"
  82:     TASKBAR_OPACITY = 0.98
  83:     MENU_OPACITY = 0.98
  84:     AUTO_REFRESH_INTERVAL = 1000  # milliseconds
  85:     PINNED_SECTION_WIDTH = 400     # Width allocated for pinned windows
  86:     PINNED_BUTTON_WIDTH = 80       # Width of each pinned window button

────────────────────────────────────────────────────────────────────────────────
FILE: enhanced_folder_inventory.py
────────────────────────────────────────────────────────────────────────────────
Path: enhanced_folder_inventory.py
Size: 23.5 KB
Lines: 569 total, 459 non-empty
Characters: 23,495
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # enhanced_folder_inventory.py
   2: """
   3: Enhanced Folder Inventory feature for SuiteView Taskbar
   4: Adds View option with Excel-like filtering capabilities
   5: """
   6: 
   7: import os
   8: import threading
   9: import time
  10: from datetime import datetime
  11: from pathlib import Path
  12: import tkinter as tk
  13: from tkinter import ttk, filedialog, messagebox
  14: from openpyxl import Workbook
  15: from openpyxl.styles import Font, PatternFill
  16: import tempfile
  17: import subprocess
  18: from inventory_view_window import InventoryViewWindow
  19: 
  20: from config import Colors, Fonts, Dimensions
  21: from ui_components import CustomDialog, FormField, WarningDialog, ErrorDialog
  22: from utils import UIUtils
  23: 
  24: class FolderInventoryDialog(CustomDialog):
  25:     """Enhanced dialog for configuring folder inventory scan with View/Print options"""
  26:     
  27:     def __init__(self, parent):
  28:         super().__init__(parent, "Folder Inventory", width=500, height=400)
  29:         
  30:         self.selected_folder = ""
  31:         self.scan_thread = None
  32:         self.cancel_scan = False
  33:         self.progress_window = None
  34:         
  35:         self.create_form()
  36:         self.add_buttons()
  37:         
  38:         # Set focus on folder field
  39:         self.folder_field.widget.focus_set()
  40:     
  41:     def create_form(self):
  42:         """Create the configuration form"""
  43:         # Folder selection
  44:         folder_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
  45:         folder_frame.pack(fill=tk.X, pady=5)
  46:         
  47:         self.folder_field = FormField(folder_frame, "Folder to scan:", width=35)
  48:         self.folder_field.pack(side=tk.LEFT, fill=tk.X, expand=True)
  49:         
  50:         browse_btn = tk.Button(folder_frame, text="Browse...", 
  51:                               command=self.browse_folder,
  52:                               bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
  53:                               font=Fonts.DIALOG_BUTTON, cursor='hand2')
  54:         browse_btn.pack(side=tk.RIGHT, padx=(5, 0))
  55:         
  56:         # Depth selection
  57:         self.depth_field = FormField(
  58:             self.dialog_content, "Scan depth:", 
  59:             field_type='combobox',
  60:             values=["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Unlimited"],
  61:             width=15
  62:         )
  63:         self.depth_field.set("1")
  64:         self.depth_field.widget.configure(state='readonly')
  65:         self.depth_field.pack(fill=tk.X, pady=5)
  66:         
  67:         # Content type selection
  68:         content_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
  69:         content_frame.pack(fill=tk.X, pady=10)
  70:         
  71:         tk.Label(content_frame, text="Include:", bg=Colors.LIGHT_GREEN, 
  72:                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).pack(anchor='w')
  73:         
  74:         self.content_type = tk.StringVar(value="both")
  75:         
  76:         radio_frame = tk.Frame(content_frame, bg=Colors.LIGHT_GREEN)
  77:         radio_frame.pack(fill=tk.X, pady=5)
  78:         
  79:         tk.Radiobutton(radio_frame, text="Files Only", variable=self.content_type, 
  80:                       value="files", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
  81:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
  82:         
  83:         tk.Radiobutton(radio_frame, text="Folders Only", variable=self.content_type, 
  84:                       value="folders", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
  85:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
  86:         
  87:         tk.Radiobutton(radio_frame, text="Both", variable=self.content_type, 
  88:                       value="both", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
  89:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
  90:         
  91:         # Output option selection (NEW)
  92:         output_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
  93:         output_frame.pack(fill=tk.X, pady=10)
  94:         
  95:         tk.Label(output_frame, text="Output to:", bg=Colors.LIGHT_GREEN, 
  96:                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).pack(anchor='w')
  97:         
  98:         self.output_type = tk.StringVar(value="view")  # Default to View
  99:         
 100:         output_radio_frame = tk.Frame(output_frame, bg=Colors.LIGHT_GREEN)
 101:         output_radio_frame.pack(fill=tk.X, pady=5)
 102:         
 103:         tk.Radiobutton(output_radio_frame, text="View (Interactive)", variable=self.output_type, 
 104:                       value="view", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 105:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
 106:         
 107:         tk.Radiobutton(output_radio_frame, text="Excel File", variable=self.output_type, 
 108:                       value="excel", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 109:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
 110:         
 111:         # Information text
 112:         info_text = ("View will show results in an interactive grid with filtering.\n"
 113:                     "Excel will create a spreadsheet file.\n"
 114:                     "Large operations (>20,000 items) will show a warning.")
 115:         info_label = tk.Label(self.dialog_content, text=info_text, 
 116:                              bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 117:                              font=(Fonts.DIALOG_LABEL[0], Fonts.DIALOG_LABEL[1]-1),
 118:                              wraplength=450, justify=tk.LEFT)
 119:         info_label.pack(pady=10)
 120:     
 121:     def browse_folder(self):
 122:         """Browse for folder to scan"""
 123:         folder = filedialog.askdirectory(parent=self, title="Select Folder to Inventory")
 124:         if folder:
 125:             self.folder_field.set(folder)
 126:             self.selected_folder = folder
 127:     
 128:     def add_buttons(self):
 129:         """Add Start and Cancel buttons"""
 130:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 131:         button_container.pack(expand=True)
 132:         
 133:         start_btn = tk.Button(button_container, text="Start Scan", 
 134:                              bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 135:                              command=self.start_scan, width=Dimensions.DIALOG_BUTTON_WIDTH,
 136:                              font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1,
 137:                              cursor='hand2')
 138:         start_btn.pack(side=tk.LEFT, padx=10)
 139:         
 140:         cancel_btn = tk.Button(button_container, text="Cancel", 
 141:                               bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 142:                               command=self.cancel, width=Dimensions.DIALOG_BUTTON_WIDTH,
 143:                               font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 144:         cancel_btn.pack(side=tk.LEFT, padx=10)
 145:         
 146:         start_btn.focus_set()
 147:     
 148:     def start_scan(self):
 149:         """Start the folder inventory scan"""
 150:         folder = self.folder_field.get().strip()
 151:         if not folder:
 152:             WarningDialog.show(self, "Invalid Input", "Please select a folder to scan.")
 153:             return
 154:         
 155:         if not os.path.exists(folder):
 156:             ErrorDialog.show(self, "Folder Not Found", f"The selected folder does not exist:\n{folder}")
 157:             return
 158:         
 159:         # Get scan parameters
 160:         depth_str = self.depth_field.get()
 161:         max_depth = None if depth_str == "Unlimited" else int(depth_str)
 162:         content_type = self.content_type.get()
 163:         output_type = self.output_type.get()
 164:         
 165:         # Quick estimation for large operation warning
 166:         if self.should_warn_large_operation(folder, max_depth):
 167:             result = WarningDialog.show(self, "Large Operation Warning", 
 168:                                        "This operation may scan more than 20,000 items and could take several minutes.\n\n"
 169:                                        "Do you want to continue?")
 170:             if not result:
 171:                 return
 172:         
 173:         # Start the scan
 174:         self.destroy()
 175:         self.start_inventory_scan(folder, max_depth, content_type, output_type)
 176:     
 177:     def should_warn_large_operation(self, folder, max_depth):
 178:         """Quick check to estimate if operation will be large"""
 179:         try:
 180:             sample_count = 0
 181:             with os.scandir(folder) as entries:
 182:                 for entry in entries:
 183:                     sample_count += 1
 184:                     if sample_count >= 1000:
 185:                         break
 186:             
 187:             if sample_count >= 1000:
 188:                 return True
 189:             
 190:             if max_depth is None or max_depth > 1:
 191:                 with os.scandir(folder) as entries:
 192:                     for entry in entries:
 193:                         if entry.is_dir():
 194:                             return True
 195:             
 196:             return False
 197:         except:
 198:             return False
 199:     
 200:     def start_inventory_scan(self, folder, max_depth, content_type, output_type):
 201:         """Start the actual inventory scan in background thread"""
 202:         self.cancel_scan = False
 203:         
 204:         # Create progress window
 205:         self.progress_window = ProgressWindow(self.parent, self.cancel_scan_operation)
 206:         
 207:         # Start scan in background thread
 208:         self.scan_thread = threading.Thread(
 209:             target=self.perform_scan,
 210:             args=(folder, max_depth, content_type, output_type),
 211:             daemon=True
 212:         )
 213:         self.scan_thread.start()
 214:     
 215:     def cancel_scan_operation(self):
 216:         """Cancel the running scan operation"""
 217:         self.cancel_scan = True
 218:         if self.progress_window:
 219:             self.progress_window.destroy()
 220:     
 221:     def perform_scan(self, folder, max_depth, content_type, output_type):
 222:         """Perform the actual folder scan (runs in background thread)"""
 223:         try:
 224:             scanner = FolderScanner(folder, max_depth, content_type, self.update_progress)
 225:             inventory_data, error_data = scanner.scan()
 226:             
 227:             if not self.cancel_scan:
 228:                 if output_type == "excel":
 229:                     # Create Excel file (existing functionality)
 230:                     excel_creator = ExcelInventoryCreator()
 231:                     excel_creator.create_workbook(inventory_data, error_data, folder)
 232:                 else:
 233:                     # Show in interactive view (NEW)
 234:                     scan_info = {
 235:                         'folder': folder,
 236:                         'generated': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
 237:                         'total_items': len(inventory_data),
 238:                         'max_depth': max_depth,
 239:                         'content_type': content_type
 240:                     }
 241:                     self.show_inventory_view(inventory_data, error_data, scan_info)
 242:                 
 243:                 # Close progress window
 244:                 if self.progress_window:
 245:                     self.progress_window.after(0, self.progress_window.destroy)
 246:                 
 247:         except Exception as e:
 248:             # Show error in main thread
 249:             if self.progress_window:
 250:                 self.progress_window.after(0, lambda: self.show_scan_error(str(e)))
 251:     
 252:     def show_inventory_view(self, inventory_data, error_data, scan_info):
 253:         """Show the inventory data in an interactive view"""
 254:         if self.progress_window:
 255:             self.progress_window.after(0, lambda: InventoryViewWindow(
 256:                 self.parent, inventory_data, error_data, scan_info))
 257:     
 258:     def update_progress(self, count, current_path):
 259:         """Update progress display (called from background thread)"""
 260:         if self.progress_window and not self.cancel_scan:
 261:             self.progress_window.after(0, lambda: self.progress_window.update_progress(count, current_path))
 262:     
 263:     def show_scan_error(self, error_message):
 264:         """Show scan error (called in main thread)"""
 265:         if self.progress_window:
 266:             self.progress_window.destroy()
 267:         ErrorDialog.show(self.parent, "Scan Error", f"An error occurred during scanning:\n{error_message}")
 268: 
 269: 
 270: class ProgressWindow(CustomDialog):
 271:     """Progress window for folder scanning"""
 272:     
 273:     def __init__(self, parent, cancel_callback):
 274:         super().__init__(parent, "Scanning Folder", width=450, height=200)
 275:         
 276:         self.cancel_callback = cancel_callback
 277:         
 278:         # Progress info
 279:         self.progress_label = tk.Label(self.dialog_content, text="Starting scan...", 
 280:                                       bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 281:                                       font=Fonts.DIALOG_LABEL, wraplength=400)
 282:         self.progress_label.pack(pady=10)
 283:         
 284:         self.count_label = tk.Label(self.dialog_content, text="Items processed: 0", 
 285:                                    bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 286:                                    font=Fonts.DIALOG_LABEL)
 287:         self.count_label.pack(pady=5)
 288:         
 289:         self.path_label = tk.Label(self.dialog_content, text="", 
 290:                                   bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 291:                                   font=(Fonts.DIALOG_LABEL[0], Fonts.DIALOG_LABEL[1]-1),
 292:                                   wraplength=400, anchor='w')
 293:         self.path_label.pack(pady=5, fill=tk.X)
 294:         
 295:         # Cancel button
 296:         cancel_btn = tk.Button(self.button_frame, text="Cancel Scan", 
 297:                               bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 298:                               command=self.cancel_callback, width=12,
 299:                               font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 300:         cancel_btn.pack()
 301:         
 302:         # Override close button to call cancel
 303:         self.protocol("WM_DELETE_WINDOW", self.cancel_callback)
 304:     
 305:     def update_progress(self, count, current_path):
 306:         """Update progress display"""
 307:         self.count_label.config(text=f"Items processed: {count:,}")
 308:         
 309:         # Truncate long paths
 310:         display_path = current_path
 311:         if len(display_path) > 60:
 312:             display_path = "..." + display_path[-57:]
 313:         
 314:         self.path_label.config(text=f"Current: {display_path}")
 315: 
 316: 
 317: class FolderScanner:
 318:     """Core folder scanning logic"""
 319:     
 320:     def __init__(self, root_folder, max_depth, content_type, progress_callback):
 321:         self.root_folder = root_folder
 322:         self.max_depth = max_depth
 323:         self.content_type = content_type
 324:         self.progress_callback = progress_callback
 325:         self.cancel_scan = False
 326:         
 327:         self.inventory_data = []
 328:         self.error_data = []
 329:         self.item_count = 0
 330:     
 331:     def scan(self):
 332:         """Main scan method"""
 333:         self._scan_directory(self.root_folder, 0)
 334:         return self.inventory_data, self.error_data
 335:     
 336:     def _scan_directory(self, directory, current_depth):
 337:         """Recursively scan directory"""
 338:         if self.cancel_scan:
 339:             return
 340:         
 341:         # Check depth limit
 342:         if self.max_depth is not None and current_depth >= self.max_depth:
 343:             return
 344:         
 345:         try:
 346:             with os.scandir(directory) as entries:
 347:                 for entry in entries:
 348:                     if self.cancel_scan:
 349:                         return
 350:                     
 351:                     try:
 352:                         self._process_entry(entry, current_depth)
 353:                     except Exception as e:
 354:                         self._log_error(entry.path, str(e))
 355:                     
 356:                     # Update progress every 100 items
 357:                     if self.item_count % 100 == 0:
 358:                         self.progress_callback(self.item_count, entry.path)
 359:         
 360:         except Exception as e:
 361:             self._log_error(directory, str(e))
 362:     
 363:     def _process_entry(self, entry, current_depth):
 364:         """Process a single file/folder entry"""
 365:         is_file = entry.is_file()
 366:         is_dir = entry.is_dir()
 367:         
 368:         # Check if we should include this type
 369:         if self.content_type == "files" and not is_file:
 370:             pass  # Skip folders
 371:         elif self.content_type == "folders" and not is_dir:
 372:             pass  # Skip files
 373:         else:
 374:             # Include this item
 375:             self._add_inventory_item(entry, is_file)
 376:         
 377:         # Recurse into subdirectories
 378:         if is_dir:
 379:             self._scan_directory(entry.path, current_depth + 1)
 380:     
 381:     def _add_inventory_item(self, entry, is_file):
 382:         """Add item to inventory data"""
 383:         try:
 384:             stat_info = entry.stat()
 385:             
 386:             # Get size (only for files)
 387:             if is_file:
 388:                 size_bytes = stat_info.st_size
 389:                 size_human = self._format_size(size_bytes)
 390:             else:
 391:                 size_bytes = 0
 392:                 size_human = "N/A"
 393:             
 394:             # Get modified date
 395:             modified_date = datetime.fromtimestamp(stat_info.st_mtime).strftime("%Y-%m-%d %H:%M:%S")
 396:             
 397:             item_data = {
 398:                 'Name': entry.name,
 399:                 'Full Path': entry.path,
 400:                 'Type': 'File' if is_file else 'Folder',
 401:                 'Size (Bytes)': size_bytes if is_file else '',
 402:                 'Size': size_human,
 403:                 'Modified Date': modified_date
 404:             }
 405:             
 406:             self.inventory_data.append(item_data)
 407:             self.item_count += 1
 408:             
 409:         except Exception as e:
 410:             self._log_error(entry.path, str(e))
 411:     
 412:     def _format_size(self, bytes_size):
 413:         """Format file size in human readable format"""
 414:         if bytes_size == 0:
 415:             return "0 B"
 416:         
 417:         size_names = ["B", "KB", "MB", "GB", "TB"]
 418:         i = 0
 419:         size = float(bytes_size)
 420:         
 421:         while size >= 1024.0 and i < len(size_names) - 1:
 422:             size /= 1024.0
 423:             i += 1
 424:         
 425:         if i == 0:
 426:             return f"{int(size)} {size_names[i]}"
 427:         else:
 428:             return f"{size:.1f} {size_names[i]}"
 429:     
 430:     def _log_error(self, path, error_message):
 431:         """Log access error"""
 432:         self.error_data.append({
 433:             'Path': path,
 434:             'Error': error_message,
 435:             'Timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
 436:         })
 437: 
 438: 
 439: class ExcelInventoryCreator:
 440:     """Creates Excel workbook with inventory data (existing functionality)"""
 441:     
 442:     def create_workbook(self, inventory_data, error_data, scanned_folder):
 443:         """Create and open Excel workbook"""
 444:         try:
 445:             # Create workbook
 446:             wb = Workbook()
 447:             
 448:             # Create inventory sheet
 449:             ws_inventory = wb.active
 450:             ws_inventory.title = "Inventory"
 451:             self._create_inventory_sheet(ws_inventory, inventory_data, scanned_folder)
 452:             
 453:             # Create errors sheet if there are errors
 454:             if error_data:
 455:                 ws_errors = wb.create_sheet("Access Errors")
 456:                 self._create_errors_sheet(ws_errors, error_data)
 457:             
 458:             # Save to temp file
 459:             temp_dir = tempfile.gettempdir()
 460:             timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
 461:             filename = f"Folder_Inventory_{timestamp}.xlsx"
 462:             filepath = os.path.join(temp_dir, filename)
 463:             
 464:             wb.save(filepath)
 465:             
 466:             # Open in Excel
 467:             self._open_excel_file(filepath)
 468:             
 469:         except Exception as e:
 470:             raise Exception(f"Failed to create Excel file: {str(e)}")
 471:     
 472:     def _create_inventory_sheet(self, worksheet, data, scanned_folder):
 473:         """Create the main inventory sheet"""
 474:         # Header
 475:         worksheet['A1'] = f"Folder Inventory: {scanned_folder}"
 476:         worksheet['A1'].font = Font(bold=True, size=14)
 477:         worksheet['A2'] = f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
 478:         worksheet['A3'] = f"Total Items: {len(data):,}"
 479:         
 480:         # Column headers
 481:         headers = ['Name', 'Full Path', 'Type', 'Size', 'Modified Date']
 482:         for col, header in enumerate(headers, 1):
 483:             cell = worksheet.cell(row=5, column=col, value=header)
 484:             cell.font = Font(bold=True)
 485:             cell.fill = PatternFill(start_color="90EE90", end_color="90EE90", fill_type="solid")
 486:         
 487:         # Data rows
 488:         for row, item in enumerate(data, 6):
 489:             worksheet.cell(row=row, column=1, value=item['Name'])
 490:             worksheet.cell(row=row, column=2, value=item['Full Path'])
 491:             worksheet.cell(row=row, column=3, value=item['Type'])
 492:             worksheet.cell(row=row, column=4, value=item['Size'])
 493:             worksheet.cell(row=row, column=5, value=item['Modified Date'])
 494:         
 495:         # Auto-adjust column widths
 496:         for column in worksheet.columns:
 497:             max_length = 0
 498:             column_letter = column[0].column_letter
 499:             for cell in column:
 500:                 try:
 501:                     if len(str(cell.value)) > max_length:
 502:                         max_length = len(str(cell.value))
 503:                 except:
 504:                     pass
 505:             adjusted_width = min(max_length + 2, 50)
 506:             worksheet.column_dimensions[column_letter].width = adjusted_width
 507:     
 508:     def _create_errors_sheet(self, worksheet, error_data):
 509:         """Create the errors sheet"""
 510:         # Header
 511:         worksheet['A1'] = "Access Errors"
 512:         worksheet['A1'].font = Font(bold=True, size=14)
 513:         worksheet['A2'] = f"Total Errors: {len(error_data)}"
 514:         
 515:         # Column headers
 516:         headers = ['Path', 'Error', 'Timestamp']
 517:         for col, header in enumerate(headers, 1):
 518:             cell = worksheet.cell(row=4, column=col, value=header)
 519:             cell.font = Font(bold=True)
 520:             cell.fill = PatternFill(start_color="FFB6C1", end_color="FFB6C1", fill_type="solid")
 521:         
 522:         # Error rows
 523:         for row, error in enumerate(error_data, 5):
 524:             worksheet.cell(row=row, column=1, value=error['Path'])
 525:             worksheet.cell(row=row, column=2, value=error['Error'])
 526:             worksheet.cell(row=row, column=3, value=error['Timestamp'])
 527:         
 528:         # Auto-adjust column widths
 529:         for column in worksheet.columns:
 530:             max_length = 0
 531:             column_letter = column[0].column_letter
 532:             for cell in column:
 533:                 try:
 534:                     if len(str(cell.value)) > max_length:
 535:                         max_length = len(str(cell.value))
 536:                 except:
 537:                     pass
 538:             adjusted_width = min(max_length + 2, 50)
 539:             worksheet.column_dimensions[column_letter].width = adjusted_width
 540:     
 541:     def _open_excel_file(self, filepath):
 542:         """Open Excel file"""
 543:         try:
 544:             os.startfile(filepath)
 545:         except:
 546:             try:
 547:                 subprocess.run(['start', 'excel', filepath], shell=True)
 548:             except:
 549:                 messagebox.showinfo("File Created", f"Excel file created at:\n{filepath}")
 550: 
 551: 
 552: # Integration function for taskbar.py
 553: def add_folder_inventory_to_taskbar(taskbar_instance):
 554:     """Add Folder Inventory button to the taskbar"""
 555:     
 556:     def show_inventory_dialog():
 557:         """Show the folder inventory dialog"""
 558:         dialog = FolderInventoryDialog(taskbar_instance.root)
 559:         dialog.lift()
 560:         dialog.focus_force()
 561:     
 562:     # Create the inventory button
 563:     inventory_btn = tk.Button(taskbar_instance.main_frame, text="Inventory", 
 564:                              bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 565:                              relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, 
 566:                              cursor='hand2', activebackground=Colors.HOVER_GREEN, 
 567:                              bd=0, padx=15, command=show_inventory_dialog)
 568:     
 569:     return inventory_btn

────────────────────────────────────────────────────────────────────────────────
FILE: explorer_utils.py
────────────────────────────────────────────────────────────────────────────────
Path: explorer_utils.py
Size: 8.9 KB
Lines: 226 total, 183 non-empty
Characters: 8,916
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # explorer_utils.py
   2: """
   3: Utility functions for detecting and interacting with File Explorer windows
   4: """
   5: 
   6: import win32gui
   7: import win32process
   8: import psutil
   9: from pathlib import Path
  10: import os
  11: 
  12: class ExplorerDetector:
  13:     """Utility class for detecting open File Explorer windows"""
  14:     
  15:     @staticmethod
  16:     def get_open_explorer_folders():
  17:         """
  18:         Get a list of currently open File Explorer folder paths
  19:         Returns list of folder paths, ordered by most recently active
  20:         """
  21:         explorer_folders = []
  22:         
  23:         def enum_window_callback(hwnd, folders_list):
  24:             """Callback function for window enumeration"""
  25:             try:
  26:                 # Check if window is visible
  27:                 if not win32gui.IsWindowVisible(hwnd):
  28:                     return True
  29:                 
  30:                 # Get window class name
  31:                 class_name = win32gui.GetClassName(hwnd)
  32:                 
  33:                 # Check if it's a File Explorer window
  34:                 if class_name in ['CabinetWClass', 'ExploreWClass']:
  35:                     # Get process information
  36:                     _, pid = win32process.GetWindowThreadProcessId(hwnd)
  37:                     
  38:                     try:
  39:                         process = psutil.Process(pid)
  40:                         if process.name().lower() == 'explorer.exe':
  41:                             # Try to get the folder path from the window
  42:                             folder_path = ExplorerDetector._get_explorer_path(hwnd)
  43:                             if folder_path and os.path.exists(folder_path):
  44:                                 folders_list.append({
  45:                                     'path': folder_path,
  46:                                     'hwnd': hwnd,
  47:                                     'title': win32gui.GetWindowText(hwnd)
  48:                                 })
  49:                     except (psutil.NoSuchProcess, psutil.AccessDenied):
  50:                         pass
  51:                         
  52:             except Exception as e:
  53:                 print(f"Error processing window {hwnd}: {e}")
  54:                 
  55:             return True
  56:         
  57:         # Enumerate all top-level windows
  58:         win32gui.EnumWindows(enum_window_callback, explorer_folders)
  59:         
  60:         # Sort by Z-order (topmost first) - approximate by hwnd order
  61:         # The most recently active windows typically have higher hwnd values
  62:         explorer_folders.sort(key=lambda x: x['hwnd'], reverse=True)
  63:         
  64:         return [folder['path'] for folder in explorer_folders]
  65:     
  66:     @staticmethod
  67:     def _get_explorer_path(hwnd):
  68:         """
  69:         Extract the current folder path from a File Explorer window
  70:         This uses the window title to determine the path
  71:         """
  72:         try:
  73:             window_title = win32gui.GetWindowText(hwnd)
  74:             
  75:             # File Explorer titles usually contain the folder name
  76:             # Try different approaches to extract the path
  77:             
  78:             # Method 1: Direct path in title (Windows 11 style)
  79:             normalized_title = os.path.normpath(window_title)
  80:             if os.path.exists(normalized_title):
  81:                 return normalized_title
  82:             
  83:             # Method 2: Parse common File Explorer title formats
  84:             # Remove common prefixes/suffixes
  85:             title_cleaned = window_title
  86:             
  87:             # Remove " - File Explorer" suffix if present
  88:             if title_cleaned.endswith(' - File Explorer'):
  89:                 title_cleaned = title_cleaned[:-15]
  90:             
  91:             # Remove " - Windows Explorer" suffix if present  
  92:             if title_cleaned.endswith(' - Windows Explorer'):
  93:                 title_cleaned = title_cleaned[:-18]
  94:             
  95:             # Normalize and check if cleaned title is a valid path
  96:             title_cleaned = os.path.normpath(title_cleaned)
  97:             if os.path.exists(title_cleaned):
  98:                 return title_cleaned
  99:             
 100:             # Method 3: Try to construct common paths
 101:             common_paths = [
 102:                 os.path.expanduser('~'),  # User home
 103:                 os.path.expanduser('~/Desktop'),
 104:                 os.path.expanduser('~/Documents'),
 105:                 os.path.expanduser('~/Downloads'),
 106:                 'C:\\',
 107:                 'D:\\',
 108:             ]
 109:             
 110:             for base_path in common_paths:
 111:                 potential_path = os.path.normpath(os.path.join(base_path, title_cleaned))
 112:                 if os.path.exists(potential_path):
 113:                     return potential_path
 114:             
 115:             # Method 4: Check if it's a special folder name
 116:             special_folders = {
 117:                 'Desktop': os.path.expanduser('~/Desktop'),
 118:                 'Documents': os.path.expanduser('~/Documents'),
 119:                 'Downloads': os.path.expanduser('~/Downloads'),
 120:                 'Pictures': os.path.expanduser('~/Pictures'),
 121:                 'Videos': os.path.expanduser('~/Videos'),
 122:                 'Music': os.path.expanduser('~/Music'),
 123:                 'This PC': os.path.expanduser('~'),
 124:                 'Computer': os.path.expanduser('~'),
 125:             }
 126:             
 127:             if title_cleaned in special_folders:
 128:                 return os.path.normpath(special_folders[title_cleaned])
 129:             
 130:             # Method 5: Advanced COM-based approach (fallback)
 131:             try:
 132:                 return ExplorerDetector._get_explorer_path_com(hwnd)
 133:             except:
 134:                 pass
 135:             
 136:             return None
 137:             
 138:         except Exception as e:
 139:             print(f"Error getting explorer path for window {hwnd}: {e}")
 140:             return None
 141:     
 142:     @staticmethod
 143:     def _get_explorer_path_com(hwnd):
 144:         """
 145:         Use COM interface to get the actual path from File Explorer
 146:         This is more reliable but also more complex
 147:         """
 148:         try:
 149:             import win32com.client
 150:             
 151:             # Get Shell Windows collection
 152:             shell_windows = win32com.client.Dispatch("Shell.Application").Windows()
 153:             
 154:             for window in shell_windows:
 155:                 try:
 156:                     # Check if this window matches our hwnd
 157:                     if hasattr(window, 'HWND') and window.HWND == hwnd:
 158:                         # Get the location URL and convert to path
 159:                         location = window.LocationURL
 160:                         if location.startswith('file:///'):
 161:                             # Convert file URL to local path
 162:                             import urllib.parse
 163:                             path = urllib.parse.unquote(location[8:])  # Remove 'file:///'
 164:                             path = path.replace('/', '\\')  # Convert to Windows path
 165:                             # Normalize the path to fix any mixed slash issues
 166:                             path = os.path.normpath(path)
 167:                             if os.path.exists(path):
 168:                                 return path
 169:                 except:
 170:                     continue
 171:                     
 172:         except Exception as e:
 173:             print(f"COM approach failed: {e}")
 174:             
 175:         return None
 176:     
 177:     @staticmethod
 178:     def get_topmost_explorer_folder():
 179:         """
 180:         Get the path of the topmost (most recently active) File Explorer folder
 181:         Returns None if no File Explorer windows are open
 182:         """
 183:         folders = ExplorerDetector.get_open_explorer_folders()
 184:         return folders[0] if folders else None
 185:     
 186:     @staticmethod
 187:     def get_best_default_folder():
 188:         """
 189:         Get the best folder to use as default for scanning
 190:         Priority: 1) Topmost Explorer folder, 2) User Documents, 3) User Home
 191:         All paths are normalized to use consistent backslashes
 192:         """
 193:         # Try to get topmost explorer folder first
 194:         explorer_folder = ExplorerDetector.get_topmost_explorer_folder()
 195:         if explorer_folder:
 196:             return os.path.normpath(explorer_folder)
 197:         
 198:         # Fallback to Documents folder
 199:         documents_folder = os.path.expanduser('~/Documents')
 200:         if os.path.exists(documents_folder):
 201:             return os.path.normpath(documents_folder)
 202:         
 203:         # Final fallback to user home
 204:         return os.path.normpath(os.path.expanduser('~'))
 205: 
 206: 
 207: # Test function for debugging
 208: def test_explorer_detection():
 209:     """Test function to see what Explorer windows are detected"""
 210:     print("Testing Explorer Detection...")
 211:     
 212:     folders = ExplorerDetector.get_open_explorer_folders()
 213:     print(f"Found {len(folders)} open File Explorer folders:")
 214:     
 215:     for i, folder in enumerate(folders, 1):
 216:         print(f"  {i}. {folder}")
 217:     
 218:     topmost = ExplorerDetector.get_topmost_explorer_folder()
 219:     print(f"\nTopmost folder: {topmost}")
 220:     
 221:     best_default = ExplorerDetector.get_best_default_folder()
 222:     print(f"Best default folder: {best_default}")
 223: 
 224: 
 225: if __name__ == "__main__":
 226:     test_explorer_detection()

────────────────────────────────────────────────────────────────────────────────
FILE: folder_inventory.py
────────────────────────────────────────────────────────────────────────────────
Path: folder_inventory.py
Size: 24.5 KB
Lines: 593 total, 478 non-empty
Characters: 24,485
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # enhanced_folder_inventory.py
   2: """
   3: Enhanced Folder Inventory feature for SuiteView Taskbar
   4: Adds View option with Excel-like filtering capabilities
   5: """
   6: 
   7: import os
   8: import threading
   9: import time
  10: from datetime import datetime
  11: from pathlib import Path
  12: import tkinter as tk
  13: from tkinter import ttk, filedialog, messagebox
  14: from openpyxl import Workbook
  15: from openpyxl.styles import Font, PatternFill
  16: import tempfile
  17: import subprocess
  18: from inventory_view_window import InventoryViewWindow
  19: from explorer_utils import ExplorerDetector
  20: 
  21: from config import Colors, Fonts, Dimensions
  22: from ui_components import CustomDialog, FormField, WarningDialog, ErrorDialog
  23: from utils import UIUtils
  24: 
  25: class FolderInventoryDialog(CustomDialog):
  26:     """Enhanced dialog for configuring folder inventory scan with View/Print options"""
  27:     
  28:     def __init__(self, parent):
  29:         super().__init__(parent, "Folder Inventory", width=500, height=400, resizable=True)
  30:         
  31:         self.selected_folder = ""
  32:         self.scan_thread = None
  33:         self.cancel_scan = False
  34:         self.progress_window = None
  35:         
  36:         self.create_form()
  37:         self.add_buttons()
  38:         
  39:         # Auto-populate folder field with topmost Explorer folder (NEW)
  40:         self.auto_populate_folder()
  41:         
  42:         # Set focus on folder field
  43:         self.folder_field.widget.focus_set()
  44:     
  45:     
  46:     
  47:     def auto_populate_folder(self):
  48:         """Auto-populate the folder field with the topmost open File Explorer folder"""
  49:         try:
  50:             best_folder = ExplorerDetector.get_best_default_folder()
  51:             if best_folder:
  52:                 self.folder_field.set(best_folder)
  53:                 self.selected_folder = best_folder
  54:         except Exception as e:
  55:             print(f"Error auto-populating folder: {e}")
  56:             # Fallback to user home directory
  57:             try:
  58:                 fallback_folder = os.path.expanduser('~')
  59:                 self.folder_field.set(fallback_folder)
  60:                 self.selected_folder = fallback_folder
  61:             except:
  62:                 pass  # If all else fails, leave empty
  63:         
  64:     def create_form(self):
  65:         """Create the configuration form"""
  66:         # Folder selection using FormField with stacked layout
  67:         folder_container = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
  68:         folder_container.pack(fill=tk.X, pady=(0, 10))
  69:         
  70:         self.folder_field = FormField(folder_container, "Folder to scan:", layout='stacked')
  71:         self.folder_field.pack(side=tk.LEFT, fill=tk.X, expand=True)
  72:         
  73:         browse_btn = tk.Button(folder_container, text="Browse...", 
  74:                             command=self.browse_folder,
  75:                             bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
  76:                             font=Fonts.DIALOG_BUTTON, cursor='hand2')
  77:         browse_btn.pack(side=tk.RIGHT, padx=(5, 0))
  78: 
  79:         # Depth selection
  80:         self.depth_field = FormField(
  81:             self.dialog_content, "Scan depth:", 
  82:             field_type='combobox',
  83:             values=["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Unlimited"],
  84:             width=15
  85:         )
  86:             
  87:         self.depth_field.set("1")
  88:         self.depth_field.widget.configure(state='readonly')
  89:         self.depth_field.pack(fill=tk.X, pady=5)
  90:         
  91:         # Content type selection
  92:         content_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
  93:         content_frame.pack(fill=tk.X, pady=10)
  94:         
  95:         tk.Label(content_frame, text="Include:", bg=Colors.LIGHT_GREEN, 
  96:                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).pack(anchor='w')
  97:         
  98:         self.content_type = tk.StringVar(value="both")
  99:         
 100:         radio_frame = tk.Frame(content_frame, bg=Colors.LIGHT_GREEN)
 101:         radio_frame.pack(fill=tk.X, pady=5)
 102:         
 103:         tk.Radiobutton(radio_frame, text="Files Only", variable=self.content_type, 
 104:                       value="files", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 105:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
 106:         
 107:         tk.Radiobutton(radio_frame, text="Folders Only", variable=self.content_type, 
 108:                       value="folders", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 109:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
 110:         
 111:         tk.Radiobutton(radio_frame, text="Both", variable=self.content_type, 
 112:                       value="both", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 113:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
 114:         
 115:         # Output option selection (NEW)
 116:         output_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
 117:         output_frame.pack(fill=tk.X, pady=10)
 118:         
 119:         tk.Label(output_frame, text="Output to:", bg=Colors.LIGHT_GREEN, 
 120:                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).pack(anchor='w')
 121:         
 122:         self.output_type = tk.StringVar(value="view")  # Default to View
 123:         
 124:         output_radio_frame = tk.Frame(output_frame, bg=Colors.LIGHT_GREEN)
 125:         output_radio_frame.pack(fill=tk.X, pady=5)
 126:         
 127:         tk.Radiobutton(output_radio_frame, text="View (Interactive)", variable=self.output_type, 
 128:                       value="view", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 129:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
 130:         
 131:         tk.Radiobutton(output_radio_frame, text="Excel File", variable=self.output_type, 
 132:                       value="excel", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 133:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
 134:         
 135:         # Information text
 136:         info_text = ("View will show results in an interactive grid with filtering.\n"
 137:                     "Excel will create a spreadsheet file.\n"
 138:                     "Large operations (>20,000 items) will show a warning.")
 139:         info_label = tk.Label(self.dialog_content, text=info_text, 
 140:                              bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 141:                              font=(Fonts.DIALOG_LABEL[0], Fonts.DIALOG_LABEL[1]-1),
 142:                              wraplength=450, justify=tk.LEFT)
 143:         info_label.pack(pady=10)
 144:     
 145:     def browse_folder(self):
 146:         """Browse for folder to scan"""
 147:         folder = filedialog.askdirectory(parent=self, title="Select Folder to Inventory")
 148:         if folder:
 149:             self.folder_field.set(folder)
 150:             self.selected_folder = folder
 151:     
 152:     def add_buttons(self):
 153:         """Add Start and Cancel buttons"""
 154:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 155:         button_container.pack(expand=True)
 156:         
 157:         start_btn = tk.Button(button_container, text="Start Scan", 
 158:                              bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 159:                              command=self.start_scan, width=Dimensions.DIALOG_BUTTON_WIDTH,
 160:                              font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1,
 161:                              cursor='hand2')
 162:         start_btn.pack(side=tk.LEFT, padx=10)
 163:         
 164:         cancel_btn = tk.Button(button_container, text="Cancel", 
 165:                               bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 166:                               command=self.cancel, width=Dimensions.DIALOG_BUTTON_WIDTH,
 167:                               font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 168:         cancel_btn.pack(side=tk.LEFT, padx=10)
 169:         
 170:         start_btn.focus_set()
 171:     
 172:     def start_scan(self):
 173:         """Start the folder inventory scan"""
 174:         folder = self.folder_field.get().strip()
 175:         if not folder:
 176:             WarningDialog.show(self, "Invalid Input", "Please select a folder to scan.")
 177:             return
 178:         
 179:         if not os.path.exists(folder):
 180:             ErrorDialog.show(self, "Folder Not Found", f"The selected folder does not exist:\n{folder}")
 181:             return
 182:         
 183:         # Get scan parameters
 184:         depth_str = self.depth_field.get()
 185:         max_depth = None if depth_str == "Unlimited" else int(depth_str)
 186:         content_type = self.content_type.get()
 187:         output_type = self.output_type.get()
 188:         
 189:         # Quick estimation for large operation warning
 190:         if self.should_warn_large_operation(folder, max_depth):
 191:             result = WarningDialog.show(self, "Large Operation Warning", 
 192:                                        "This operation may scan more than 20,000 items and could take several minutes.\n\n"
 193:                                        "Do you want to continue?")
 194:             if not result:
 195:                 return
 196:         
 197:         # Start the scan
 198:         self.destroy()
 199:         self.start_inventory_scan(folder, max_depth, content_type, output_type)
 200:     
 201:     def should_warn_large_operation(self, folder, max_depth):
 202:         """Quick check to estimate if operation will be large"""
 203:         try:
 204:             sample_count = 0
 205:             with os.scandir(folder) as entries:
 206:                 for entry in entries:
 207:                     sample_count += 1
 208:                     if sample_count >= 1000:
 209:                         break
 210:             
 211:             if sample_count >= 1000:
 212:                 return True
 213:             
 214:             if max_depth is None or max_depth > 1:
 215:                 with os.scandir(folder) as entries:
 216:                     for entry in entries:
 217:                         if entry.is_dir():
 218:                             return True
 219:             
 220:             return False
 221:         except:
 222:             return False
 223:     
 224:     def start_inventory_scan(self, folder, max_depth, content_type, output_type):
 225:         """Start the actual inventory scan in background thread"""
 226:         self.cancel_scan = False
 227:         
 228:         # Create progress window
 229:         self.progress_window = ProgressWindow(self.parent, self.cancel_scan_operation)
 230:         
 231:         # Start scan in background thread
 232:         self.scan_thread = threading.Thread(
 233:             target=self.perform_scan,
 234:             args=(folder, max_depth, content_type, output_type),
 235:             daemon=True
 236:         )
 237:         self.scan_thread.start()
 238:     
 239:     def cancel_scan_operation(self):
 240:         """Cancel the running scan operation"""
 241:         self.cancel_scan = True
 242:         if self.progress_window:
 243:             self.progress_window.destroy()
 244:     
 245:     def perform_scan(self, folder, max_depth, content_type, output_type):
 246:         """Perform the actual folder scan (runs in background thread)"""
 247:         try:
 248:             scanner = FolderScanner(folder, max_depth, content_type, self.update_progress)
 249:             inventory_data, error_data = scanner.scan()
 250:             
 251:             if not self.cancel_scan:
 252:                 if output_type == "excel":
 253:                     # Create Excel file (existing functionality)
 254:                     excel_creator = ExcelInventoryCreator()
 255:                     excel_creator.create_workbook(inventory_data, error_data, folder)
 256:                 else:
 257:                     # Show in interactive view (NEW)
 258:                     scan_info = {
 259:                         'folder': folder,
 260:                         'generated': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
 261:                         'total_items': len(inventory_data),
 262:                         'max_depth': max_depth,
 263:                         'content_type': content_type
 264:                     }
 265:                     self.show_inventory_view(inventory_data, error_data, scan_info)
 266:                 
 267:                 # Close progress window
 268:                 if self.progress_window:
 269:                     self.progress_window.after(0, self.progress_window.destroy)
 270:                 
 271:         except Exception as e:
 272:             # Show error in main thread
 273:             if self.progress_window:
 274:                 self.progress_window.after(0, lambda: self.show_scan_error(str(e)))
 275:     
 276:     def show_inventory_view(self, inventory_data, error_data, scan_info):
 277:         """Show the inventory data in an interactive view"""
 278:         if self.progress_window:
 279:             self.progress_window.after(0, lambda: InventoryViewWindow(
 280:                 self.parent, inventory_data, error_data, scan_info))
 281:     
 282:     def update_progress(self, count, current_path):
 283:         """Update progress display (called from background thread)"""
 284:         if self.progress_window and not self.cancel_scan:
 285:             self.progress_window.after(0, lambda: self.progress_window.update_progress(count, current_path))
 286:     
 287:     def show_scan_error(self, error_message):
 288:         """Show scan error (called in main thread)"""
 289:         if self.progress_window:
 290:             self.progress_window.destroy()
 291:         ErrorDialog.show(self.parent, "Scan Error", f"An error occurred during scanning:\n{error_message}")
 292: 
 293: 
 294: class ProgressWindow(CustomDialog):
 295:     """Progress window for folder scanning"""
 296:     
 297:     def __init__(self, parent, cancel_callback):
 298:         super().__init__(parent, "Scanning Folder", width=450, height=200)
 299:         
 300:         self.cancel_callback = cancel_callback
 301:         
 302:         # Progress info
 303:         self.progress_label = tk.Label(self.dialog_content, text="Starting scan...", 
 304:                                       bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 305:                                       font=Fonts.DIALOG_LABEL, wraplength=400)
 306:         self.progress_label.pack(pady=10)
 307:         
 308:         self.count_label = tk.Label(self.dialog_content, text="Items processed: 0", 
 309:                                    bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 310:                                    font=Fonts.DIALOG_LABEL)
 311:         self.count_label.pack(pady=5)
 312:         
 313:         self.path_label = tk.Label(self.dialog_content, text="", 
 314:                                   bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 315:                                   font=(Fonts.DIALOG_LABEL[0], Fonts.DIALOG_LABEL[1]-1),
 316:                                   wraplength=400, anchor='w')
 317:         self.path_label.pack(pady=5, fill=tk.X)
 318:         
 319:         # Cancel button
 320:         cancel_btn = tk.Button(self.button_frame, text="Cancel Scan", 
 321:                               bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 322:                               command=self.cancel_callback, width=12,
 323:                               font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 324:         cancel_btn.pack()
 325:         
 326:         # Override close button to call cancel
 327:         self.protocol("WM_DELETE_WINDOW", self.cancel_callback)
 328:     
 329:     def update_progress(self, count, current_path):
 330:         """Update progress display"""
 331:         self.count_label.config(text=f"Items processed: {count:,}")
 332:         
 333:         # Truncate long paths
 334:         display_path = current_path
 335:         if len(display_path) > 60:
 336:             display_path = "..." + display_path[-57:]
 337:         
 338:         self.path_label.config(text=f"Current: {display_path}")
 339: 
 340: 
 341: class FolderScanner:
 342:     """Core folder scanning logic"""
 343:     
 344:     def __init__(self, root_folder, max_depth, content_type, progress_callback):
 345:         self.root_folder = root_folder
 346:         self.max_depth = max_depth
 347:         self.content_type = content_type
 348:         self.progress_callback = progress_callback
 349:         self.cancel_scan = False
 350:         
 351:         self.inventory_data = []
 352:         self.error_data = []
 353:         self.item_count = 0
 354:     
 355:     def scan(self):
 356:         """Main scan method"""
 357:         self._scan_directory(self.root_folder, 0)
 358:         return self.inventory_data, self.error_data
 359:     
 360:     def _scan_directory(self, directory, current_depth):
 361:         """Recursively scan directory"""
 362:         if self.cancel_scan:
 363:             return
 364:         
 365:         # Check depth limit
 366:         if self.max_depth is not None and current_depth >= self.max_depth:
 367:             return
 368:         
 369:         try:
 370:             with os.scandir(directory) as entries:
 371:                 for entry in entries:
 372:                     if self.cancel_scan:
 373:                         return
 374:                     
 375:                     try:
 376:                         self._process_entry(entry, current_depth)
 377:                     except Exception as e:
 378:                         self._log_error(entry.path, str(e))
 379:                     
 380:                     # Update progress every 100 items
 381:                     if self.item_count % 100 == 0:
 382:                         self.progress_callback(self.item_count, entry.path)
 383:         
 384:         except Exception as e:
 385:             self._log_error(directory, str(e))
 386:     
 387:     def _process_entry(self, entry, current_depth):
 388:         """Process a single file/folder entry"""
 389:         is_file = entry.is_file()
 390:         is_dir = entry.is_dir()
 391:         
 392:         # Check if we should include this type
 393:         if self.content_type == "files" and not is_file:
 394:             pass  # Skip folders
 395:         elif self.content_type == "folders" and not is_dir:
 396:             pass  # Skip files
 397:         else:
 398:             # Include this item
 399:             self._add_inventory_item(entry, is_file)
 400:         
 401:         # Recurse into subdirectories
 402:         if is_dir:
 403:             self._scan_directory(entry.path, current_depth + 1)
 404:     
 405:     def _add_inventory_item(self, entry, is_file):
 406:         """Add item to inventory data"""
 407:         try:
 408:             stat_info = entry.stat()
 409:             
 410:             # Get size (only for files)
 411:             if is_file:
 412:                 size_bytes = stat_info.st_size
 413:                 size_human = self._format_size(size_bytes)
 414:             else:
 415:                 size_bytes = 0
 416:                 size_human = "N/A"
 417:             
 418:             # Get modified date
 419:             modified_date = datetime.fromtimestamp(stat_info.st_mtime).strftime("%Y-%m-%d %H:%M:%S")
 420:             
 421:             item_data = {
 422:                 'Name': entry.name,
 423:                 'Full Path': entry.path,
 424:                 'Type': 'File' if is_file else 'Folder',
 425:                 'Size (Bytes)': size_bytes if is_file else '',
 426:                 'Size': size_human,
 427:                 'Modified Date': modified_date
 428:             }
 429:             
 430:             self.inventory_data.append(item_data)
 431:             self.item_count += 1
 432:             
 433:         except Exception as e:
 434:             self._log_error(entry.path, str(e))
 435:     
 436:     def _format_size(self, bytes_size):
 437:         """Format file size in human readable format"""
 438:         if bytes_size == 0:
 439:             return "0 B"
 440:         
 441:         size_names = ["B", "KB", "MB", "GB", "TB"]
 442:         i = 0
 443:         size = float(bytes_size)
 444:         
 445:         while size >= 1024.0 and i < len(size_names) - 1:
 446:             size /= 1024.0
 447:             i += 1
 448:         
 449:         if i == 0:
 450:             return f"{int(size)} {size_names[i]}"
 451:         else:
 452:             return f"{size:.1f} {size_names[i]}"
 453:     
 454:     def _log_error(self, path, error_message):
 455:         """Log access error"""
 456:         self.error_data.append({
 457:             'Path': path,
 458:             'Error': error_message,
 459:             'Timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
 460:         })
 461: 
 462: 
 463: class ExcelInventoryCreator:
 464:     """Creates Excel workbook with inventory data (existing functionality)"""
 465:     
 466:     def create_workbook(self, inventory_data, error_data, scanned_folder):
 467:         """Create and open Excel workbook"""
 468:         try:
 469:             # Create workbook
 470:             wb = Workbook()
 471:             
 472:             # Create inventory sheet
 473:             ws_inventory = wb.active
 474:             ws_inventory.title = "Inventory"
 475:             self._create_inventory_sheet(ws_inventory, inventory_data, scanned_folder)
 476:             
 477:             # Create errors sheet if there are errors
 478:             if error_data:
 479:                 ws_errors = wb.create_sheet("Access Errors")
 480:                 self._create_errors_sheet(ws_errors, error_data)
 481:             
 482:             # Save to temp file
 483:             temp_dir = tempfile.gettempdir()
 484:             timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
 485:             filename = f"Folder_Inventory_{timestamp}.xlsx"
 486:             filepath = os.path.join(temp_dir, filename)
 487:             
 488:             wb.save(filepath)
 489:             
 490:             # Open in Excel
 491:             self._open_excel_file(filepath)
 492:             
 493:         except Exception as e:
 494:             raise Exception(f"Failed to create Excel file: {str(e)}")
 495:     
 496:     def _create_inventory_sheet(self, worksheet, data, scanned_folder):
 497:         """Create the main inventory sheet"""
 498:         # Header
 499:         worksheet['A1'] = f"Folder Inventory: {scanned_folder}"
 500:         worksheet['A1'].font = Font(bold=True, size=14)
 501:         worksheet['A2'] = f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
 502:         worksheet['A3'] = f"Total Items: {len(data):,}"
 503:         
 504:         # Column headers
 505:         headers = ['Name', 'Full Path', 'Type', 'Size', 'Modified Date']
 506:         for col, header in enumerate(headers, 1):
 507:             cell = worksheet.cell(row=5, column=col, value=header)
 508:             cell.font = Font(bold=True)
 509:             cell.fill = PatternFill(start_color="90EE90", end_color="90EE90", fill_type="solid")
 510:         
 511:         # Data rows
 512:         for row, item in enumerate(data, 6):
 513:             worksheet.cell(row=row, column=1, value=item['Name'])
 514:             worksheet.cell(row=row, column=2, value=item['Full Path'])
 515:             worksheet.cell(row=row, column=3, value=item['Type'])
 516:             worksheet.cell(row=row, column=4, value=item['Size'])
 517:             worksheet.cell(row=row, column=5, value=item['Modified Date'])
 518:         
 519:         # Auto-adjust column widths
 520:         for column in worksheet.columns:
 521:             max_length = 0
 522:             column_letter = column[0].column_letter
 523:             for cell in column:
 524:                 try:
 525:                     if len(str(cell.value)) > max_length:
 526:                         max_length = len(str(cell.value))
 527:                 except:
 528:                     pass
 529:             adjusted_width = min(max_length + 2, 50)
 530:             worksheet.column_dimensions[column_letter].width = adjusted_width
 531:     
 532:     def _create_errors_sheet(self, worksheet, error_data):
 533:         """Create the errors sheet"""
 534:         # Header
 535:         worksheet['A1'] = "Access Errors"
 536:         worksheet['A1'].font = Font(bold=True, size=14)
 537:         worksheet['A2'] = f"Total Errors: {len(error_data)}"
 538:         
 539:         # Column headers
 540:         headers = ['Path', 'Error', 'Timestamp']
 541:         for col, header in enumerate(headers, 1):
 542:             cell = worksheet.cell(row=4, column=col, value=header)
 543:             cell.font = Font(bold=True)
 544:             cell.fill = PatternFill(start_color="FFB6C1", end_color="FFB6C1", fill_type="solid")
 545:         
 546:         # Error rows
 547:         for row, error in enumerate(error_data, 5):
 548:             worksheet.cell(row=row, column=1, value=error['Path'])
 549:             worksheet.cell(row=row, column=2, value=error['Error'])
 550:             worksheet.cell(row=row, column=3, value=error['Timestamp'])
 551:         
 552:         # Auto-adjust column widths
 553:         for column in worksheet.columns:
 554:             max_length = 0
 555:             column_letter = column[0].column_letter
 556:             for cell in column:
 557:                 try:
 558:                     if len(str(cell.value)) > max_length:
 559:                         max_length = len(str(cell.value))
 560:                 except:
 561:                     pass
 562:             adjusted_width = min(max_length + 2, 50)
 563:             worksheet.column_dimensions[column_letter].width = adjusted_width
 564:     
 565:     def _open_excel_file(self, filepath):
 566:         """Open Excel file"""
 567:         try:
 568:             os.startfile(filepath)
 569:         except:
 570:             try:
 571:                 subprocess.run(['start', 'excel', filepath], shell=True)
 572:             except:
 573:                 messagebox.showinfo("File Created", f"Excel file created at:\n{filepath}")
 574: 
 575: 
 576: # Integration function for taskbar.py
 577: def add_folder_inventory_to_taskbar(taskbar_instance):
 578:     """Add Folder Inventory button to the taskbar"""
 579:     
 580:     def show_inventory_dialog():
 581:         """Show the folder inventory dialog"""
 582:         dialog = FolderInventoryDialog(taskbar_instance.root)
 583:         dialog.lift()
 584:         dialog.focus_force()
 585:     
 586:     # Create the inventory button
 587:     inventory_btn = tk.Button(taskbar_instance.main_frame, text="Inventory", 
 588:                              bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 589:                              relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, 
 590:                              cursor='hand2', activebackground=Colors.HOVER_GREEN, 
 591:                              bd=0, padx=15, command=show_inventory_dialog)
 592:     
 593:     return inventory_btn

────────────────────────────────────────────────────────────────────────────────
FILE: inventory_view_window.py
────────────────────────────────────────────────────────────────────────────────
Path: inventory_view_window.py
Size: 21.1 KB
Lines: 498 total, 396 non-empty
Characters: 21,071
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # inventory_view_window.py
   2: """
   3: Interactive inventory view window with Excel-like filtering capabilities
   4: This component will be reused throughout the SuiteView project for data grids
   5: """
   6: 
   7: import tkinter as tk
   8: from tkinter import ttk, messagebox
   9: from datetime import datetime
  10: from config import Colors, Fonts, Dimensions
  11: from ui_components import CustomDialog
  12: 
  13: class InventoryViewWindow(tk.Toplevel):
  14:     """Interactive window for viewing inventory data with Excel-like filtering"""
  15:     
  16:     def __init__(self, parent, inventory_data, error_data, scan_info):
  17:         super().__init__(parent)
  18:         self.parent = parent
  19:         self.inventory_data = inventory_data.copy()  # Original data
  20:         self.filtered_data = inventory_data.copy()   # Current filtered data
  21:         self.error_data = error_data
  22:         self.scan_info = scan_info
  23:         
  24:         # Filter state tracking
  25:         self.active_filters = {}  # column_name -> set of selected values
  26:         self.column_unique_values = {}  # column_name -> list of unique values
  27:         
  28:         # Window setup
  29:         self.title("Folder Inventory - Interactive View")
  30:         self.configure(bg=Colors.DARK_GREEN)
  31:         self.attributes('-topmost', True)
  32:         self.geometry("1000x700")
  33:         
  34:         # Make window resizable
  35:         self.resizable(True, True)
  36:         
  37:         # Main container
  38:         self.main_frame = tk.Frame(self, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=2)
  39:         self.main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
  40:         
  41:         # Create header with scan information
  42:         self.create_header()
  43:         
  44:         # Create the filterable data grid
  45:         self.create_data_grid()
  46:         
  47:         # Create footer with action buttons
  48:         self.create_footer()
  49:         
  50:         # Initialize data
  51:         self.populate_grid()
  52:         self.update_stats()
  53:         
  54:         # Bind window close event
  55:         self.protocol("WM_DELETE_WINDOW", self.on_closing)
  56:         
  57:         # Center the window
  58:         self.center_window()
  59:     
  60:     def create_header(self):
  61:         """Create header with scan information"""
  62:         header_frame = tk.Frame(self.main_frame, bg=Colors.LIGHT_GREEN, relief=tk.RAISED, bd=1)
  63:         header_frame.pack(fill=tk.X, padx=2, pady=2)
  64:         
  65:         # Title
  66:         title_label = tk.Label(header_frame, text="📁 Folder Inventory Results", 
  67:                               bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
  68:                               font=('Arial', 14, 'bold'))
  69:         title_label.pack(pady=5)
  70:         
  71:         # Scan information in a grid
  72:         info_frame = tk.Frame(header_frame, bg=Colors.LIGHT_GREEN)
  73:         info_frame.pack(pady=5)
  74:         
  75:         # Row 1: Folder and Date
  76:         tk.Label(info_frame, text="Scanned Folder:", bg=Colors.LIGHT_GREEN, 
  77:                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).grid(row=0, column=0, sticky='w', padx=5)
  78:         tk.Label(info_frame, text=self.scan_info['folder'], bg=Colors.LIGHT_GREEN, 
  79:                 fg=Colors.DARK_GREEN, font=Fonts.DIALOG_LABEL).grid(row=0, column=1, sticky='w', padx=5)
  80:         
  81:         tk.Label(info_frame, text="Generated:", bg=Colors.LIGHT_GREEN, 
  82:                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).grid(row=0, column=2, sticky='w', padx=20)
  83:         tk.Label(info_frame, text=self.scan_info['generated'], bg=Colors.LIGHT_GREEN, 
  84:                 fg=Colors.DARK_GREEN, font=Fonts.DIALOG_LABEL).grid(row=0, column=3, sticky='w', padx=5)
  85:         
  86:         # Row 2: Total Items and Content Type
  87:         self.stats_label = tk.Label(info_frame, text="", bg=Colors.LIGHT_GREEN, 
  88:                                    fg=Colors.BLACK, font=Fonts.DIALOG_LABEL)
  89:         self.stats_label.grid(row=1, column=0, columnspan=2, sticky='w', padx=5, pady=5)
  90:         
  91:         content_type_text = {
  92:             'files': 'Files Only',
  93:             'folders': 'Folders Only', 
  94:             'both': 'Files and Folders'
  95:         }.get(self.scan_info['content_type'], 'Unknown')
  96:         
  97:         tk.Label(info_frame, text=f"Content: {content_type_text}", bg=Colors.LIGHT_GREEN, 
  98:                 fg=Colors.DARK_GREEN, font=Fonts.DIALOG_LABEL).grid(row=1, column=2, columnspan=2, sticky='w', padx=20)
  99:     
 100:     def create_data_grid(self):
 101:         """Create the main data grid with filtering"""
 102:         # Grid container
 103:         grid_frame = tk.Frame(self.main_frame, bg=Colors.LIGHT_GREEN, relief=tk.SUNKEN, bd=1)
 104:         grid_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
 105:         
 106:         # Create Treeview for the data grid
 107:         self.tree = ttk.Treeview(grid_frame, show='tree headings')
 108:         
 109:         # Define columns (excluding Size (Bytes) from display but keeping in data)
 110:         self.columns = ['Name', 'Full Path', 'Type', 'Size', 'Modified Date']
 111:         self.tree['columns'] = self.columns
 112:         
 113:         # Configure tree column (hidden)
 114:         self.tree.column('#0', width=0, stretch=False)
 115:         self.tree.heading('#0', text='')
 116:         
 117:         # Configure data columns
 118:         column_widths = {
 119:             'Name': 200,
 120:             'Full Path': 300,
 121:             'Type': 80,
 122:             'Size': 100,
 123:             'Modified Date': 150
 124:         }
 125:         
 126:         for col in self.columns:
 127:             self.tree.column(col, width=column_widths.get(col, 100), anchor='w')
 128:             # Create clickable headers for filtering
 129:             self.tree.heading(col, text=f"{col} ▼", command=lambda c=col: self.show_filter_menu(c))
 130:         
 131:         # Scrollbars
 132:         v_scrollbar = ttk.Scrollbar(grid_frame, orient=tk.VERTICAL, command=self.tree.yview)
 133:         h_scrollbar = ttk.Scrollbar(grid_frame, orient=tk.HORIZONTAL, command=self.tree.xview)
 134:         self.tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
 135:         
 136:         # Pack grid components
 137:         self.tree.grid(row=0, column=0, sticky='nsew')
 138:         v_scrollbar.grid(row=0, column=1, sticky='ns')
 139:         h_scrollbar.grid(row=1, column=0, sticky='ew')
 140:         
 141:         # Configure grid weights
 142:         grid_frame.grid_rowconfigure(0, weight=1)
 143:         grid_frame.grid_columnconfigure(0, weight=1)
 144:         
 145:         # Style the treeview
 146:         style = ttk.Style()
 147:         style.configure('Treeview', background=Colors.LIGHT_GREEN, 
 148:                        foreground=Colors.BLACK, fieldbackground=Colors.LIGHT_GREEN)
 149:         style.configure('Treeview.Heading', background=Colors.MEDIUM_GREEN,
 150:                        foreground=Colors.BLACK, font=Fonts.MENU_HEADER)
 151:     
 152:     def create_footer(self):
 153:         """Create footer with action buttons and filter status"""
 154:         footer_frame = tk.Frame(self.main_frame, bg=Colors.DARK_GREEN, height=50)
 155:         footer_frame.pack(fill=tk.X, side=tk.BOTTOM, padx=2, pady=2)
 156:         footer_frame.pack_propagate(False)
 157:         
 158:         # Left side - filter status
 159:         filter_frame = tk.Frame(footer_frame, bg=Colors.DARK_GREEN)
 160:         filter_frame.pack(side=tk.LEFT, fill=tk.Y)
 161:         
 162:         self.filter_status_label = tk.Label(filter_frame, text="No filters applied", 
 163:                                            bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 164:                                            font=Fonts.MENU_ITEM)
 165:         self.filter_status_label.pack(side=tk.LEFT, padx=10, pady=5)
 166:         
 167:         # Right side - action buttons
 168:         button_frame = tk.Frame(footer_frame, bg=Colors.DARK_GREEN)
 169:         button_frame.pack(side=tk.RIGHT, fill=tk.Y)
 170:         
 171:         # Clear Filters button
 172:         clear_btn = tk.Button(button_frame, text="Clear All Filters", 
 173:                              bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 174:                              relief=tk.RAISED, bd=1, cursor='hand2',
 175:                              font=Fonts.MENU_ITEM, padx=10,
 176:                              command=self.clear_all_filters)
 177:         clear_btn.pack(side=tk.LEFT, padx=5, pady=5)
 178:         
 179:         # Export to Excel button
 180:         export_btn = tk.Button(button_frame, text="Export to Excel", 
 181:                               bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 182:                               relief=tk.RAISED, bd=1, cursor='hand2',
 183:                               font=Fonts.MENU_ITEM, padx=10,
 184:                               command=self.export_to_excel)
 185:         export_btn.pack(side=tk.LEFT, padx=5, pady=5)
 186:         
 187:         # Close button
 188:         close_btn = tk.Button(button_frame, text="Close", 
 189:                              bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 190:                              relief=tk.RAISED, bd=1, cursor='hand2',
 191:                              font=Fonts.MENU_ITEM, padx=10,
 192:                              command=self.on_closing)
 193:         close_btn.pack(side=tk.LEFT, padx=5, pady=5)
 194:     
 195:     def populate_grid(self):
 196:         """Populate the grid with current filtered data"""
 197:         # Clear existing items
 198:         for item in self.tree.get_children():
 199:             self.tree.delete(item)
 200:         
 201:         # Add filtered data
 202:         for item in self.filtered_data:
 203:             values = [item[col] for col in self.columns]
 204:             self.tree.insert('', 'end', values=values)
 205:         
 206:         # Calculate unique values for each column (from original data for proper filtering)
 207:         self.calculate_unique_values()
 208:     
 209:     def calculate_unique_values(self):
 210:         """Calculate unique values for each column from original data"""
 211:         self.column_unique_values = {}
 212:         for col in self.columns:
 213:             unique_vals = set()
 214:             for item in self.inventory_data:
 215:                 val = item.get(col, '')
 216:                 if val != '':  # Don't include empty values
 217:                     unique_vals.add(str(val))
 218:             self.column_unique_values[col] = sorted(list(unique_vals))
 219:     
 220:     def show_filter_menu(self, column):
 221:         """Show filter menu for a specific column"""
 222:         FilterMenuDialog(self, column, self.column_unique_values[column], 
 223:                         self.active_filters.get(column, set()), self.apply_filter)
 224:     
 225:     def apply_filter(self, column, selected_values):
 226:         """Apply filter to a specific column"""
 227:         if selected_values:
 228:             self.active_filters[column] = set(selected_values)
 229:         else:
 230:             # Remove filter if no values selected
 231:             if column in self.active_filters:
 232:                 del self.active_filters[column]
 233:         
 234:         # Apply all filters
 235:         self.filter_data()
 236:         self.update_display()
 237:         self.update_filter_status()
 238:     
 239:     def filter_data(self):
 240:         """Apply all active filters to the data"""
 241:         self.filtered_data = []
 242:         
 243:         for item in self.inventory_data:
 244:             include_item = True
 245:             
 246:             # Check each active filter
 247:             for filter_col, filter_values in self.active_filters.items():
 248:                 item_value = str(item.get(filter_col, ''))
 249:                 if item_value not in filter_values:
 250:                     include_item = False
 251:                     break
 252:             
 253:             if include_item:
 254:                 self.filtered_data.append(item)
 255:     
 256:     def update_display(self):
 257:         """Update the grid display with filtered data"""
 258:         # Clear existing items
 259:         for item in self.tree.get_children():
 260:             self.tree.delete(item)
 261:         
 262:         # Add filtered data
 263:         for item in self.filtered_data:
 264:             values = [item[col] for col in self.columns]
 265:             self.tree.insert('', 'end', values=values)
 266:         
 267:         # Update stats
 268:         self.update_stats()
 269:     
 270:     def update_stats(self):
 271:         """Update the statistics display"""
 272:         total_original = len(self.inventory_data)
 273:         total_filtered = len(self.filtered_data)
 274:         
 275:         if total_filtered == total_original:
 276:             stats_text = f"Total Items: {total_original:,}"
 277:         else:
 278:             stats_text = f"Showing: {total_filtered:,} of {total_original:,} items"
 279:         
 280:         self.stats_label.config(text=stats_text)
 281:     
 282:     def update_filter_status(self):
 283:         """Update the filter status display"""
 284:         if not self.active_filters:
 285:             self.filter_status_label.config(text="No filters applied")
 286:         else:
 287:             filter_count = len(self.active_filters)
 288:             filter_text = f"{filter_count} filter{'s' if filter_count > 1 else ''} applied: "
 289:             filter_details = []
 290:             for col, values in self.active_filters.items():
 291:                 if len(values) == 1:
 292:                     filter_details.append(f"{col}={list(values)[0]}")
 293:                 else:
 294:                     filter_details.append(f"{col}({len(values)} values)")
 295:             filter_text += ", ".join(filter_details)
 296:             
 297:             # Truncate if too long
 298:             if len(filter_text) > 80:
 299:                 filter_text = filter_text[:77] + "..."
 300:             
 301:             self.filter_status_label.config(text=filter_text)
 302:     
 303:     def clear_all_filters(self):
 304:         """Clear all active filters"""
 305:         self.active_filters = {}
 306:         self.filtered_data = self.inventory_data.copy()
 307:         self.update_display()
 308:         self.update_filter_status()
 309:         
 310:         # Update column headers to remove filter indicators
 311:         for col in self.columns:
 312:             self.tree.heading(col, text=f"{col} ▼")
 313:     
 314:     def export_to_excel(self):
 315:         """Export the current filtered data to Excel"""
 316:         from folder_inventory import ExcelInventoryCreator
 317:         
 318:         try:
 319:             excel_creator = ExcelInventoryCreator()
 320:             excel_creator.create_workbook(self.filtered_data, self.error_data, self.scan_info['folder'])
 321:             messagebox.showinfo("Export Complete", "Filtered data has been exported to Excel.")
 322:         except Exception as e:
 323:             messagebox.showerror("Export Error", f"Failed to export to Excel:\n{str(e)}")
 324:     
 325:     def center_window(self):
 326:         """Center the window on screen"""
 327:         self.update_idletasks()
 328:         width = self.winfo_width()
 329:         height = self.winfo_height()
 330:         x = (self.winfo_screenwidth() // 2) - (width // 2)
 331:         y = (self.winfo_screenheight() // 2) - (height // 2)
 332:         self.geometry(f"{width}x{height}+{x}+{y}")
 333:     
 334:     def on_closing(self):
 335:         """Handle window closing"""
 336:         self.destroy()
 337: 
 338: 
 339: class FilterMenuDialog(CustomDialog):
 340:     """Dialog for selecting filter values for a column (Excel-like)"""
 341:     
 342:     def __init__(self, parent, column_name, unique_values, current_selection, apply_callback):
 343:         super().__init__(parent, f"Filter: {column_name}", width=350, height=400)
 344:         
 345:         self.column_name = column_name
 346:         self.unique_values = unique_values
 347:         self.current_selection = current_selection.copy()
 348:         self.apply_callback = apply_callback
 349:         
 350:         # If no current selection, default to all selected
 351:         if not self.current_selection:
 352:             self.current_selection = set(unique_values)
 353:         
 354:         self.create_filter_interface()
 355:         self.create_action_buttons()
 356:     
 357:     def create_filter_interface(self):
 358:         """Create the filter selection interface"""
 359:         # Search box
 360:         search_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
 361:         search_frame.pack(fill=tk.X, pady=5)
 362:         
 363:         tk.Label(search_frame, text="Search:", bg=Colors.LIGHT_GREEN, 
 364:                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).pack(side=tk.LEFT)
 365:         
 366:         self.search_var = tk.StringVar()
 367:         self.search_var.trace('w', self.filter_list)
 368:         search_entry = tk.Entry(search_frame, textvariable=self.search_var, 
 369:                                font=Fonts.DIALOG_LABEL)
 370:         search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
 371:         
 372:         # Select All / None buttons
 373:         select_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
 374:         select_frame.pack(fill=tk.X, pady=5)
 375:         
 376:         select_all_btn = tk.Button(select_frame, text="Select All", 
 377:                                   bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 378:                                   command=self.select_all, font=Fonts.DIALOG_LABEL)
 379:         select_all_btn.pack(side=tk.LEFT, padx=5)
 380:         
 381:         select_none_btn = tk.Button(select_frame, text="Select None", 
 382:                                    bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 383:                                    command=self.select_none, font=Fonts.DIALOG_LABEL)
 384:         select_none_btn.pack(side=tk.LEFT, padx=5)
 385:         
 386:         # Listbox with checkboxes (simulated with Treeview)
 387:         list_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
 388:         list_frame.pack(fill=tk.BOTH, expand=True, pady=5)
 389:         
 390:         # Create Treeview for checkbox list
 391:         self.filter_tree = ttk.Treeview(list_frame, show='tree', height=12)
 392:         self.filter_tree.column('#0', width=300)
 393:         
 394:         # Scrollbar for the list
 395:         filter_scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, 
 396:                                         command=self.filter_tree.yview)
 397:         self.filter_tree.configure(yscrollcommand=filter_scrollbar.set)
 398:         
 399:         self.filter_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
 400:         filter_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
 401:         
 402:         # Populate the list
 403:         self.populate_filter_list()
 404:         
 405:         # Bind double-click to toggle selection
 406:         self.filter_tree.bind('<Double-1>', self.toggle_item)
 407:         self.filter_tree.bind('<Return>', self.toggle_item)
 408:     
 409:     def populate_filter_list(self, search_text=""):
 410:         """Populate the filter list with checkboxes"""
 411:         # Clear existing items
 412:         for item in self.filter_tree.get_children():
 413:             self.filter_tree.delete(item)
 414:         
 415:         # Filter values based on search
 416:         filtered_values = [val for val in self.unique_values 
 417:                           if search_text.lower() in val.lower()] if search_text else self.unique_values
 418:         
 419:         # Add items with checkbox indicators
 420:         for value in filtered_values:
 421:             checkbox = "☑" if value in self.current_selection else "☐"
 422:             display_text = f"{checkbox} {value}"
 423:             item_id = self.filter_tree.insert('', 'end', text=display_text, values=[value])
 424:     
 425:     def filter_list(self, *args):
 426:         """Filter the list based on search text"""
 427:         search_text = self.search_var.get()
 428:         self.populate_filter_list(search_text)
 429:     
 430:     def toggle_item(self, event=None):
 431:         """Toggle selection of an item"""
 432:         selected_item = self.filter_tree.selection()
 433:         if not selected_item:
 434:             return
 435:         
 436:         item_id = selected_item[0]
 437:         values = self.filter_tree.item(item_id, 'values')
 438:         if values:
 439:             value = values[0]
 440:             
 441:             if value in self.current_selection:
 442:                 self.current_selection.remove(value)
 443:             else:
 444:                 self.current_selection.add(value)
 445:             
 446:             # Update display
 447:             search_text = self.search_var.get()
 448:             self.populate_filter_list(search_text)
 449:     
 450:     def select_all(self):
 451:         """Select all visible items"""
 452:         search_text = self.search_var.get()
 453:         filtered_values = [val for val in self.unique_values 
 454:                           if search_text.lower() in val.lower()] if search_text else self.unique_values
 455:         
 456:         for value in filtered_values:
 457:             self.current_selection.add(value)
 458:         
 459:         self.populate_filter_list(search_text)
 460:     
 461:     def select_none(self):
 462:         """Deselect all visible items"""
 463:         search_text = self.search_var.get()
 464:         filtered_values = [val for val in self.unique_values 
 465:                           if search_text.lower() in val.lower()] if search_text else self.unique_values
 466:         
 467:         for value in filtered_values:
 468:             self.current_selection.discard(value)
 469:         
 470:         self.populate_filter_list(search_text)
 471:     
 472:     def create_action_buttons(self):
 473:         """Create OK and Cancel buttons"""
 474:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 475:         button_container.pack(expand=True)
 476:         
 477:         ok_btn = tk.Button(button_container, text="OK", 
 478:                           bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 479:                           command=self.apply_filter, width=Dimensions.DIALOG_BUTTON_WIDTH,
 480:                           font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 481:         ok_btn.pack(side=tk.LEFT, padx=10)
 482:         
 483:         cancel_btn = tk.Button(button_container, text="Cancel", 
 484:                               bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 485:                               command=self.cancel, width=Dimensions.DIALOG_BUTTON_WIDTH,
 486:                               font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 487:         cancel_btn.pack(side=tk.LEFT, padx=10)
 488:         
 489:         ok_btn.focus_set()
 490:     
 491:     def apply_filter(self):
 492:         """Apply the selected filter"""
 493:         self.apply_callback(self.column_name, list(self.current_selection))
 494:         self.destroy()
 495:     
 496:     def cancel(self):
 497:         """Cancel without applying changes"""
 498:         self.destroy()

────────────────────────────────────────────────────────────────────────────────
FILE: links_manager.py
────────────────────────────────────────────────────────────────────────────────
Path: links_manager.py
Size: 11.1 KB
Lines: 306 total, 253 non-empty
Characters: 11,075
Type: Data management for links and categories
────────────────────────────────────────────────────────────────────────────────

   1: # links_manager.py
   2: """
   3: Data management for Quick Links
   4: Handles loading, saving, and CRUD operations for links
   5: """
   6: 
   7: import json
   8: import os
   9: from pathlib import Path
  10: from config import Paths, DEFAULT_CATEGORIES
  11: from utils import FileUtils  # Import FileUtils for path normalization
  12: 
  13: class LinksManager:
  14:     """Manages saved links with categories"""
  15:     
  16:     def __init__(self):
  17:         # Ensure config directory exists
  18:         Paths.ensure_config_dir()
  19:         self.config_file = Paths.LINKS_FILE
  20:         self.links = self.load_links()
  21:     
  22:     def load_links(self):
  23:         """Load links from config file"""
  24:         try:
  25:             if self.config_file.exists():
  26:                 with open(self.config_file, 'r', encoding='utf-8') as f:
  27:                     data = json.load(f)
  28:                     # Validate structure
  29:                     if "categories" in data and "links" in data:
  30:                         # Fix any existing path issues
  31:                         self._fix_path_separators(data)
  32:                         return data
  33:                     else:
  34:                         print("Invalid config structure, creating new config")
  35:                         return self._create_default_config()
  36:             else:
  37:                 return self._create_default_config()
  38:         except (json.JSONDecodeError, FileNotFoundError, KeyError) as e:
  39:             print(f"Error loading links: {e}. Creating new config.")
  40:             return self._create_default_config()
  41:     
  42:     def _fix_path_separators(self, data):
  43:         """Fix forward slash path separators in existing links"""
  44:         for link in data.get("links", []):
  45:             if "path" in link:
  46:                 link["path"] = FileUtils.normalize_path(link["path"])
  47:     
  48:     def _create_default_config(self):
  49:         """Create default configuration"""
  50:         return {
  51:             "categories": DEFAULT_CATEGORIES.copy(),
  52:             "links": [],
  53:             "ui_preferences": {
  54:                 "menu_height": 300  # Default menu height
  55:             }
  56:         }
  57:     
  58:     def save_links(self):
  59:         """Save links to config file"""
  60:         try:
  61:             with open(self.config_file, 'w', encoding='utf-8') as f:
  62:                 json.dump(self.links, f, indent=2, ensure_ascii=False)
  63:             return True
  64:         except Exception as e:
  65:             print(f"Error saving links: {e}")
  66:             return False
  67:     
  68:     def add_link(self, name, path, category, icon="📄"):
  69:         """Add a new link"""
  70:         if not name or not path:
  71:             return False
  72:             
  73:         # Normalize the path for Windows
  74:         normalized_path = FileUtils.normalize_path(path)
  75:         
  76:         # Ensure category exists
  77:         if category not in self.links["categories"]:
  78:             self.links["categories"].append(category)
  79:         
  80:         new_link = {
  81:             "name": name.strip(),
  82:             "path": normalized_path,
  83:             "category": category,
  84:             "icon": icon
  85:         }
  86:         
  87:         self.links["links"].append(new_link)
  88:         return self.save_links()
  89:     
  90:     def update_link(self, index, name, path, category, icon="📄"):
  91:         """Update an existing link"""
  92:         if not (0 <= index < len(self.links["links"])):
  93:             return False
  94:         
  95:         if not name or not path:
  96:             return False
  97:         
  98:         # Normalize the path for Windows
  99:         normalized_path = FileUtils.normalize_path(path)
 100:         
 101:         # Ensure category exists
 102:         if category not in self.links["categories"]:
 103:             self.links["categories"].append(category)
 104:         
 105:         self.links["links"][index] = {
 106:             "name": name.strip(),
 107:             "path": normalized_path,
 108:             "category": category,
 109:             "icon": icon
 110:         }
 111:         
 112:         return self.save_links()
 113:     
 114:     def remove_link(self, index):
 115:         """Remove a link by index"""
 116:         if 0 <= index < len(self.links["links"]):
 117:             del self.links["links"][index]
 118:             return self.save_links()
 119:         return False
 120:     
 121:     def get_links_by_category(self, category):
 122:         """Get all links in a category"""
 123:         return [link for link in self.links["links"] if link["category"] == category]
 124:     
 125:     def get_all_links(self):
 126:         """Get all links"""
 127:         return self.links["links"].copy()
 128:     
 129:     def get_categories(self):
 130:         """Get all categories"""
 131:         return self.links["categories"].copy()
 132:     
 133:     def add_category(self, category_name):
 134:         """Add a new category"""
 135:         if category_name and category_name not in self.links["categories"]:
 136:             self.links["categories"].append(category_name)
 137:             return self.save_links()
 138:         return False
 139:     
 140:     def remove_category(self, category_name):
 141:         """Remove a category and all its links"""
 142:         if category_name in self.links["categories"]:
 143:             # Remove all links in this category
 144:             self.links["links"] = [
 145:                 link for link in self.links["links"] 
 146:                 if link["category"] != category_name
 147:             ]
 148:             # Remove the category
 149:             self.links["categories"].remove(category_name)
 150:             return self.save_links()
 151:         return False
 152:     
 153:     def move_link(self, from_index, to_index):
 154:         """Move a link from one position to another"""
 155:         if (0 <= from_index < len(self.links["links"]) and 
 156:             0 <= to_index < len(self.links["links"])):
 157:             
 158:             link = self.links["links"].pop(from_index)
 159:             self.links["links"].insert(to_index, link)
 160:             return self.save_links()
 161:         return False
 162:     
 163:     def search_links(self, query):
 164:         """Search links by name or path"""
 165:         query = query.lower().strip()
 166:         if not query:
 167:             return self.get_all_links()
 168:         
 169:         results = []
 170:         for link in self.links["links"]:
 171:             if (query in link["name"].lower() or 
 172:                 query in link["path"].lower() or
 173:                 query in link["category"].lower()):
 174:                 results.append(link)
 175:         
 176:         return results
 177:     
 178:     def get_stats(self):
 179:         """Get statistics about links"""
 180:         total_links = len(self.links["links"])
 181:         categories_count = {}
 182:         
 183:         for link in self.links["links"]:
 184:             category = link["category"]
 185:             categories_count[category] = categories_count.get(category, 0) + 1
 186:         
 187:         return {
 188:             "total_links": total_links,
 189:             "total_categories": len(self.links["categories"]),
 190:             "links_per_category": categories_count
 191:         }
 192:     
 193:     def export_links(self, file_path):
 194:         """Export links to a JSON file"""
 195:         try:
 196:             with open(file_path, 'w', encoding='utf-8') as f:
 197:                 json.dump(self.links, f, indent=2, ensure_ascii=False)
 198:             return True
 199:         except Exception as e:
 200:             print(f"Error exporting links: {e}")
 201:             return False
 202:     
 203:     def import_links(self, file_path, merge=True):
 204:         """Import links from a JSON file"""
 205:         try:
 206:             with open(file_path, 'r', encoding='utf-8') as f:
 207:                 imported_data = json.load(f)
 208:             
 209:             if not merge:
 210:                 # Replace all data
 211:                 self.links = imported_data
 212:             else:
 213:                 # Merge data
 214:                 for category in imported_data.get("categories", []):
 215:                     if category not in self.links["categories"]:
 216:                         self.links["categories"].append(category)
 217:                 
 218:                 for link in imported_data.get("links", []):
 219:                     # Check for duplicates (same name and path)
 220:                     duplicate = any(
 221:                         existing["name"] == link["name"] and existing["path"] == link["path"]
 222:                         for existing in self.links["links"]
 223:                     )
 224:                     if not duplicate:
 225:                         self.links["links"].append(link)
 226:             
 227:             return self.save_links()
 228:         except Exception as e:
 229:             print(f"Error importing links: {e}")
 230:             return False
 231:     
 232:     def get_menu_height(self):
 233:         """Get stored menu height"""
 234:         return self.links.get("ui_preferences", {}).get("menu_height", 300)
 235:     
 236:     def set_menu_height(self, height):
 237:         """Set menu height and save"""
 238:         if "ui_preferences" not in self.links:
 239:             self.links["ui_preferences"] = {}
 240:         self.links["ui_preferences"]["menu_height"] = height
 241:         return self.save_links()
 242:     
 243:     def move_link_to_category(self, link_index, new_category):
 244:         """Move a link to a different category"""
 245:         if not (0 <= link_index < len(self.links["links"])):
 246:             return False
 247:         
 248:         # Ensure new category exists
 249:         if new_category not in self.links["categories"]:
 250:             self.links["categories"].append(new_category)
 251:         
 252:         # Update the link's category
 253:         self.links["links"][link_index]["category"] = new_category
 254:         return self.save_links()
 255:     
 256:     def reorder_links_in_category(self, category, old_position, new_position):
 257:         """Reorder links within a category"""
 258:         category_links = [i for i, link in enumerate(self.links["links"]) 
 259:                          if link["category"] == category]
 260:         
 261:         if not (0 <= old_position < len(category_links) and 
 262:                 0 <= new_position < len(category_links)):
 263:             return False
 264:         
 265:         # Get the actual indices in the main links array
 266:         old_index = category_links[old_position]
 267:         new_index = category_links[new_position]
 268:         
 269:         # Move the link
 270:         link_to_move = self.links["links"].pop(old_index)
 271:         
 272:         # Adjust new_index if it's affected by the removal
 273:         if old_index < new_index:
 274:             new_index -= 1
 275:         
 276:         # Calculate the correct insertion position
 277:         if new_position == 0:
 278:             # Insert at the beginning of the category
 279:             insert_index = category_links[0] if old_index != category_links[0] else 0
 280:         elif new_position == len(category_links) - 1:
 281:             # Insert at the end of the category
 282:             insert_index = len(self.links["links"])
 283:         else:
 284:             # Insert at the specified position
 285:             insert_index = category_links[new_position]
 286:             if old_index < insert_index:
 287:                 insert_index -= 1
 288:         
 289:         self.links["links"].insert(insert_index, link_to_move)
 290:         return self.save_links()
 291:     
 292:     def get_link_position_in_category(self, link_index):
 293:         """Get the position of a link within its category"""
 294:         if not (0 <= link_index < len(self.links["links"])):
 295:             return -1
 296:         
 297:         link = self.links["links"][link_index]
 298:         category = link["category"]
 299:         
 300:         category_links = [i for i, l in enumerate(self.links["links"]) 
 301:                          if l["category"] == category]
 302:         
 303:         try:
 304:             return category_links.index(link_index)
 305:         except ValueError:
 306:             return -1

────────────────────────────────────────────────────────────────────────────────
FILE: main.py
────────────────────────────────────────────────────────────────────────────────
Path: main.py
Size: 1.1 KB
Lines: 42 total, 36 non-empty
Characters: 1,105
Type: Main application entry point
────────────────────────────────────────────────────────────────────────────────

   1: # main.py
   2: """
   3: Main entry point for SuiteView Taskbar Application
   4: """
   5: import sys
   6: import os
   7: 
   8: # Add the current directory to the Python path to ensure imports work
   9: current_dir = os.path.dirname(os.path.abspath(__file__))
  10: if current_dir not in sys.path:
  11:     sys.path.insert(0, current_dir)
  12: 
  13: # Now import our modules
  14: try:
  15:     from taskbar import SuiteViewTaskbar
  16:     from config import Settings
  17: except ImportError as e:
  18:     print(f"Import error: {e}")
  19:     print(f"Current directory: {current_dir}")
  20:     print(f"Files in directory: {os.listdir(current_dir)}")
  21:     sys.exit(1)
  22: 
  23: def main():
  24:     """Main application entry point"""
  25:     try:
  26:         print(f"Starting {Settings.APP_NAME} v{Settings.VERSION}")
  27:         
  28:         # Create and run the taskbar application
  29:         app = SuiteViewTaskbar()
  30:         app.run()
  31:         
  32:     except KeyboardInterrupt:
  33:         print("Application interrupted by user")
  34:         sys.exit(0)
  35:     except Exception as e:
  36:         print(f"Error starting application: {e}")
  37:         import traceback
  38:         traceback.print_exc()
  39:         sys.exit(1)
  40: 
  41: if __name__ == "__main__":
  42:     main()

────────────────────────────────────────────────────────────────────────────────
FILE: pinned_windows.py
────────────────────────────────────────────────────────────────────────────────
Path: pinned_windows.py
Size: 7.3 KB
Lines: 177 total, 143 non-empty
Characters: 7,291
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # pinned_windows.py (modified)
   2: """
   3: Pinned windows section for SuiteView Taskbar
   4: Manages the pinned window buttons in the taskbar
   5: Modified to blend seamlessly with taskbar
   6: """
   7: 
   8: import tkinter as tk
   9: from config import Colors, Fonts, Settings
  10: from window_manager import ManagedWindow, WindowManager
  11: from ui_components import ConfirmationDialog
  12: 
  13: class PinnedWindowButton(tk.Frame):
  14:     """Individual pinned window button"""
  15:     
  16:     def __init__(self, parent, window: ManagedWindow, window_manager: WindowManager, 
  17:                  on_unpin_callback):
  18:         super().__init__(parent, bg=Colors.DARK_GREEN)
  19:         self.window = window
  20:         self.window_manager = window_manager
  21:         self.on_unpin_callback = on_unpin_callback
  22:         
  23:         # Create button
  24:         self.create_button()
  25:         
  26:         # Bind right-click for unpin
  27:         self.button.bind("<Button-3>", self.show_unpin_menu)
  28:     
  29:     def create_button(self):
  30:         """Create the toggle button"""
  31:         print(f"\n=== CREATING PINNED BUTTON ===")
  32:         print(f"Window: {self.window.display_name}")
  33:         print(f"Parent: {self.master}")
  34:         
  35:         # Determine colors based on visibility
  36:         bg_color = Colors.WINDOW_VISIBLE if not self.window.is_hidden else Colors.WINDOW_HIDDEN
  37:         fg_color = Colors.BLACK if not self.window.is_hidden else Colors.WHITE
  38:         
  39:         # Use app name with word wrapping instead of truncating
  40:         display_text = self.window.app_name
  41:         
  42:         # Create smaller font for button text
  43:         button_font = (Fonts.TASKBAR_BUTTON[0], Fonts.TASKBAR_BUTTON[1] - 2)
  44:         
  45:         self.button = tk.Button(self, text=display_text,
  46:                                bg=bg_color, fg=fg_color,
  47:                                relief=tk.RAISED, bd=2,
  48:                                font=button_font,
  49:                                width=6, height=2,  # More square: 6 chars wide, 2 lines high
  50:                                cursor='hand2',
  51:                                activebackground=Colors.HOVER_GREEN,
  52:                                command=self.toggle_window,
  53:                                wraplength=45,  # Enable word wrapping at ~45 pixels
  54:                                justify=tk.CENTER)  # Center the wrapped text
  55:         self.button.pack(padx=2, pady=2)
  56:         
  57:         # Force visibility
  58:         self.button.update()
  59:         
  60:         print(f"Button created: {self.button}")
  61:         print(f"Button visible: {self.button.winfo_viewable()}")
  62:         print(f"Button geometry: {self.button.winfo_geometry()}")
  63:         print(f"=== END CREATING PINNED BUTTON ===\n")
  64:     
  65:     def toggle_window(self):
  66:         """Toggle window visibility"""
  67:         self.window.bring_to_front()
  68:         self.update_appearance()
  69:     
  70:     def update_appearance(self):
  71:         """Update button appearance based on window state"""
  72:         bg_color = Colors.WINDOW_VISIBLE if not self.window.is_hidden else Colors.WINDOW_HIDDEN
  73:         fg_color = Colors.BLACK if not self.window.is_hidden else Colors.WHITE
  74:         self.button.configure(bg=bg_color, fg=fg_color)
  75:     
  76:     def show_unpin_menu(self, event):
  77:         """Show right-click menu for unpinning"""
  78:         result = ConfirmationDialog.ask(
  79:             self.winfo_toplevel(),
  80:             "Unpin Window",
  81:             f"Unpin '{self.window.app_name}' from taskbar?",
  82:             icon="📌"
  83:         )
  84:         
  85:         if result:
  86:             self.window_manager.unpin_window(self.window)
  87:             self.on_unpin_callback()
  88:             
  89:         # Prevent event from propagating to parent widgets (taskbar)
  90:         return 'break'
  91: 
  92: class PinnedWindowsSection(tk.Frame):
  93:     """Section in taskbar for pinned windows - now blends with taskbar"""
  94:     
  95:     def __init__(self, parent, window_manager: WindowManager, on_pin_changed_callback=None):
  96:         # Use same background as taskbar, no border
  97:         super().__init__(parent, bg=Colors.DARK_GREEN, relief=tk.FLAT, bd=0)
  98:         self.window_manager = window_manager
  99:         self.pinned_buttons = {}
 100:         self.on_pin_changed_callback = on_pin_changed_callback
 101:         
 102:         # Debug output
 103:         print(f"\n=== CREATING PINNED WINDOWS SECTION ===")
 104:         print(f"Parent: {parent}")
 105:         print(f"Window manager: {window_manager}")
 106: 
 107:         # Set minimum and fixed size
 108:         self.configure(width=Settings.PINNED_SECTION_WIDTH, height=35)
 109:         self.pack_propagate(False)  # Maintain fixed size
 110:         
 111:         # Remove any visible border
 112:         self.configure(highlightbackground=Colors.DARK_GREEN, highlightthickness=0)
 113:         
 114:         # Create container for buttons with no special background
 115:         self.button_container = tk.Frame(self, bg=Colors.DARK_GREEN)
 116:         self.button_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=2)
 117:         
 118:         # No empty state label - just leave it blank
 119:         
 120:         print(f"PinnedWindowsSection created successfully: {self}")
 121:         print(f"=== END CREATING PINNED WINDOWS SECTION ===\n")
 122:     
 123:     def refresh(self):
 124:         """Refresh the pinned windows display"""
 125:         print(f"\n=== PINNED SECTION REFRESH ===")
 126:         print(f"Current button count: {len(self.pinned_buttons)}")
 127:         
 128:         # Clear existing buttons
 129:         for hwnd in list(self.pinned_buttons.keys()):
 130:             print(f"Destroying old button for hwnd: {hwnd}")
 131:             self.pinned_buttons[hwnd].destroy()
 132:             del self.pinned_buttons[hwnd]
 133:         
 134:         # Get pinned windows
 135:         pinned_windows = self.window_manager.get_pinned_windows()
 136:         print(f"Found {len(pinned_windows)} pinned windows")
 137:         
 138:         if pinned_windows:
 139:             # Create buttons for pinned windows
 140:             for i, window in enumerate(pinned_windows):
 141:                 print(f"{i}. Creating button for: {window.display_name} (hwnd: {window.hwnd})")
 142:                 if window.is_valid():
 143:                     button = PinnedWindowButton(
 144:                         self.button_container, 
 145:                         window, 
 146:                         self.window_manager,
 147:                         self.on_pin_changed
 148:                     )
 149:                     button.pack(side=tk.LEFT, padx=2)
 150:                     self.pinned_buttons[window.hwnd] = button
 151:                     print(f"   Button created and packed")
 152:                     
 153:                     # Force update to ensure visibility
 154:                     button.update()
 155:                     self.button_container.update()
 156:                 else:
 157:                     print(f"   Window is not valid!")
 158:         
 159:         # Force the section to update
 160:         self.update_idletasks()
 161:         print(f"Button container visible: {self.button_container.winfo_viewable()}")
 162:         print(f"Section geometry: {self.winfo_width()}x{self.winfo_height()}")
 163:         print("=== END REFRESH ===\n")
 164:     
 165:     def update_window_states(self):
 166:         """Update appearance of all pinned window buttons"""
 167:         for button in self.pinned_buttons.values():
 168:             button.update_appearance()
 169:     
 170:     def on_pin_changed(self):
 171:         """Called when a window is pinned/unpinned from the button"""
 172:         # Refresh the pinned section
 173:         self.refresh()
 174:         
 175:         # Also call the taskbar callback if it exists
 176:         if self.on_pin_changed_callback:
 177:             self.on_pin_changed_callback()

────────────────────────────────────────────────────────────────────────────────
FILE: quick_links.py
────────────────────────────────────────────────────────────────────────────────
Path: quick_links.py
Size: 36.3 KB
Lines: 867 total, 691 non-empty
Characters: 36,267
Type: Quick links menu and management
────────────────────────────────────────────────────────────────────────────────

   1: # quick_links.py
   2: """
   3: Quick Links feature for SuiteView Taskbar
   4: Contains the links menu, dialogs, and management interface
   5: """
   6: 
   7: import tkinter as tk
   8: from tkinter import ttk, filedialog
   9: from config import Colors, Fonts, Dimensions
  10: from utils import UIUtils, FileUtils
  11: from ui_components import CustomDialog, ConfirmationDialog, FormField, CategoryHeader, WarningDialog, ErrorDialog
  12: from links_manager import LinksManager
  13: 
  14: class QuickLinksMenu(tk.Toplevel):
  15:     """Enhanced right-click context menu for managing links with column layout"""
  16:     
  17:     def __init__(self, parent, taskbar_instance, x, y):
  18:         super().__init__(parent)
  19:         self.parent = parent
  20:         self.taskbar_instance = taskbar_instance
  21:         self.links_manager = taskbar_instance.links_manager
  22:         
  23:         # Window setup
  24:         self.overrideredirect(True)
  25:         self.configure(bg=Colors.DARK_GREEN)
  26:         self.attributes('-topmost', True)
  27:         self.attributes('-alpha', 0.98)
  28:         
  29:         # Initialize resize variables
  30:         self.is_resizing = False
  31:         self.resize_start_y = 0
  32:         self.original_height = 0
  33:         self.bottom_y = 0  # Track bottom position for locked resizing
  34:         
  35:         # Initialize drag and drop variables
  36:         self.is_dragging_link = False
  37:         self.drag_start_time = 0
  38:         self.drag_threshold = 5  # pixels to move before considering it a drag
  39:         self.drag_time_threshold = 200  # milliseconds to wait before drag
  40:         self.dragged_link_data = None
  41:         self.dragged_link_index = None
  42:         self.drag_visual = None
  43:         self.drop_indicators = []
  44:         
  45:         # Position the menu
  46:         self.geometry(f"+{x}+{y}")
  47:         
  48:         # Main container with dark green border
  49:         self.main_frame = tk.Frame(self, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=2)
  50:         self.main_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
  51:         
  52:         # Header frame with buttons
  53:         self.create_header()
  54:         
  55:         # Content area with light green background
  56:         self.content_frame = tk.Frame(self.main_frame, bg=Colors.LIGHT_GREEN, relief=tk.SUNKEN, bd=1)
  57:         self.content_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
  58:         
  59:         # Create column layout for all categories
  60:         self.create_column_layout()
  61:         
  62:         # Bind events
  63:         self.bind("<FocusOut>", lambda e: self.destroy())
  64:         self.focus_set()
  65:         
  66:         # Set minimum size based on content and stored preferences
  67:         self.update_idletasks()
  68:         self.menu_width = max(Dimensions.MENU_MIN_WIDTH, self.winfo_reqwidth())
  69:         
  70:         # Use stored menu height or default
  71:         stored_height = self.links_manager.get_menu_height()
  72:         calculated_height = max(Dimensions.MENU_MIN_HEIGHT, self.winfo_reqheight())
  73:         self.menu_height = max(stored_height, calculated_height)
  74:         
  75:         self.geometry(f"{self.menu_width}x{self.menu_height}")
  76:         
  77:         # Store bottom position for locked resizing
  78:         self.update_idletasks()
  79:         self.bottom_y = self.winfo_y() + self.winfo_height()
  80:         
  81:         # Setup resize functionality
  82:         self.setup_resize_functionality()
  83:         
  84:     
  85:     def create_header(self):
  86:         """Create header with title and buttons"""
  87:         self.header_frame = tk.Frame(self.main_frame, bg=Colors.DARK_GREEN, height=25)
  88:         self.header_frame.pack(fill=tk.X, padx=1, pady=1)
  89:         self.header_frame.pack_propagate(False)
  90:         
  91:         # Create a resize area at the top of the header
  92:         resize_area = tk.Frame(self.header_frame, bg=Colors.MEDIUM_GREEN, height=3, cursor='sb_v_double_arrow')
  93:         resize_area.pack(fill=tk.X, side=tk.TOP)
  94:         
  95:         # Main header content
  96:         header_content = tk.Frame(self.header_frame, bg=Colors.DARK_GREEN)
  97:         header_content.pack(fill=tk.BOTH, expand=True)
  98:         
  99:         # Resize handle (left side) - more prominent
 100:         resize_handle = tk.Label(header_content, text="═══", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 101:                                font=('Arial', 6), cursor='sb_v_double_arrow', width=4)
 102:         resize_handle.pack(side=tk.LEFT, padx=2, pady=3)
 103:         
 104:         # Title with resize capability
 105:         title_label = tk.Label(header_content, text="Quick Links ↕", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 106:                              font=Fonts.MENU_HEADER, cursor='sb_v_double_arrow')
 107:         title_label.pack(side=tk.LEFT, padx=5, pady=3)
 108:         
 109:         # Bind resize events to multiple elements for better usability
 110:         for widget in [resize_area, resize_handle, title_label, self.header_frame]:
 111:             widget.bind("<Button-1>", self.start_resize)
 112:             widget.bind("<B1-Motion>", self.do_resize)
 113:             widget.bind("<ButtonRelease-1>", self.end_resize)
 114:             widget.bind("<Enter>", lambda e: self.configure(cursor='sb_v_double_arrow'))
 115:             widget.bind("<Leave>", lambda e: self.configure(cursor=''))
 116:         
 117:         # Buttons with green theme
 118:         button_frame = tk.Frame(header_content, bg=Colors.DARK_GREEN)
 119:         button_frame.pack(side=tk.RIGHT, padx=5)
 120:         
 121:         # Add button
 122:         add_btn = tk.Button(button_frame, text="Add", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 123:                            relief=tk.RAISED, bd=1, cursor='hand2', 
 124:                            font=Fonts.MENU_ITEM, width=4, height=1,
 125:                            command=self.add_new_link)
 126:         add_btn.pack(side=tk.LEFT, padx=1)
 127:         
 128:         # View button (placeholder for future features)
 129:         view_btn = tk.Button(button_frame, text="Vie", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 130:                             relief=tk.RAISED, bd=1, cursor='hand2',
 131:                             font=Fonts.MENU_ITEM, width=4, height=1)
 132:         view_btn.pack(side=tk.LEFT, padx=1)
 133:         
 134:         # Close button
 135:         close_btn = tk.Button(button_frame, text="X", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 136:                              relief=tk.RAISED, bd=1, cursor='hand2',
 137:                              font=Fonts.MENU_ITEM, width=3, height=1,
 138:                              command=self.destroy)
 139:         close_btn.pack(side=tk.LEFT, padx=1)
 140:     
 141:     def create_column_layout(self):
 142:         """Create column layout showing all categories"""
 143:         # Container for columns
 144:         columns_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
 145:         columns_frame.pack(fill=tk.BOTH, expand=True, padx=3, pady=3)
 146:         
 147:         categories = self.links_manager.get_categories()
 148:         num_categories = len(categories)
 149:         
 150:         # Create columns for each category
 151:         for i, category in enumerate(categories):
 152:             column_frame = tk.Frame(columns_frame, bg=Colors.LIGHT_GREEN, relief=tk.FLAT)
 153:             column_frame.grid(row=0, column=i, sticky='nsew', padx=2, pady=1)
 154:             
 155:             # Configure grid weights for equal distribution
 156:             columns_frame.grid_columnconfigure(i, weight=1)
 157:         
 158:         columns_frame.grid_rowconfigure(0, weight=1)
 159:         
 160:         # Populate each column
 161:         for i, category in enumerate(categories):
 162:             self.create_category_column(columns_frame, category, i)
 163:     
 164:     def create_category_column(self, parent, category, column_index):
 165:         """Create a column for a specific category"""
 166:         # Get the column frame
 167:         column_frame = parent.grid_slaves(row=0, column=column_index)[0]
 168:         
 169:         # Category header
 170:         header = CategoryHeader(column_frame, category)
 171:         header.pack(fill=tk.X, pady=(0, 2))
 172:         
 173:         # Links container with light green background
 174:         links_container = tk.Frame(column_frame, bg=Colors.LIGHT_GREEN)
 175:         links_container.pack(fill=tk.BOTH, expand=True)
 176:         
 177:         # Store category for drop operations
 178:         links_container.category = category
 179:         links_container.bind("<Enter>", lambda e: self.on_category_drop_zone_enter(e, category))
 180:         links_container.bind("<Leave>", lambda e: self.on_category_drop_zone_leave(e, category))
 181:         
 182:         # Get links for this category
 183:         links = self.links_manager.get_links_by_category(category)
 184:         
 185:         if links:
 186:             for link in links:
 187:                 # Find the actual index in the full links list
 188:                 actual_index = self.links_manager.get_all_links().index(link)
 189:                 self.create_compact_link_item(links_container, link, actual_index)
 190:         else:
 191:             # Empty state - also acts as a drop zone
 192:             empty_label = tk.Label(links_container, text="", bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 193:                                  font=(Fonts.MENU_ITEM[0], Fonts.MENU_ITEM[1], 'italic'))
 194:             empty_label.pack(pady=5)
 195:             empty_label.category = category
 196:             empty_label.bind("<Enter>", lambda e: self.on_empty_category_enter(e, category))
 197:             empty_label.bind("<Leave>", lambda e: self.on_empty_category_leave(e, category))
 198:     
 199:     def create_compact_link_item(self, parent, link, index):
 200:         """Create a compact link item with drag-and-drop support"""
 201:         # Create a frame to hold the link (easier for drag operations)
 202:         link_frame = tk.Frame(parent, bg=Colors.LIGHT_GREEN, relief=tk.FLAT)
 203:         link_frame.pack(fill=tk.X, padx=2, pady=1)
 204:         
 205:         # Create the link label
 206:         link_label = tk.Label(link_frame, text=f"{link['name']}", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 207:                              font=Fonts.MENU_ITEM, anchor='w', height=1,
 208:                              cursor='hand2', relief=tk.FLAT, padx=5, pady=2)
 209:         link_label.pack(fill=tk.X)
 210:         
 211:         # Store link data for drag operations
 212:         link_frame.link_data = link
 213:         link_frame.link_index = index
 214:         link_frame.category = link['category']
 215:         link_label.link_data = link
 216:         link_label.link_index = index
 217:         link_label.category = link['category']
 218:         
 219:         # Apply hover effects
 220:         UIUtils.apply_hover_effect(link_label, Colors.LIGHT_GREEN, Colors.HOVER_GREEN, 
 221:                                   Colors.BLACK, Colors.WHITE)
 222:         
 223:         # Bind drag and drop events
 224:         for widget in [link_frame, link_label]:
 225:             widget.bind("<Button-1>", lambda e, l=link, i=index: self.on_link_press(e, l, i))
 226:             widget.bind("<B1-Motion>", lambda e, l=link, i=index: self.on_link_drag(e, l, i))
 227:             widget.bind("<ButtonRelease-1>", lambda e, l=link, i=index: self.on_link_release(e, l, i))
 228:             widget.bind("<Button-3>", lambda e, l=link, i=index: self.show_link_context_menu(e, l, i))
 229:         
 230:         # Mark as drop zone
 231:         link_frame.bind("<Enter>", lambda e: self.on_drop_zone_enter(e, link, index))
 232:         link_frame.bind("<Leave>", lambda e: self.on_drop_zone_leave(e, link, index))
 233:     
 234:     def show_link_context_menu(self, event, link, index):
 235:         """Show context menu for individual link"""
 236:         context_menu = tk.Menu(self, tearoff=0, bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 237:                               activebackground=Colors.HOVER_GREEN, activeforeground=Colors.WHITE)
 238:         
 239:         context_menu.add_command(label=f"Open {link['name']}", 
 240:                                 command=lambda: FileUtils.open_path(link['path'], self.parent))
 241:         context_menu.add_separator()
 242:         context_menu.add_command(label="Edit", 
 243:                                 command=lambda: self.edit_link(link, index))
 244:         context_menu.add_command(label="Delete", 
 245:                                 command=lambda: self.delete_link(link, index))
 246:         
 247:         try:
 248:             context_menu.tk_popup(event.x_root, event.y_root)
 249:         finally:
 250:             context_menu.grab_release()
 251:     
 252:     def edit_link(self, link, index):
 253:         """Edit an existing link"""
 254:         self.destroy()
 255:         AddEditLinkDialog.show_edit_dialog(self.parent, self.links_manager, self.taskbar_instance, link, index)
 256:     
 257:     def delete_link(self, link, index):
 258:         """Delete a link with confirmation"""
 259:         result = ConfirmationDialog.ask(
 260:             self.parent, 
 261:             "Delete Link", 
 262:             f"Are you sure you want to delete:\n'{link['name']}'?"
 263:         )
 264:         
 265:         if result:
 266:             self.links_manager.remove_link(index)
 267:             self.destroy()
 268:             # Refresh menu
 269:             self.taskbar_instance.show_links_menu(None)
 270:     
 271:     def add_new_link(self):
 272:         """Show dialog to add a new link"""
 273:         self.destroy()
 274:         AddEditLinkDialog.show_add_dialog(self.parent, self.links_manager, self.taskbar_instance)
 275:     
 276:     def setup_resize_functionality(self):
 277:         """Setup resize functionality with minimum size constraints"""
 278:         self.min_height = 150  # Minimum height
 279:         self.max_height = 600  # Maximum height for usability
 280:         
 281:         # Allow window to be resizable
 282:         self.resizable(False, True)  # Only allow vertical resizing
 283:     
 284:     def start_resize(self, event):
 285:         """Start resizing operation"""
 286:         self.is_resizing = True
 287:         self.resize_start_y = event.y_root
 288:         self.original_height = self.winfo_height()
 289:         self.original_x = self.winfo_x()
 290:         
 291:         # Update bottom position
 292:         self.bottom_y = self.winfo_y() + self.winfo_height()
 293:         
 294:         # Change cursor to indicate resizing
 295:         self.configure(cursor='sb_v_double_arrow')
 296:         
 297:         # Visual feedback
 298:         self.header_frame.configure(bg=Colors.HOVER_GREEN)
 299:         
 300:         print(f"Starting resize: height={self.original_height}, bottom_y={self.bottom_y}")
 301:     
 302:     def do_resize(self, event):
 303:         """Handle resize drag motion"""
 304:         if not self.is_resizing:
 305:             return
 306:         
 307:         # Calculate the change in Y position
 308:         delta_y = event.y_root - self.resize_start_y
 309:         
 310:         # Calculate new height (drag up = smaller delta = taller window)
 311:         new_height = self.original_height - delta_y
 312:         
 313:         # Apply constraints
 314:         new_height = max(self.min_height, min(self.max_height, new_height))
 315:         
 316:         # Calculate new Y position to keep bottom locked
 317:         new_y = self.bottom_y - new_height
 318:         
 319:         # Apply the new geometry
 320:         try:
 321:             self.geometry(f"{self.menu_width}x{int(new_height)}+{self.original_x}+{int(new_y)}")
 322:         except Exception as e:
 323:             print(f"Resize error: {e}")
 324:     
 325:     def end_resize(self, event):
 326:         """End resizing operation"""
 327:         self.is_resizing = False
 328:         self.configure(cursor='')
 329:         
 330:         # Remove visual feedback
 331:         self.header_frame.configure(bg=Colors.DARK_GREEN)
 332:         
 333:         # Update the stored height
 334:         self.menu_height = self.winfo_height()
 335:         
 336:         # Save the new height persistently
 337:         self.links_manager.set_menu_height(self.menu_height)
 338:         
 339:         print(f"Resize ended: new height={self.menu_height} (saved)")
 340:     
 341:     # Drag and Drop Event Handlers
 342:     def on_link_press(self, event, link, index):
 343:         """Handle mouse press on link - start potential drag or prepare for click"""
 344:         import time
 345:         self.drag_start_time = time.time() * 1000  # Convert to milliseconds
 346:         self.drag_start_x = event.x_root
 347:         self.drag_start_y = event.y_root
 348:         self.dragged_link_data = link
 349:         self.dragged_link_index = index
 350:         self.potential_drag = True
 351:         
 352:         # Schedule a delayed check for click vs drag
 353:         self.after(self.drag_time_threshold, lambda: self.check_for_click_or_drag(event, link, index))
 354:     
 355:     def on_link_drag(self, event, link, index):
 356:         """Handle mouse drag on link"""
 357:         if not hasattr(self, 'potential_drag') or not self.potential_drag:
 358:             return
 359:         
 360:         # Calculate distance moved
 361:         distance = ((event.x_root - self.drag_start_x) ** 2 + (event.y_root - self.drag_start_y) ** 2) ** 0.5
 362:         
 363:         if distance > self.drag_threshold:
 364:             self.start_link_drag(event, link, index)
 365:     
 366:     def on_link_release(self, event, link, index):
 367:         """Handle mouse release on link"""
 368:         if self.is_dragging_link:
 369:             self.end_link_drag(event, link, index)
 370:         elif hasattr(self, 'potential_drag') and self.potential_drag:
 371:             # This was a click, not a drag
 372:             self.handle_link_click(link)
 373:         
 374:         # Reset drag state
 375:         self.potential_drag = False
 376:         self.is_dragging_link = False
 377:     
 378:     def check_for_click_or_drag(self, event, link, index):
 379:         """Determine if this was a click or start of drag after delay"""
 380:         if hasattr(self, 'potential_drag') and self.potential_drag and not self.is_dragging_link:
 381:             # Still within time threshold and no drag started, treat as click
 382:             pass  # Let the release handler manage the click
 383:     
 384:     def handle_link_click(self, link):
 385:         """Handle regular link click to open file"""
 386:         FileUtils.open_path(link['path'], self.parent)
 387:         self.destroy()
 388:     
 389:     def start_link_drag(self, event, link, index):
 390:         """Start dragging a link"""
 391:         if self.is_dragging_link:
 392:             return
 393:         
 394:         self.is_dragging_link = True
 395:         self.potential_drag = False
 396:         
 397:         # Create drag visual
 398:         self.create_drag_visual(event, link)
 399:         
 400:         # Show drop indicators
 401:         self.show_drop_indicators()
 402:         
 403:         print(f"Started dragging: {link['name']}")
 404:     
 405:     def create_drag_visual(self, event, link):
 406:         """Create visual feedback for dragging"""
 407:         if self.drag_visual:
 408:             self.drag_visual.destroy()
 409:         
 410:         self.drag_visual = tk.Toplevel(self)
 411:         self.drag_visual.overrideredirect(True)
 412:         self.drag_visual.attributes('-topmost', True)
 413:         self.drag_visual.attributes('-alpha', 0.8)
 414:         
 415:         # Make drag visual ignore mouse events (so they pass through to drop zones)
 416:         try:
 417:             # This makes the window transparent to mouse events
 418:             self.drag_visual.attributes('-transparentcolor', 'black')  
 419:         except:
 420:             pass  # Not all systems support this
 421:         
 422:         # Create drag visual content
 423:         drag_frame = tk.Frame(self.drag_visual, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=2)
 424:         drag_frame.pack(padx=2, pady=2)
 425:         
 426:         tk.Label(drag_frame, text=f"🚀 {link['name']}", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 427:                 font=Fonts.MENU_ITEM, padx=10, pady=5).pack()
 428:         
 429:         # Position at cursor
 430:         self.drag_visual.geometry(f"+{event.x_root + 10}+{event.y_root + 10}")
 431:         
 432:         # Bind motion to follow cursor
 433:         self.bind("<Motion>", self.update_drag_visual)
 434:     
 435:     def update_drag_visual(self, event):
 436:         """Update drag visual position"""
 437:         if self.drag_visual and self.is_dragging_link:
 438:             self.drag_visual.geometry(f"+{event.x_root + 10}+{event.y_root + 10}")
 439:     
 440:     def show_drop_indicators(self):
 441:         """Show visual indicators for valid drop zones"""
 442:         # This would highlight valid drop areas
 443:         # For now, we'll rely on hover effects in the drop zone handlers
 444:         pass
 445:     
 446:     def end_link_drag(self, event, link, index):
 447:         """End link drag operation"""
 448:         print(f"Ending drag for: {link['name']}")
 449:         
 450:         # Try to find drop target at current mouse position
 451:         drop_target = self.find_drop_target_at_position(event.x_root, event.y_root)
 452:         
 453:         if drop_target:
 454:             print(f"Found drop target: {drop_target}")
 455:             self.current_drop_target = drop_target
 456:             self.perform_drop_operation()
 457:         else:
 458:             print("No valid drop target found")
 459:         
 460:         self.is_dragging_link = False
 461:         
 462:         # Clean up drag visual
 463:         if self.drag_visual:
 464:             self.drag_visual.destroy()
 465:             self.drag_visual = None
 466:         
 467:         # Unbind motion events
 468:         self.unbind("<Motion>")
 469:         
 470:         # Hide drop indicators
 471:         self.hide_drop_indicators()
 472:         
 473:         print(f"Ended dragging: {link['name']}")
 474:     
 475:     def hide_drop_indicators(self):
 476:         """Hide drop zone indicators"""
 477:         # Clean up any drop indicators
 478:         for indicator in self.drop_indicators:
 479:             try:
 480:                 indicator.destroy()
 481:             except:
 482:                 pass
 483:         self.drop_indicators.clear()
 484:     
 485:     # Drop Zone Event Handlers
 486:     def on_drop_zone_enter(self, event, link, index):
 487:         """Handle mouse entering a link drop zone"""
 488:         if self.is_dragging_link and self.dragged_link_index != index:
 489:             event.widget.configure(bg=Colors.HOVER_GREEN)
 490:             self.current_drop_target = {'type': 'reorder', 'link': link, 'index': index}
 491:     
 492:     def on_drop_zone_leave(self, event, link, index):
 493:         """Handle mouse leaving a link drop zone"""
 494:         if self.is_dragging_link:
 495:             event.widget.configure(bg=Colors.LIGHT_GREEN)
 496:             if hasattr(self, 'current_drop_target'):
 497:                 delattr(self, 'current_drop_target')
 498:     
 499:     def on_category_drop_zone_enter(self, event, category):
 500:         """Handle mouse entering a category drop zone"""
 501:         if self.is_dragging_link and self.dragged_link_data['category'] != category:
 502:             event.widget.configure(bg=Colors.MEDIUM_GREEN)
 503:             self.current_drop_target = {'type': 'move', 'category': category}
 504:     
 505:     def on_category_drop_zone_leave(self, event, category):
 506:         """Handle mouse leaving a category drop zone"""
 507:         if self.is_dragging_link:
 508:             event.widget.configure(bg=Colors.LIGHT_GREEN)
 509:             if hasattr(self, 'current_drop_target'):
 510:                 delattr(self, 'current_drop_target')
 511:     
 512:     def on_empty_category_enter(self, event, category):
 513:         """Handle mouse entering an empty category"""
 514:         if self.is_dragging_link and self.dragged_link_data['category'] != category:
 515:             event.widget.configure(bg=Colors.MEDIUM_GREEN)
 516:             self.current_drop_target = {'type': 'move', 'category': category}
 517:     
 518:     def on_empty_category_leave(self, event, category):
 519:         """Handle mouse leaving an empty category"""
 520:         if self.is_dragging_link:
 521:             event.widget.configure(bg=Colors.LIGHT_GREEN)
 522:             if hasattr(self, 'current_drop_target'):
 523:                 delattr(self, 'current_drop_target')
 524:     
 525:     def perform_drop_operation(self):
 526:         """Perform the actual drop operation based on current target"""
 527:         print(f"Performing drop operation...")
 528:         
 529:         if not hasattr(self, 'current_drop_target'):
 530:             print("No current_drop_target found")
 531:             return False
 532:             
 533:         if not self.dragged_link_data or self.dragged_link_index is None:
 534:             print("No dragged link data found")
 535:             return False
 536:         
 537:         target = self.current_drop_target
 538:         success = False
 539:         
 540:         print(f"Drop target: {target}")
 541:         print(f"Dragged link: {self.dragged_link_data['name']} (index: {self.dragged_link_index})")
 542:         
 543:         if target['type'] == 'move':
 544:             # Move to different category
 545:             print(f"Attempting to move to category: {target['category']}")
 546:             success = self.links_manager.move_link_to_category(self.dragged_link_index, target['category'])
 547:             if success:
 548:                 print(f"✅ Moved '{self.dragged_link_data['name']}' to category '{target['category']}'")
 549:             else:
 550:                 print(f"❌ Failed to move '{self.dragged_link_data['name']}' to category '{target['category']}'")
 551:         
 552:         elif target['type'] == 'reorder':
 553:             # Reorder within same category
 554:             dragged_category = self.dragged_link_data['category']
 555:             dragged_pos = self.links_manager.get_link_position_in_category(self.dragged_link_index)
 556:             target_pos = self.links_manager.get_link_position_in_category(target['index'])
 557:             
 558:             print(f"Attempting to reorder in category: {dragged_category}")
 559:             print(f"From position {dragged_pos} to position {target_pos}")
 560:             
 561:             if dragged_pos != -1 and target_pos != -1:
 562:                 success = self.links_manager.reorder_links_in_category(dragged_category, dragged_pos, target_pos)
 563:                 if success:
 564:                     print(f"✅ Reordered '{self.dragged_link_data['name']}' in category '{dragged_category}'")
 565:                 else:
 566:                     print(f"❌ Failed to reorder '{self.dragged_link_data['name']}' in category '{dragged_category}'")
 567:             else:
 568:                 print(f"❌ Invalid positions: dragged_pos={dragged_pos}, target_pos={target_pos}")
 569:         
 570:         if success:
 571:             # Refresh the menu to show changes
 572:             print("Refreshing menu...")
 573:             self.refresh_menu()
 574:         else:
 575:             print("Drop operation failed")
 576:         
 577:         return success
 578:     
 579:     def refresh_menu(self):
 580:         """Refresh the menu display after drag and drop operations"""
 581:         # Store current position
 582:         current_x = self.winfo_x()
 583:         current_y = self.winfo_y()
 584:         current_height = self.winfo_height()
 585:         
 586:         # Recreate the column layout
 587:         for widget in self.content_frame.winfo_children():
 588:             widget.destroy()
 589:         
 590:         self.create_column_layout()
 591:         
 592:         # Restore position and size
 593:         self.geometry(f"{self.menu_width}x{current_height}+{current_x}+{current_y}")
 594:         
 595:         print("Menu refreshed after drag and drop")
 596:     
 597:     def find_drop_target_at_position(self, x, y):
 598:         """Find what widget/drop target is at the given screen coordinates"""
 599:         try:
 600:             # Get widget at position relative to this window
 601:             widget_at_pos = self.winfo_containing(x, y)
 602:             
 603:             if not widget_at_pos:
 604:                 return None
 605:                 
 606:             print(f"Widget at position: {widget_at_pos}")
 607:             
 608:             # Check if it's a link (for reordering)
 609:             if hasattr(widget_at_pos, 'link_data') and hasattr(widget_at_pos, 'link_index'):
 610:                 link_data = widget_at_pos.link_data
 611:                 link_index = widget_at_pos.link_index
 612:                 
 613:                 # Don't allow dropping on self
 614:                 if link_index == self.dragged_link_index:
 615:                     return None
 616:                     
 617:                 return {
 618:                     'type': 'reorder', 
 619:                     'link': link_data, 
 620:                     'index': link_index
 621:                 }
 622:             
 623:             # Check if it's a category area (for moving to different category)
 624:             if hasattr(widget_at_pos, 'category'):
 625:                 category = widget_at_pos.category
 626:                 
 627:                 # Don't allow dropping in same category (unless it's for reordering)
 628:                 if category != self.dragged_link_data['category']:
 629:                     return {
 630:                         'type': 'move', 
 631:                         'category': category
 632:                     }
 633:             
 634:             # Check parent widgets for category info
 635:             parent = widget_at_pos
 636:             while parent and parent != self:
 637:                 if hasattr(parent, 'category'):
 638:                     category = parent.category
 639:                     if category != self.dragged_link_data['category']:
 640:                         return {
 641:                             'type': 'move', 
 642:                             'category': category
 643:                         }
 644:                 parent = parent.master
 645:                 
 646:             return None
 647:             
 648:         except Exception as e:
 649:             print(f"Error finding drop target: {e}")
 650:             return None
 651: 
 652: class AddEditLinkDialog(CustomDialog):
 653:     """Dialog for adding or editing links"""
 654:     
 655:     def __init__(self, parent, links_manager, taskbar_instance, edit_mode=False, link_data=None, link_index=None):
 656:         title = "Edit Link" if edit_mode else "Add New Link"
 657:         super().__init__(parent, title, width=450, height=280)
 658:         
 659:         self.links_manager = links_manager
 660:         self.taskbar_instance = taskbar_instance
 661:         self.edit_mode = edit_mode
 662:         self.link_data = link_data
 663:         self.link_index = link_index
 664:         
 665:         self.create_form()
 666:         self.add_buttons()
 667:         
 668:         # Prefill data if editing
 669:         if edit_mode and link_data:
 670:             self.name_field.set(link_data['name'])
 671:             self.path_field.set(link_data['path'])
 672:             self.category_field.set(link_data['category'])
 673:     
 674:     def create_form(self):
 675:         """Create the form fields"""
 676:         # Name field
 677:         self.name_field = FormField(self.dialog_content, "Name:", width=35)
 678:         self.name_field.pack(fill=tk.X, pady=5)
 679:         
 680:         # Path field with browse button
 681:         path_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
 682:         path_frame.pack(fill=tk.X, pady=5)
 683:         
 684:         self.path_field = FormField(path_frame, "Path/URL:", width=25)
 685:         self.path_field.pack(side=tk.LEFT, fill=tk.X, expand=True)
 686:         
 687:         browse_btn = tk.Button(path_frame, text="Browse...", command=self.browse_path,
 688:                               bg=Colors.MEDIUM_GREEN, font=Fonts.DIALOG_LABEL)
 689:         browse_btn.pack(side=tk.RIGHT, padx=(5, 0))
 690:         
 691:         # Category field
 692:         self.category_field = FormField(
 693:             self.dialog_content, "Category:", 
 694:             field_type='combobox',
 695:             values=self.links_manager.get_categories(),
 696:         )
 697:         self.category_field.pack(fill=tk.X, pady=5)
 698:         
 699:         # Set default category to "Quick Links"
 700:         categories = self.links_manager.get_categories()
 701:         if "Quick Links" in categories:
 702:             self.category_field.set("Quick Links")
 703:         elif categories:
 704:             self.category_field.set(categories[0])
 705:     
 706:     def browse_path(self):
 707:         """Browse for file or folder"""
 708:         import os
 709:         
 710:         self.grab_release()
 711:         choice = BrowseChoiceDialog.ask(self)
 712:         
 713:         if choice == "file":
 714:             path = filedialog.askopenfilename(parent=self)
 715:         elif choice == "folder":
 716:             path = filedialog.askdirectory(parent=self)
 717:         else:
 718:             # Restore grab and focus when canceling
 719:             self.grab_set()
 720:             self.focus_force()
 721:             return
 722:         
 723:         if path:
 724:             self.path_field.set(path)
 725:             
 726:             # Auto-populate name field if it's empty
 727:             if not self.name_field.get().strip():
 728:                 if choice == "file":
 729:                     # Extract filename without extension
 730:                     filename = os.path.basename(path)
 731:                     name_without_ext = os.path.splitext(filename)[0]
 732:                     self.name_field.set(name_without_ext)
 733:                 elif choice == "folder":
 734:                     # Extract folder name
 735:                     folder_name = os.path.basename(path.rstrip(os.sep))
 736:                     self.name_field.set(folder_name)
 737:         
 738:         # Always restore grab and focus after browse operation
 739:         self.grab_set()
 740:         self.focus_force()
 741:     
 742:     def add_buttons(self):
 743:         """Add Save and Cancel buttons"""
 744:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 745:         button_container.pack(expand=True)
 746:         
 747:         save_btn = tk.Button(button_container, text="Save", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 748:                             command=self.save_link, width=Dimensions.DIALOG_BUTTON_WIDTH,
 749:                             font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 750:         save_btn.pack(side=tk.LEFT, padx=10)
 751:         
 752:         cancel_btn = tk.Button(button_container, text="Cancel", bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 753:                               command=self.cancel, width=Dimensions.DIALOG_BUTTON_WIDTH,
 754:                               font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 755:         cancel_btn.pack(side=tk.LEFT, padx=10)
 756:     
 757:     def save_link(self):
 758:         """Save the link"""
 759:         name = self.name_field.get().strip()
 760:         path = self.path_field.get().strip()
 761:         category = self.category_field.get()
 762:         
 763:         if not name or not path:
 764:             WarningDialog.show(self, "Invalid Input", "Please enter both name and path.")
 765:             return
 766:         
 767:         if self.edit_mode:
 768:             # Update existing link
 769:             icon = self.link_data.get('icon', '📄') if self.link_data else '📄'
 770:             success = self.links_manager.update_link(self.link_index, name, path, category, icon)
 771:         else:
 772:             # Add new link
 773:             success = self.links_manager.add_link(name, path, category)
 774:         
 775:         if success:
 776:             self.destroy()
 777:             # Refresh menu
 778:             self.taskbar_instance.show_links_menu(None)
 779:         else:
 780:             ErrorDialog.show(self, "Error", "Failed to save link.")
 781:     
 782:     @classmethod
 783:     def show_add_dialog(cls, parent, links_manager, taskbar_instance):
 784:         """Show dialog to add a new link"""
 785:         dialog = cls(parent, links_manager, taskbar_instance)
 786:         dialog.lift()
 787:         dialog.focus_force()
 788:         return dialog
 789:     
 790:     @classmethod
 791:     def show_edit_dialog(cls, parent, links_manager, taskbar_instance, link_data, link_index):
 792:         """Show dialog to edit an existing link"""
 793:         dialog = cls(parent, links_manager, taskbar_instance, True, link_data, link_index)
 794:         dialog.lift()
 795:         dialog.focus_force()
 796:         return dialog
 797: 
 798: class BrowseChoiceDialog(CustomDialog):
 799:     """Custom dialog for choosing between file or folder browsing"""
 800:     
 801:     def __init__(self, parent):
 802:         super().__init__(parent, "Browse Options", width=300, height=180)
 803:         
 804:         # Icon and message
 805:         icon_label = tk.Label(self.dialog_content, text="📁", bg=Colors.LIGHT_GREEN,
 806:                              fg=Colors.BLACK, font=('Arial', 24))
 807:         icon_label.pack(pady=10)
 808:         
 809:         message_label = tk.Label(self.dialog_content, text="What would you like to browse for?", 
 810:                                bg=Colors.LIGHT_GREEN, fg=Colors.BLACK, font=Fonts.DIALOG_LABEL)
 811:         message_label.pack(pady=5)
 812:         
 813:         # Add buttons
 814:         self.add_choice_buttons()
 815:         
 816:         # Bind keys
 817:         self.bind('<Escape>', lambda e: self.cancel())
 818:     
 819:     def add_choice_buttons(self):
 820:         """Add File, Folder, and Cancel buttons"""
 821:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 822:         button_container.pack(expand=True)
 823:         
 824:         # File button
 825:         file_btn = tk.Button(button_container, text="File", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 826:                            command=self.choose_file, width=8,
 827:                            font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 828:         file_btn.pack(side=tk.LEFT, padx=5)
 829:         
 830:         # Folder button
 831:         folder_btn = tk.Button(button_container, text="Folder", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 832:                              command=self.choose_folder, width=8,
 833:                              font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 834:         folder_btn.pack(side=tk.LEFT, padx=5)
 835:         
 836:         # Cancel button
 837:         cancel_btn = tk.Button(button_container, text="Cancel", bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 838:                              command=self.cancel, width=8,
 839:                              font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 840:         cancel_btn.pack(side=tk.LEFT, padx=5)
 841:         
 842:         # Focus on File button as default
 843:         file_btn.focus_set()
 844:     
 845:     def choose_file(self):
 846:         """File button clicked"""
 847:         self.result = "file"
 848:         self.destroy()
 849:     
 850:     def choose_folder(self):
 851:         """Folder button clicked"""
 852:         self.result = "folder"
 853:         self.destroy()
 854:     
 855:     @classmethod
 856:     def ask(cls, parent):
 857:         """Show browse choice dialog and return result"""
 858:         dialog = cls(parent)
 859:         dialog.lift()
 860:         dialog.focus_force()
 861:         try:
 862:             parent.wait_window(dialog)
 863:             return dialog.result
 864:         finally:
 865:             # Ensure parent regains focus after dialog closes
 866:             if parent and parent.winfo_exists():
 867:                 parent.focus_force()

────────────────────────────────────────────────────────────────────────────────
FILE: restore_deskop.py
────────────────────────────────────────────────────────────────────────────────
Path: restore_deskop.py
Size: 1.5 KB
Lines: 41 total, 33 non-empty
Characters: 1,488
Type: Desktop restoration utilities
────────────────────────────────────────────────────────────────────────────────

   1: import ctypes
   2: from ctypes import wintypes
   3: import time
   4: 
   5: def fix_desktop_space():
   6:     """Force restore desktop working area"""
   7:     user32 = ctypes.windll.user32
   8:     
   9:     # Method 1: Get actual screen size and restore
  10:     screen_width = user32.GetSystemMetrics(0)
  11:     screen_height = user32.GetSystemMetrics(1)
  12:     
  13:     print(f"Screen size: {screen_width}x{screen_height}")
  14:     
  15:     # Method 2: Force full screen work area
  16:     full_area = wintypes.RECT(0, 0, screen_width, screen_height)
  17:     result = user32.SystemParametersInfoW(0x002F, 0, ctypes.byref(full_area), 0)
  18:     print(f"Full restore attempt: {'Success' if result else 'Failed'}")
  19:     
  20:     # Method 3: Broadcast change to all windows
  21:     HWND_BROADCAST = 0xFFFF
  22:     WM_SETTINGCHANGE = 0x001A
  23:     user32.SendMessageW(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0)
  24:     
  25:     # Method 4: Try with SPIF_SENDCHANGE flag
  26:     SPIF_SENDCHANGE = 0x0002
  27:     SPIF_UPDATEINIFILE = 0x0001
  28:     result2 = user32.SystemParametersInfoW(0x002F, 0, ctypes.byref(full_area), SPIF_SENDCHANGE | SPIF_UPDATEINIFILE)
  29:     print(f"Restore with flags: {'Success' if result2 else 'Failed'}")
  30:     
  31:     # Method 5: Explorer restart (most aggressive)
  32:     print("\nRestarting Explorer to force refresh...")
  33:     import os
  34:     os.system("taskkill /f /im explorer.exe")
  35:     time.sleep(1)
  36:     os.system("start explorer.exe")
  37: 
  38: if __name__ == "__main__":
  39:     fix_desktop_space()
  40:     print("\nDesktop space should be restored!")
  41:     print("If not, try logging out and back in.")

────────────────────────────────────────────────────────────────────────────────
FILE: snip_feature.py
────────────────────────────────────────────────────────────────────────────────
Path: snip_feature.py
Size: 16.1 KB
Lines: 410 total, 331 non-empty
Characters: 16,062
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # snip_feature.py
   2: """
   3: Screen capture and document integration feature for SuiteView Taskbar
   4: Handles taking screenshots and inserting them into Word documents or Outlook emails
   5: """
   6: 
   7: import os
   8: import tempfile
   9: import time
  10: from datetime import datetime
  11: from PIL import ImageGrab
  12: import win32com.client
  13: import pythoncom
  14: from config import Colors, Fonts
  15: from ui_components import ErrorDialog, WarningDialog
  16: import tkinter as tk
  17: 
  18: class SnippingManager:
  19:     """Manages screen capture and document integration"""
  20:     
  21:     def __init__(self, parent_window=None):
  22:         self.parent_window = parent_window
  23:         self.current_word_app = None
  24:         self.current_word_doc = None
  25:         self.current_outlook_app = None
  26:         self.current_outlook_item = None
  27:         self.temp_image_counter = 0
  28:         
  29:         # Create temp directory for screenshots
  30:         self.temp_dir = os.path.join(tempfile.gettempdir(), "SuiteView_Screenshots")
  31:         self.ensure_temp_directory()
  32:     
  33:     def ensure_temp_directory(self):
  34:         """Ensure temporary directory exists for storing screenshots"""
  35:         try:
  36:             if not os.path.exists(self.temp_dir):
  37:                 os.makedirs(self.temp_dir)
  38:         except Exception as e:
  39:             print(f"Warning: Could not create temp directory: {e}")
  40:             self.temp_dir = tempfile.gettempdir()
  41:     
  42:     def capture_primary_screen(self):
  43:         """Capture screenshot of primary monitor and save to temp file"""
  44:         try:
  45:             # Capture the primary screen
  46:             screenshot = ImageGrab.grab()
  47:             
  48:             # Generate unique filename
  49:             timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
  50:             self.temp_image_counter += 1
  51:             filename = f"screenshot_{timestamp}_{self.temp_image_counter}.png"
  52:             filepath = os.path.join(self.temp_dir, filename)
  53:             
  54:             # Save screenshot
  55:             screenshot.save(filepath, "PNG")
  56:             print(f"Screenshot saved: {filepath}")
  57:             return filepath
  58:             
  59:         except Exception as e:
  60:             self._show_error("Screenshot Error", f"Failed to capture screenshot: {str(e)}")
  61:             return None
  62:     
  63:     def snip_to_target(self, target_app="Word"):
  64:         """Main method to handle snipping to specified application"""
  65:         try:
  66:             # Capture screenshot first
  67:             image_path = self.capture_primary_screen()
  68:             if not image_path:
  69:                 return False
  70:             
  71:             # Route to appropriate handler
  72:             if target_app.lower() == "word":
  73:                 return self.snip_to_word(image_path)
  74:             elif target_app.lower() == "outlook":
  75:                 return self.snip_to_outlook(image_path)
  76:             else:
  77:                 self._show_error("Invalid Target", f"Unknown target application: {target_app}")
  78:                 return False
  79:                 
  80:         except Exception as e:
  81:             self._show_error("Snip Error", f"Failed to complete snip operation: {str(e)}")
  82:             return False
  83:     
  84:     def snip_to_word(self, image_path):
  85:         """Insert screenshot into Word document"""
  86:         try:
  87:             # Check if we have an active Word document
  88:             if not self._is_word_document_active():
  89:                 # Create new Word document
  90:                 if not self._create_new_word_document():
  91:                     return False
  92:             
  93:             # Insert image into document
  94:             if self._insert_image_to_word(image_path):
  95:                 print("Successfully added screenshot to Word document")
  96:                 return True
  97:             else:
  98:                 return False
  99:                 
 100:         except Exception as e:
 101:             self._show_error("Word Error", f"Failed to add screenshot to Word: {str(e)}")
 102:             return False
 103:     
 104:     def snip_to_outlook(self, image_path):
 105:         """Insert screenshot into Outlook email"""
 106:         try:
 107:             # Check if we have an active Outlook email
 108:             if not self._is_outlook_email_active():
 109:                 # Create new Outlook email
 110:                 if not self._create_new_outlook_email():
 111:                     return False
 112:             
 113:             # Insert image into email
 114:             if self._insert_image_to_outlook(image_path):
 115:                 print("Successfully added screenshot to Outlook email")
 116:                 return True
 117:             else:
 118:                 return False
 119:                 
 120:         except Exception as e:
 121:             self._show_error("Outlook Error", f"Failed to add screenshot to Outlook: {str(e)}")
 122:             return False
 123:     
 124:     def _is_word_document_active(self):
 125:         """Check if the current Word document is still active"""
 126:         try:
 127:             if not self.current_word_app or not self.current_word_doc:
 128:                 return False
 129:             
 130:             # Try to access the document - this will fail if it's closed
 131:             _ = self.current_word_doc.Name
 132:             
 133:             # Check if the document is still in the application's documents collection
 134:             for doc in self.current_word_app.Documents:
 135:                 if doc.Name == self.current_word_doc.Name:
 136:                     return True
 137:             
 138:             return False
 139:             
 140:         except Exception:
 141:             # If any error occurs, assume document is no longer active
 142:             self.current_word_doc = None
 143:             return False
 144:     
 145:     def _is_outlook_email_active(self):
 146:         """Check if the current Outlook email is still active"""
 147:         try:
 148:             if not self.current_outlook_app or not self.current_outlook_item:
 149:                 return False
 150:             
 151:             # Try to access the email item - this will fail if it's closed/sent
 152:             _ = self.current_outlook_item.Subject
 153:             return True
 154:             
 155:         except Exception:
 156:             # If any error occurs, assume email is no longer active
 157:             self.current_outlook_item = None
 158:             return False
 159:     
 160:     def _create_new_word_document(self):
 161:         """Create a new Word document"""
 162:         try:
 163:             # Initialize COM
 164:             pythoncom.CoInitialize()
 165:             
 166:             # Connect to or create Word application
 167:             try:
 168:                 self.current_word_app = win32com.client.GetActiveObject("Word.Application")
 169:             except:
 170:                 self.current_word_app = win32com.client.Dispatch("Word.Application")
 171:             
 172:             # Make Word visible
 173:             self.current_word_app.Visible = True
 174:             
 175:             # Create new document
 176:             self.current_word_doc = self.current_word_app.Documents.Add()
 177:             
 178:             # Add a title
 179:             title_range = self.current_word_doc.Range(0, 0)
 180:             title_range.Text = f"Screenshots - {datetime.now().strftime('%Y-%m-%d %I:%M %p')}\n\n"
 181:             title_range.Font.Bold = True
 182:             title_range.Font.Size = 14
 183:             
 184:             # Move cursor to end for image insertion
 185:             # Use numeric constant instead of named constant to avoid import issues
 186:             self.current_word_doc.Range().Collapse(0)  # 0 = wdCollapseEnd
 187:             
 188:             print("Created new Word document")
 189:             return True
 190:             
 191:         except Exception as e:
 192:             self._show_error("Word Creation Error", f"Failed to create Word document: {str(e)}")
 193:             self.current_word_app = None
 194:             self.current_word_doc = None
 195:             return False
 196:     
 197:     def _create_new_outlook_email(self):
 198:         """Create a new Outlook email"""
 199:         try:
 200:             # Initialize COM
 201:             pythoncom.CoInitialize()
 202:             
 203:             # Connect to Outlook
 204:             try:
 205:                 self.current_outlook_app = win32com.client.GetActiveObject("Outlook.Application")
 206:             except:
 207:                 self.current_outlook_app = win32com.client.Dispatch("Outlook.Application")
 208:             
 209:             # Create new mail item
 210:             self.current_outlook_item = self.current_outlook_app.CreateItem(0)  # 0 = olMailItem
 211:             
 212:             # Set email properties
 213:             self.current_outlook_item.Subject = f"Screenshots - {datetime.now().strftime('%Y-%m-%d %I:%M %p')}"
 214:             self.current_outlook_item.Body = "Screenshots captured:\n\n"
 215:             
 216:             # Display the email
 217:             self.current_outlook_item.Display()
 218:             
 219:             print("Created new Outlook email")
 220:             return True
 221:             
 222:         except Exception as e:
 223:             self._show_error("Outlook Creation Error", f"Failed to create Outlook email: {str(e)}")
 224:             self.current_outlook_app = None
 225:             self.current_outlook_item = None
 226:             return False
 227:     
 228:     def _insert_image_to_word(self, image_path):
 229:         """Insert image into the current Word document"""
 230:         try:
 231:             if not self.current_word_doc:
 232:                 return False
 233:             
 234:             # Always position at the end of the document to preserve the title
 235:             doc_end = self.current_word_doc.Range()
 236:             doc_end.Collapse(0)  # 0 = wdCollapseEnd
 237:             doc_end.Select()
 238:             
 239:             # Get the selection at the end of the document
 240:             selection = self.current_word_app.Selection
 241:             
 242:             # Add timestamp before image
 243:             timestamp_text = f"Screenshot taken: {datetime.now().strftime('%I:%M:%S %p')}\n"
 244:             selection.TypeText(timestamp_text)
 245:             
 246:             # Insert the image
 247:             inline_shape = selection.InlineShapes.AddPicture(
 248:                 FileName=image_path,
 249:                 LinkToFile=False,
 250:                 SaveWithDocument=True
 251:             )
 252:             
 253:             # Scale image to fit page width (optional)
 254:             page_width = self.current_word_doc.PageSetup.PageWidth - \
 255:                         self.current_word_doc.PageSetup.LeftMargin - \
 256:                         self.current_word_doc.PageSetup.RightMargin
 257:             
 258:             if inline_shape.Width > page_width:
 259:                 scale_factor = page_width / inline_shape.Width
 260:                 inline_shape.Width = page_width
 261:                 inline_shape.Height = inline_shape.Height * scale_factor
 262:             
 263:             # Add some space after the image
 264:             selection.TypeText("\n\n")
 265:             
 266:             # Clean up temp file
 267:             self._cleanup_temp_file(image_path)
 268:             
 269:             return True
 270:             
 271:         except Exception as e:
 272:             print(f"Error inserting image to Word: {e}")
 273:             return False
 274:     
 275:     def _insert_image_to_outlook(self, image_path):
 276:         """Insert image into the current Outlook email"""
 277:         try:
 278:             if not self.current_outlook_item:
 279:                 return False
 280:             
 281:             # Get the current body and add timestamp
 282:             current_body = self.current_outlook_item.Body if self.current_outlook_item.Body else ""
 283:             timestamp_text = f"Screenshot taken: {datetime.now().strftime('%I:%M:%S %p')}\n"
 284:             
 285:             # Add the image as an attachment and embed it
 286:             attachment = self.current_outlook_item.Attachments.Add(image_path)
 287:             
 288:             # For HTML emails, we could embed the image inline, but for simplicity
 289:             # we'll just attach it and add a note in the body
 290:             self.current_outlook_item.Body = current_body + timestamp_text + "[Screenshot attached]\n\n"
 291:             
 292:             # Clean up temp file
 293:             self._cleanup_temp_file(image_path)
 294:             
 295:             return True
 296:             
 297:         except Exception as e:
 298:             print(f"Error inserting image to Outlook: {e}")
 299:             return False
 300:     
 301:     def _cleanup_temp_file(self, filepath):
 302:         """Clean up temporary image file"""
 303:         try:
 304:             # Wait a moment to ensure file is not locked
 305:             time.sleep(0.1)
 306:             if os.path.exists(filepath):
 307:                 os.remove(filepath)
 308:         except Exception as e:
 309:             print(f"Warning: Could not delete temp file {filepath}: {e}")
 310:     
 311:     def _show_error(self, title, message):
 312:         """Show error dialog to user"""
 313:         print(f"Error - {title}: {message}")
 314:         if self.parent_window:
 315:             try:
 316:                 ErrorDialog.show(self.parent_window, title, message)
 317:             except:
 318:                 pass  # Fallback to console output only
 319:     
 320:     def cleanup_temp_directory(self):
 321:         """Clean up old temporary files"""
 322:         try:
 323:             if os.path.exists(self.temp_dir):
 324:                 for filename in os.listdir(self.temp_dir):
 325:                     if filename.startswith("screenshot_"):
 326:                         filepath = os.path.join(self.temp_dir, filename)
 327:                         # Delete files older than 1 hour
 328:                         if time.time() - os.path.getctime(filepath) > 3600:
 329:                             os.remove(filepath)
 330:         except Exception as e:
 331:             print(f"Warning: Could not clean temp directory: {e}")
 332:     
 333:     def force_new_document(self, target_app="Word"):
 334:         """Force creation of a new document (useful for manual reset)"""
 335:         if target_app.lower() == "word":
 336:             self.current_word_doc = None
 337:             self.current_word_app = None
 338:         elif target_app.lower() == "outlook":
 339:             self.current_outlook_item = None
 340:             self.current_outlook_app = None
 341: 
 342: class SnipUI:
 343:     """UI components for the Snip feature"""
 344:     
 345:     @staticmethod
 346:     def create_snip_button(parent, snipping_manager, target_var):
 347:         """Create the Snip button"""
 348:         def on_snip_click():
 349:             target = target_var.get()
 350:             success = snipping_manager.snip_to_target(target)
 351:             if success:
 352:                 print(f"Screenshot successfully added to {target}")
 353:         
 354:         snip_btn = tk.Button(parent, text="Snip", 
 355:                            bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 356:                            relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, 
 357:                            cursor='hand2', activebackground=Colors.HOVER_GREEN, 
 358:                            bd=0, padx=15, command=on_snip_click)
 359:         return snip_btn
 360:     
 361:     @staticmethod
 362:     def create_target_combobox(parent, default_value="Word"):
 363:         """Create the target application combobox"""
 364:         from tkinter import ttk
 365:         
 366:         target_var = tk.StringVar(value=default_value)
 367:         combo = ttk.Combobox(parent, textvariable=target_var, 
 368:                            values=["Word", "Outlook"],
 369:                            state='readonly', width=8)
 370:         
 371:         # Style the combobox to match the app theme
 372:         style = ttk.Style()
 373:         style.theme_use('default')
 374:         style.configure('Snip.TCombobox', 
 375:                        fieldbackground=Colors.MEDIUM_GREEN, 
 376:                        background=Colors.MEDIUM_GREEN)
 377:         combo.configure(style='Snip.TCombobox')
 378:         
 379:         return combo, target_var
 380: 
 381: # Integration helper functions for taskbar.py
 382: def add_snip_feature_to_taskbar(taskbar_instance):
 383:     """Add Snip feature to the existing taskbar"""
 384:     
 385:     # Create snipping manager
 386:     snipping_manager = SnippingManager(taskbar_instance.root)
 387:     
 388:     # Create frame for snip controls
 389:     snip_frame = tk.Frame(taskbar_instance.main_frame, bg=Colors.DARK_GREEN)
 390:     snip_frame.pack(side=tk.LEFT, padx=10)
 391:     
 392:     # Create target selection combobox
 393:     combo, target_var = SnipUI.create_target_combobox(snip_frame)
 394:     combo.pack(side=tk.LEFT, padx=(0, 5))
 395:     
 396:     # Create snip button
 397:     snip_btn = SnipUI.create_snip_button(snip_frame, snipping_manager, target_var)
 398:     snip_btn.pack(side=tk.LEFT)
 399:     
 400:     # Store reference for cleanup
 401:     taskbar_instance.snipping_manager = snipping_manager
 402:     
 403:     # Schedule periodic cleanup of temp files
 404:     def cleanup_temp_files():
 405:         snipping_manager.cleanup_temp_directory()
 406:         taskbar_instance.root.after(300000, cleanup_temp_files)  # Every 5 minutes
 407:     
 408:     taskbar_instance.root.after(300000, cleanup_temp_files)
 409:     
 410:     return snipping_manager

────────────────────────────────────────────────────────────────────────────────
FILE: taskbar.py
────────────────────────────────────────────────────────────────────────────────
Path: taskbar.py
Size: 16.1 KB
Lines: 398 total, 317 non-empty
Characters: 16,060
Type: Core taskbar functionality and UI
────────────────────────────────────────────────────────────────────────────────

   1: # taskbar.py (UPDATED)
   2: """
   3: Core taskbar window and layout for SuiteView Taskbar Application
   4: """
   5: 
   6: import tkinter as tk
   7: from tkinter import ttk
   8: import sys
   9: from ctypes import wintypes
  10: 
  11: from config import Colors, Fonts, Dimensions, Settings
  12: from utils import WindowsUtils, UIUtils
  13: from links_manager import LinksManager
  14: from quick_links import QuickLinksMenu
  15: from snip_feature import add_snip_feature_to_taskbar
  16: from folder_inventory import add_folder_inventory_to_taskbar  # UPDATED IMPORT
  17: 
  18: from window_manager import WindowManager
  19: from windows_menu import WindowsMenu
  20: from pinned_windows import PinnedWindowsSection
  21: 
  22: class SuiteViewTaskbar:
  23:     """Main taskbar application window"""
  24:     
  25:     def __init__(self):
  26:         self.root = tk.Tk()
  27:         self.links_manager = LinksManager()
  28:         self.window_manager = WindowManager()
  29: 
  30:         # Initialize these BEFORE creating UI
  31:         self.links_menu = None
  32:         self.windows_menu = None
  33:         self.pinned_section = None  # Initialize to None
  34:         self.windows_menu_geometry = None
  35: 
  36: 
  37:         # Store original work area for restoration
  38:         self.original_work_area = WindowsUtils.get_work_area()
  39:         
  40:         # Get screen dimensions
  41:         self.screen_width, self.screen_height = WindowsUtils.get_screen_dimensions()
  42:         
  43:         # Get Windows taskbar height for better positioning
  44:         self.windows_taskbar_height = WindowsUtils.get_windows_taskbar_height()
  45:         
  46:         # Position the custom taskbar above Windows taskbar
  47:         self.y_position = self.screen_height - self.windows_taskbar_height - Dimensions.TASKBAR_HEIGHT
  48:         
  49:         # Setup the window
  50:         self.setup_window()
  51:         
  52:         # Create taskbar content
  53:         self.create_taskbar_content()
  54:         
  55:         # Setup event bindings
  56:         self.bind_events()
  57:         
  58:         # Apply Windows API modifications
  59:         self.setup_windows_integration()
  60:         
  61: 
  62:     def toggle_windows_menu(self):
  63:         """Toggle the windows management menu"""
  64:         if self.windows_menu and hasattr(self.windows_menu, 'winfo_exists'):
  65:             try:
  66:                 if self.windows_menu.winfo_exists():
  67:                     # Store current geometry before closing
  68:                     self.windows_menu_geometry = self.windows_menu.get_current_geometry()
  69:                     self.windows_menu.close_window()
  70:                     self.windows_menu = None
  71:                     return
  72:             except:
  73:                 self.windows_menu = None
  74:         
  75:         # Create new windows menu
  76:         self.windows_menu = WindowsMenu(self.root, self.window_manager, 
  77:                                       self.on_windows_pinned,
  78:                                       self.windows_menu_geometry)
  79:         
  80:         # If no stored geometry, position it properly
  81:         if not self.windows_menu_geometry:
  82:             # Update the window to get its actual size
  83:             self.windows_menu.update_idletasks()
  84:             
  85:             # Calculate position - above taskbar, right side
  86:             window_width = self.windows_menu.winfo_reqwidth()
  87:             window_height = self.windows_menu.winfo_reqheight()
  88:             
  89:             x = self.root.winfo_screenwidth() - window_width - 20  # 20px from right edge
  90:             y = self.y_position - window_height - 5  # 5px above taskbar
  91:             
  92:             # Ensure it doesn't go off-screen
  93:             x = max(0, x)
  94:             y = max(0, y)
  95:             
  96:             self.windows_menu.geometry(f"{window_width}x{window_height}+{x}+{y}")
  97:     
  98:     def setup_window(self):
  99:         """Configure the main window properties"""
 100:         # Remove window decorations
 101:         self.root.overrideredirect(True)
 102:         
 103:         # Set window attributes
 104:         self.root.attributes('-topmost', True)
 105:         self.root.attributes('-alpha', Settings.TASKBAR_OPACITY)
 106:         
 107:         # Configure window geometry
 108:         self.root.geometry(f"{self.screen_width}x{Dimensions.TASKBAR_HEIGHT}+0+{self.y_position}")
 109:         
 110:         # Set background color to dark green
 111:         self.root.configure(bg=Colors.DARK_GREEN)
 112:     
 113:     def create_taskbar_content(self):
 114:         """Create the taskbar UI elements"""
 115:         # Create main frame
 116:         self.main_frame = tk.Frame(self.root, bg=Colors.DARK_GREEN, highlightthickness=0)
 117:         self.main_frame.pack(fill=tk.BOTH, expand=True)
 118:         
 119:         # SuiteView Logo/Title
 120:         self.create_logo_section()
 121:         
 122:         # Separator
 123:         separator = UIUtils.create_separator(self.main_frame, Colors.DARK_GREEN, width=2)
 124:         separator.pack(side=tk.LEFT, fill=tk.Y, padx=10)
 125:         
 126:         # Main buttons
 127:         self.create_main_buttons()
 128:         
 129:         # Right side elements
 130:         self.create_right_side_elements()
 131:     
 132:     def create_logo_section(self):
 133:         """Create the SuiteView logo/title section"""
 134:         logo_frame = tk.Frame(self.main_frame, bg=Colors.DARK_GREEN)
 135:         logo_frame.pack(side=tk.LEFT, padx=10)
 136:         
 137:         # Logo text with styling
 138:         logo_label = tk.Label(logo_frame, text=Settings.APP_NAME, bg=Colors.DARK_GREEN, 
 139:                              fg=Colors.WHITE, font=Fonts.TASKBAR_TITLE)
 140:         logo_label.pack()
 141:         logo_label.bind("<Button-3>", self.show_links_menu)
 142:     
 143:     def create_main_buttons(self):
 144:         """Create the main taskbar buttons"""
 145:         # Existing buttons
 146:         buttons_data = [
 147:             ("Get Policy", None),
 148:             ("Cyber", None),
 149:             ("TAI", None)
 150:         ]
 151:         
 152:         for text, command in buttons_data:
 153:             btn = tk.Button(self.main_frame, text=text, bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 154:                         relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, cursor='hand2',
 155:                         activebackground=Colors.HOVER_GREEN, bd=0, padx=15)
 156:             btn.pack(side=tk.LEFT, padx=5)
 157:             btn.bind("<Button-3>", self.show_links_menu)
 158:             if command:
 159:                 btn.configure(command=command)
 160:         
 161:         # Add separator before new features
 162:         separator = UIUtils.create_separator(self.main_frame, Colors.DARK_GREEN, width=2)
 163:         separator.pack(side=tk.LEFT, fill=tk.Y, padx=10)
 164:         
 165:         # Add Inventory feature
 166:         inventory_btn = add_folder_inventory_to_taskbar(self)
 167:         inventory_btn.pack(side=tk.LEFT, padx=5)
 168:         inventory_btn.bind("<Button-3>", self.show_links_menu)
 169:         
 170:         # Add separator before Snip feature
 171:         separator2 = UIUtils.create_separator(self.main_frame, Colors.DARK_GREEN, width=2)
 172:         separator2.pack(side=tk.LEFT, fill=tk.Y, padx=10)
 173:         
 174:         # Add Snip feature
 175:         self.snipping_manager = add_snip_feature_to_taskbar(self)
 176:         
 177:         # Add separator before pinned windows section
 178:         separator3 = UIUtils.create_separator(self.main_frame, Colors.DARK_GREEN, width=2)
 179:         separator3.pack(side=tk.LEFT, fill=tk.Y, padx=10)
 180:         
 181:         # Create and store pinned windows section - THIS IS THE KEY FIX
 182:         print(f"Creating pinned section...")
 183:         self.pinned_section = PinnedWindowsSection(self.main_frame, self.window_manager, self.on_windows_pinned)
 184:         self.pinned_section.pack(side=tk.LEFT, fill=tk.Y, padx=5)
 185:         
 186:         # Set minimum width for the section
 187:         self.pinned_section.configure(width=Settings.PINNED_SECTION_WIDTH)
 188:         
 189:         # Debug to confirm it's created and assigned
 190:         print(f"Pinned section created and assigned: {self.pinned_section}")
 191:         print(f"self.pinned_section is not None: {self.pinned_section is not None}")
 192:     
 193:     def create_right_side_elements(self):
 194:         """Create the right side elements of the taskbar"""
 195:         
 196:         # X close button
 197:         close_btn = tk.Label(self.main_frame, text="X", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 198:                             font=(Fonts.TASKBAR_BUTTON[0], Fonts.TASKBAR_BUTTON[1], 'bold'), 
 199:                             cursor='hand2')
 200:         close_btn.pack(side=tk.RIGHT, padx=5)
 201:         close_btn.bind("<Button-1>", self.close_app)
 202:     
 203:         #Windows button
 204:         windows_btn = tk.Button(self.main_frame, text="Windows", 
 205:                             bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 206:                             relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, 
 207:                             cursor='hand2', activebackground=Colors.HOVER_GREEN, 
 208:                             bd=0, padx=15, command=self.toggle_windows_menu)
 209:         windows_btn.pack(side=tk.RIGHT, padx=5)
 210: 
 211:     def bind_events(self):
 212:         """Bind event handlers"""
 213:         # Main window events
 214:         self.root.bind("<Button-3>", self.show_links_menu)
 215:         self.main_frame.bind("<Button-3>", self.show_links_menu)
 216:         
 217:         # Emergency exit keys
 218:         self.root.bind("<Escape>", self.close_app)
 219:         self.root.bind("<Control-q>", self.close_app)
 220:         self.root.bind("<Control-Q>", self.close_app)
 221:         self.root.bind("<Alt-F4>", self.close_app)
 222:     
 223:     def setup_windows_integration(self):
 224:         """Setup Windows API integration"""
 225:         # Keep window on top using Windows API
 226:         self.set_always_on_top()
 227:         
 228:         # Adjust desktop working area
 229:         self.adjust_work_area()
 230:         
 231:     def show_links_menu(self, event):
 232:         """Show the right-click links menu positioned above the taskbar"""
 233:         if self.links_menu:
 234:             self.links_menu.destroy()
 235:         
 236:         # Create the menu at a temporary position first
 237:         temp_x, temp_y = 0, 0
 238:         self.links_menu = QuickLinksMenu(self.root, self, temp_x, temp_y)
 239:         
 240:         # Get cursor position or use center position
 241:         if event:
 242:             x = self.root.winfo_pointerx() - 200  # Offset to center menu on cursor
 243:         else:
 244:             x = self.screen_width // 2 - 200  # Center horizontally
 245:         
 246:         # Calculate proper position above YOUR custom taskbar
 247:         final_y = self.y_position - self.links_menu.menu_height - 5  # 5px gap above YOUR taskbar
 248:         final_x = x
 249:         
 250:         # Reposition the menu to the correct location
 251:         self.links_menu.geometry(f"+{final_x}+{final_y}")
 252:         
 253:         # Debug output
 254:         print(f"Estimated height: {self.links_menu.menu_height}")
 255:         print(f"Positioned menu at: {final_x}, {final_y}")
 256:         print(f"Menu bottom should be at: {final_y + self.links_menu.menu_height}")
 257:        
 258:     def show_windows_menu(self, event=None):
 259:         """Show the windows management menu - toggle if already open"""
 260:         if self.windows_menu and self.windows_menu.winfo_exists():
 261:             # If menu exists and is open, close it
 262:             self.windows_menu.close_window()
 263:             self.windows_menu = None
 264:         else:
 265:             # Otherwise, create and show it
 266:             # Get screen dimensions
 267:             screen_width = self.root.winfo_screenwidth()
 268:             
 269:             # Position the menu above the taskbar, centered on screen
 270:             x = (screen_width - 700) // 2  # Center a 700px wide menu
 271:             y = self.y_position - 600  # Default height assumption
 272:             
 273:     def set_always_on_top(self):
 274:         """Force window to stay on top using Windows API"""
 275:         WindowsUtils.set_window_topmost(self.root.winfo_id())
 276:     
 277:     def adjust_work_area(self):
 278:         """Adjust desktop work area to make room for taskbar"""
 279:         if self.original_work_area:
 280:             work_area = wintypes.RECT()
 281:             work_area.left = self.original_work_area.left
 282:             work_area.top = self.original_work_area.top
 283:             work_area.right = self.original_work_area.right
 284:             work_area.bottom = self.y_position
 285:             
 286:             success = WindowsUtils.set_work_area(work_area)
 287:             if not success:
 288:                 print("Could not adjust work area. May require admin privileges.")
 289:     
 290:     def close_app(self, event=None):
 291:         """Close the application"""
 292:         try:
 293:             self.window_manager.unhide_all_windows()
 294:             self.restore_work_area()
 295:         except:
 296:             pass  # Don't fail if restore doesn't work
 297:         
 298:         # Clean up snipping manager if it exists
 299:         if hasattr(self, 'snipping_manager'):
 300:             try:
 301:                 self.snipping_manager.cleanup_temp_directory()
 302:             except:
 303:                 pass
 304:         
 305:         # Force kill any open dialogs
 306:         for child in self.root.winfo_children():
 307:             if isinstance(child, tk.Toplevel):
 308:                 child.destroy()
 309:         
 310:         self.root.quit()
 311:         self.root.destroy()
 312:         sys.exit(0)
 313:     
 314:     def restore_work_area(self):
 315:         """Restore original work area"""
 316:         if self.original_work_area:
 317:             WindowsUtils.restore_work_area(self.original_work_area)
 318:     
 319:     def run(self):
 320:         """Start the application"""
 321:         """Start the application"""
 322:         # Verify setup before starting
 323:         self.verify_setup()
 324:         
 325:         # Start the periodic topmost maintenance
 326:         self.root.after(Settings.AUTO_REFRESH_INTERVAL, self.maintain_topmost)
 327:         
 328:         # Start the main event loop
 329:         self.root.mainloop()
 330:     
 331:     def maintain_topmost(self):
 332:         """Periodically ensure window stays on top"""
 333:         self.set_always_on_top()
 334: 
 335:         # Update pinned window button states
 336:         if self.pinned_section:
 337:             self.pinned_section.update_window_states()
 338: 
 339:         self.root.after(Settings.AUTO_REFRESH_INTERVAL, self.maintain_topmost)
 340: 
 341:     def toggle_windows_menu(self):
 342:         """Toggle the windows management menu"""
 343:         if self.windows_menu and hasattr(self.windows_menu, 'winfo_exists'):
 344:             try:
 345:                 if self.windows_menu.winfo_exists():
 346:                     # Store current geometry BEFORE closing
 347:                     self.windows_menu_geometry = self.windows_menu.get_current_geometry()
 348:                     print(f"Storing geometry: {self.windows_menu_geometry}")  # Debug
 349:                     self.windows_menu.close_window()
 350:                     self.windows_menu = None
 351:                     return
 352:             except:
 353:                 self.windows_menu = None
 354:         
 355:         # Create new windows menu
 356:         print(f"Creating menu with stored geometry: {self.windows_menu_geometry}")  # Debug
 357:         self.windows_menu = WindowsMenu(self.root, self.window_manager, 
 358:                                     self.on_windows_pinned,
 359:                                     self.windows_menu_geometry)
 360:     
 361: 
 362:     def on_windows_pinned(self):
 363:         """Callback when windows are pinned/unpinned"""
 364:         print(f"\n=== ON_WINDOWS_PINNED CALLED ===")
 365:         print(f"Pinned section: {self.pinned_section}")
 366:         
 367:         if self.pinned_section:
 368:             print(f"Refreshing pinned section...")
 369:             self.pinned_section.refresh()
 370:         else:
 371:             print(f"ERROR: pinned_section is None!")
 372:         
 373:         # Always refresh the Windows Manager if it's open to update the list
 374:         if self.windows_menu and hasattr(self.windows_menu, 'winfo_exists'):
 375:             try:
 376:                 if self.windows_menu.winfo_exists():
 377:                     print(f"Refreshing Windows Manager...")
 378:                     self.windows_menu.refresh_window_list()
 379:                 else:
 380:                     print(f"Windows Manager exists but window is destroyed")
 381:             except Exception as e:
 382:                 print(f"Error refreshing Windows Manager: {e}")
 383:                 self.windows_menu = None
 384:         else:
 385:             print(f"Windows Manager is not open")
 386:             
 387:         print(f"=== END ON_WINDOWS_PINNED ===\n")
 388: 
 389:     def verify_setup(self):
 390:         """Verify all components are properly initialized"""
 391:         print(f"\n=== VERIFYING TASKBAR SETUP ===")
 392:         print(f"Window manager: {self.window_manager}")
 393:         print(f"Pinned section: {self.pinned_section}")
 394:         print(f"Pinned section type: {type(self.pinned_section)}")
 395:         if self.pinned_section:
 396:             print(f"Pinned section parent: {self.pinned_section.master}")
 397:             print(f"Pinned section visible: {self.pinned_section.winfo_exists()}")
 398:         print(f"=== END VERIFICATION ===\n")

────────────────────────────────────────────────────────────────────────────────
FILE: ui_components.py
────────────────────────────────────────────────────────────────────────────────
Path: ui_components.py
Size: 28.7 KB
Lines: 745 total, 615 non-empty
Characters: 29,342
Type: Reusable UI components and dialogs
────────────────────────────────────────────────────────────────────────────────

   1: # ui_components.py
   2: """
   3: Shared UI components for SuiteView Taskbar Application
   4: Contains reusable dialogs, custom widgets, and styling functions
   5: """
   6: 
   7: import tkinter as tk
   8: from tkinter import ttk
   9: from config import Colors, Fonts, Dimensions
  10: from utils import UIUtils
  11: 
  12: class CustomDialog(tk.Toplevel):
  13:     """Base class for custom dialogs with consistent styling"""
  14:     
  15:     def __init__(self, parent, title, width=400, height=300, resizable=False, x=None, y=None):
  16:         super().__init__(parent)
  17:         self.parent = parent
  18:         self.result = None
  19:         
  20:         # Initialize drag variables
  21:         self.is_dragging = False
  22:         self.drag_start_x = 0
  23:         self.drag_start_y = 0
  24:         
  25:         # Initialize topmost maintenance
  26:         self.maintain_topmost_active = True
  27:         
  28:         # Window setup
  29:         self.configure(bg=Colors.DARK_GREEN)
  30:         self.resizable(resizable, resizable)
  31:         self.overrideredirect(True)  # Remove default title bar
  32:         
  33:         # Make dialog modal and always on top
  34:         self.transient(parent)
  35:         self.attributes('-topmost', True)
  36:         self.lift()
  37:         
  38:         if x is not None and y is not None:
  39:             # Use custom position
  40:             self.geometry(f"{width}x{height}+{x}+{y}")
  41:         else:
  42:             # Center on screen (existing behavior)
  43:             UIUtils.center_window(self, width, height)
  44:         
  45:         # Main content frame
  46:         self.content_frame = tk.Frame(self, bg=Colors.LIGHT_GREEN, relief=tk.RAISED, bd=2)
  47:         self.content_frame.pack(fill=tk.BOTH, expand=True, padx=3, pady=3)
  48:         
  49:         # Create custom title bar
  50:         self.create_title_bar(title)
  51:         
  52:         # Container for dialog content
  53:         self.dialog_content = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
  54:         self.dialog_content.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
  55:         
  56:         # Button frame at bottom
  57:         self.button_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN, height=50)
  58:         self.button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=10)
  59:         self.button_frame.pack_propagate(False)
  60:         
  61:         # Make modal and ensure it stays on top
  62:         self.grab_set()
  63:         self.focus_force()
  64:         
  65:         # Schedule periodic topmost updates to ensure dialog stays visible
  66:         self.after(100, self._maintain_topmost)
  67:         
  68:         # Pause parent's topmost maintenance if it exists
  69:         if hasattr(parent, 'pause_topmost_maintenance'):
  70:             parent.pause_topmost_maintenance()
  71:         
  72:         # Resume parent's topmost when this dialog is destroyed
  73:         self.protocol("WM_DELETE_WINDOW", self._on_closing)
  74:     
  75:     def create_title_bar(self, title):
  76:         """Create custom title bar with drag functionality"""
  77:         self.title_frame = tk.Frame(self.content_frame, bg=Colors.DARK_GREEN, height=25)
  78:         self.title_frame.pack(fill=tk.X)
  79:         self.title_frame.pack_propagate(False)
  80:         
  81:         # Drag handle (left side)
  82:         drag_handle = tk.Label(self.title_frame, text="⋮⋮⋮", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
  83:                              font=('Arial', 8), cursor='fleur')
  84:         drag_handle.pack(side=tk.LEFT, padx=3, pady=3)
  85:         
  86:         # Title label
  87:         title_label = tk.Label(self.title_frame, text=f"📋 {title}", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
  88:                               font=Fonts.DIALOG_TITLE, cursor='fleur')
  89:         title_label.pack(side=tk.LEFT, padx=5, pady=3)
  90:         
  91:         # Close button
  92:         close_btn = tk.Label(self.title_frame, text="×", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
  93:                            font=('Arial', 12, 'bold'), cursor='hand2')
  94:         close_btn.pack(side=tk.RIGHT, padx=5)
  95:         close_btn.bind("<Button-1>", lambda e: self.cancel())
  96:         
  97:         # Bind drag events to title bar elements
  98:         for widget in [self.title_frame, drag_handle, title_label]:
  99:             widget.bind("<Button-1>", self.start_drag)
 100:             widget.bind("<B1-Motion>", self.do_drag)
 101:             widget.bind("<ButtonRelease-1>", self.end_drag)
 102:             widget.bind("<Enter>", lambda e: self.configure(cursor='fleur'))
 103:             widget.bind("<Leave>", lambda e: self.configure(cursor=''))
 104:         
 105:         return self.title_frame
 106:     
 107:     def add_button(self, text, command, style='primary'):
 108:         """Add a button to the button frame"""
 109:         if style == 'primary':
 110:             bg_color = Colors.DARK_GREEN
 111:         elif style == 'secondary':
 112:             bg_color = Colors.MEDIUM_GREEN
 113:         else:
 114:             bg_color = Colors.INACTIVE_GRAY
 115:         
 116:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 117:         button_container.pack(expand=True)
 118:         
 119:         btn = tk.Button(button_container, text=text, bg=bg_color, fg=Colors.WHITE,
 120:                        command=command, width=Dimensions.DIALOG_BUTTON_WIDTH, 
 121:                        font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 122:         btn.pack(side=tk.LEFT, padx=5)
 123:         
 124:         return btn
 125:     
 126:     def cancel(self):
 127:         """Cancel the dialog"""
 128:         self.result = None
 129:         self.destroy()
 130:     
 131:     def ok(self):
 132:         """OK button handler - override in subclasses"""
 133:         self.result = True
 134:         self.destroy()
 135:     
 136:     def start_drag(self, event):
 137:         """Start dragging the dialog"""
 138:         self.is_dragging = True
 139:         self.drag_start_x = event.x_root
 140:         self.drag_start_y = event.y_root
 141:         
 142:         # Visual feedback
 143:         self.title_frame.configure(bg=Colors.HOVER_GREEN)
 144:         self.configure(cursor='fleur')
 145:     
 146:     def do_drag(self, event):
 147:         """Handle drag motion"""
 148:         if not self.is_dragging:
 149:             return
 150:         
 151:         # Calculate the distance moved
 152:         delta_x = event.x_root - self.drag_start_x
 153:         delta_y = event.y_root - self.drag_start_y
 154:         
 155:         # Get current position
 156:         current_x = self.winfo_x()
 157:         current_y = self.winfo_y()
 158:         
 159:         # Calculate new position
 160:         new_x = current_x + delta_x
 161:         new_y = current_y + delta_y
 162:         
 163:         # Keep dialog on screen (basic bounds checking)
 164:         screen_width = self.winfo_screenwidth()
 165:         screen_height = self.winfo_screenheight()
 166:         dialog_width = self.winfo_width()
 167:         dialog_height = self.winfo_height()
 168:         
 169:         # Ensure dialog stays on screen
 170:         new_x = max(0, min(new_x, screen_width - dialog_width))
 171:         new_y = max(0, min(new_y, screen_height - dialog_height))
 172:         
 173:         # Move the dialog
 174:         self.geometry(f"+{new_x}+{new_y}")
 175:         
 176:         # Update start position for next move
 177:         self.drag_start_x = event.x_root
 178:         self.drag_start_y = event.y_root
 179:     
 180:     def end_drag(self, event):
 181:         """End dragging operation"""
 182:         self.is_dragging = False
 183:         self.configure(cursor='')
 184:         
 185:         # Remove visual feedback
 186:         self.title_frame.configure(bg=Colors.DARK_GREEN)
 187:     
 188:     def pause_topmost_maintenance(self):
 189:         """Pause the topmost maintenance for this dialog"""
 190:         self.maintain_topmost_active = False
 191:     
 192:     def resume_topmost_maintenance(self):
 193:         """Resume the topmost maintenance for this dialog"""
 194:         self.maintain_topmost_active = True
 195:     
 196:     def _maintain_topmost(self):
 197:         """Periodically ensure dialog stays on top"""
 198:         try:
 199:             if self.winfo_exists() and self.maintain_topmost_active:
 200:                 # Only maintain topmost if no combobox is active to avoid stealing focus
 201:                 focused_widget = self.focus_get()
 202:                 if not (focused_widget and isinstance(focused_widget, ttk.Combobox)):
 203:                     # Check if any combobox in the dialog has focus or is showing dropdown
 204:                     combobox_active = self._has_active_combobox()
 205:                     if not combobox_active:
 206:                         self.lift()
 207:                         self.attributes('-topmost', True)
 208:                 self.after(500, self._maintain_topmost)  # Check every 500ms
 209:             elif self.winfo_exists():
 210:                 # Still schedule next check even if paused
 211:                 self.after(500, self._maintain_topmost)
 212:         except:
 213:             pass  # Dialog has been destroyed
 214:     
 215:     def _has_active_combobox(self):
 216:         """Check if any combobox in the dialog is currently active (dropdown showing)"""
 217:         try:
 218:             # Recursively check all widgets to find active comboboxes
 219:             return self._check_widget_for_active_combobox(self)
 220:         except:
 221:             return False
 222:     
 223:     def _check_widget_for_active_combobox(self, widget):
 224:         """Recursively check widget and its children for active comboboxes"""
 225:         try:
 226:             # Check if current widget is an active combobox
 227:             if isinstance(widget, ttk.Combobox):
 228:                 # Check if combobox has focus or its dropdown is showing
 229:                 if widget.focus_get() == widget:
 230:                     return True
 231:                 # Additional check: see if the combobox state indicates dropdown is open
 232:                 try:
 233:                     if 'pressed' in str(widget.state()) or 'active' in str(widget.state()):
 234:                         return True
 235:                 except:
 236:                     pass
 237:             
 238:             # Check all child widgets
 239:             for child in widget.winfo_children():
 240:                 if self._check_widget_for_active_combobox(child):
 241:                     return True
 242:             
 243:             return False
 244:         except:
 245:             return False
 246:     
 247:     def _on_closing(self):
 248:         """Handle dialog closing"""
 249:         # Resume parent's topmost maintenance
 250:         if hasattr(self.parent, 'resume_topmost_maintenance'):
 251:             self.parent.resume_topmost_maintenance()
 252:         self.destroy()
 253:     
 254:     def destroy(self):
 255:         """Override destroy to clean up properly"""
 256:         # Resume parent's topmost maintenance
 257:         if hasattr(self.parent, 'resume_topmost_maintenance'):
 258:             self.parent.resume_topmost_maintenance()
 259:         super().destroy()
 260: 
 261: class ConfirmationDialog(CustomDialog):
 262:     """Confirmation dialog with Yes/No buttons"""
 263:     
 264:     def __init__(self, parent, title, message, icon="⚠️"):
 265:         super().__init__(parent, title, width=350, height=200)
 266:         
 267:         # Icon and message
 268:         icon_label = tk.Label(self.dialog_content, text=icon, bg=Colors.LIGHT_GREEN,
 269:                              fg=Colors.BLACK, font=Fonts.WARNING_ICON)
 270:         icon_label.pack(pady=10)
 271:         
 272:         message_label = tk.Label(self.dialog_content, text=message, bg=Colors.LIGHT_GREEN,
 273:                                fg=Colors.BLACK, font=Fonts.DIALOG_LABEL, wraplength=300)
 274:         message_label.pack(pady=5)
 275:         
 276:         # Buttons
 277:         self.add_buttons()
 278:         
 279:         # Bind keys
 280:         self.bind('<Return>', lambda e: self.yes())
 281:         self.bind('<Escape>', lambda e: self.no())
 282:     
 283:     def add_buttons(self):
 284:         """Add Yes/No buttons"""
 285:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 286:         button_container.pack(expand=True)
 287:         
 288:         yes_btn = tk.Button(button_container, text="Yes", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 289:                            command=self.yes, width=Dimensions.DIALOG_BUTTON_WIDTH,
 290:                            font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 291:         yes_btn.pack(side=tk.LEFT, padx=10)
 292:         
 293:         no_btn = tk.Button(button_container, text="No", bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 294:                           command=self.no, width=Dimensions.DIALOG_BUTTON_WIDTH,
 295:                           font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 296:         no_btn.pack(side=tk.LEFT, padx=10)
 297:         
 298:         # Focus on No button (safer default)
 299:         no_btn.focus_set()
 300:     
 301:     def yes(self):
 302:         """Yes button clicked"""
 303:         self.result = True
 304:         self.destroy()
 305:     
 306:     def no(self):
 307:         """No button clicked"""
 308:         self.result = False
 309:         self.destroy()
 310:     
 311:     @classmethod
 312:     def ask(cls, parent, title, message, icon="⚠️"):
 313:         """Show confirmation dialog and return result"""
 314:         dialog = cls(parent, title, message, icon)
 315:         dialog.lift()
 316:         dialog.focus_force()
 317:         parent.wait_window(dialog)
 318:         return dialog.result
 319: 
 320: class WarningDialog(CustomDialog):
 321:     """Warning dialog with OK button"""
 322:     
 323:     def __init__(self, parent, title, message, icon="⚠️"):
 324:         super().__init__(parent, title, width=380, height=220)
 325:         
 326:         # Icon and message
 327:         icon_label = tk.Label(self.dialog_content, text=icon, bg=Colors.LIGHT_GREEN,
 328:                              fg=Colors.BLACK, font=('Arial', 24))
 329:         icon_label.pack(pady=10)
 330:         
 331:         message_label = tk.Label(self.dialog_content, text=message, bg=Colors.LIGHT_GREEN,
 332:                                fg=Colors.BLACK, font=Fonts.DIALOG_LABEL, wraplength=320)
 333:         message_label.pack(pady=5)
 334:         
 335:         # Buttons
 336:         self.add_buttons()
 337:         
 338:         # Bind keys
 339:         self.bind('<Return>', lambda e: self.ok())
 340:         self.bind('<Escape>', lambda e: self.ok())
 341:     
 342:     def add_buttons(self):
 343:         """Add OK button"""
 344:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 345:         button_container.pack(expand=True)
 346:         
 347:         ok_btn = tk.Button(button_container, text="OK", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 348:                           command=self.ok, width=Dimensions.DIALOG_BUTTON_WIDTH,
 349:                           font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 350:         ok_btn.pack(padx=10)
 351:         ok_btn.focus_set()
 352:     
 353:     @classmethod
 354:     def show(cls, parent, title, message, icon="⚠️"):
 355:         """Show warning dialog"""
 356:         dialog = cls(parent, title, message, icon)
 357:         dialog.lift()
 358:         dialog.focus_force()
 359:         dialog.attributes('-topmost', True)
 360:         parent.wait_window(dialog)
 361:         return dialog.result
 362: 
 363: class ErrorDialog(CustomDialog):
 364:     """Error dialog with OK button"""
 365:     
 366:     def __init__(self, parent, title, message, icon="❌"):
 367:         super().__init__(parent, title, width=400, height=240)
 368:         
 369:         # Icon and message
 370:         icon_label = tk.Label(self.dialog_content, text=icon, bg=Colors.LIGHT_GREEN,
 371:                              fg=Colors.BLACK, font=('Arial', 24))
 372:         icon_label.pack(pady=10)
 373:         
 374:         message_label = tk.Label(self.dialog_content, text=message, bg=Colors.LIGHT_GREEN,
 375:                                fg=Colors.BLACK, font=Fonts.DIALOG_LABEL, wraplength=340)
 376:         message_label.pack(pady=5)
 377:         
 378:         # Buttons
 379:         self.add_buttons()
 380:         
 381:         # Bind keys
 382:         self.bind('<Return>', lambda e: self.ok())
 383:         self.bind('<Escape>', lambda e: self.ok())
 384:     
 385:     def add_buttons(self):
 386:         """Add OK button"""
 387:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 388:         button_container.pack(expand=True)
 389:         
 390:         ok_btn = tk.Button(button_container, text="OK", bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 391:                           command=self.ok, width=Dimensions.DIALOG_BUTTON_WIDTH,
 392:                           font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 393:         ok_btn.pack(padx=10)
 394:         ok_btn.focus_set()
 395:     
 396:     @classmethod
 397:     def show(cls, parent, title, message, icon="❌"):
 398:         """Show error dialog"""
 399:         dialog = cls(parent, title, message, icon)
 400:         dialog.lift()
 401:         dialog.focus_force()
 402:         dialog.attributes('-topmost', True)
 403:         parent.wait_window(dialog)
 404:         return dialog.result
 405: 
 406: # Updated FormField class (add this to ui_components.py)
 407: 
 408: class FormField:
 409:     """Helper class for creating form fields with clipboard support"""
 410:     
 411:     def __init__(self, parent, label_text, field_type='entry', layout='side-by-side', **kwargs):
 412:         self.frame = tk.Frame(parent, bg=Colors.LIGHT_GREEN)
 413:         self.layout = layout
 414:         
 415:         if layout == 'stacked':
 416:             # Label on top, widget below
 417:             self.label = tk.Label(self.frame, text=label_text, bg=Colors.LIGHT_GREEN, 
 418:                                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL)
 419:             self.label.pack(anchor='w', pady=(0, 2))
 420:             
 421:             if field_type == 'entry':
 422:                 self.widget = tk.Entry(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 423:                 self._bind_clipboard_operations()
 424:             elif field_type == 'combobox':
 425:                 self.widget = ttk.Combobox(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 426:                 self._bind_combobox_clipboard_operations()
 427:             elif field_type == 'text':
 428:                 self.widget = tk.Text(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 429:                 self._bind_text_clipboard_operations()
 430:             
 431:             self.widget.pack(fill=tk.X, expand=True)
 432:             
 433:         else:
 434:             # Original side-by-side layout
 435:             self.label = tk.Label(self.frame, text=label_text, bg=Colors.LIGHT_GREEN, 
 436:                                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL)
 437:             self.label.grid(row=0, column=0, padx=5, pady=5, sticky='w')
 438:         
 439:             if field_type == 'entry':
 440:                 self.widget = tk.Entry(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 441:                 self._bind_clipboard_operations()
 442:             elif field_type == 'combobox':
 443:                 self.widget = ttk.Combobox(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 444:                 self._bind_combobox_clipboard_operations()
 445:             elif field_type == 'text':
 446:                 self.widget = tk.Text(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 447:                 self._bind_text_clipboard_operations()
 448:             
 449:             self.widget.grid(row=0, column=1, padx=5, pady=5, sticky='ew')
 450:             self.frame.grid_columnconfigure(1, weight=1)
 451:     
 452:     def _bind_clipboard_operations(self):
 453:         """Bind standard clipboard operations to Entry widget"""
 454:         # Standard Windows/cross-platform shortcuts
 455:         self.widget.bind('<Control-c>', self._copy)
 456:         self.widget.bind('<Control-x>', self._cut)
 457:         self.widget.bind('<Control-v>', self._paste)
 458:         self.widget.bind('<Control-a>', self._select_all)
 459:         
 460:         # Right-click context menu
 461:         self.widget.bind('<Button-3>', self._show_context_menu)
 462:     
 463:     def _bind_combobox_clipboard_operations(self):
 464:         """Bind clipboard operations to Combobox widget"""
 465:         # Comboboxes need special handling since they have different methods
 466:         self.widget.bind('<Control-c>', self._copy_combobox)
 467:         self.widget.bind('<Control-x>', self._cut_combobox)
 468:         self.widget.bind('<Control-v>', self._paste_combobox)
 469:         self.widget.bind('<Control-a>', self._select_all_combobox)
 470:         
 471:         # Right-click context menu
 472:         self.widget.bind('<Button-3>', self._show_combobox_context_menu)
 473:     
 474:     def _bind_text_clipboard_operations(self):
 475:         """Enhance Text widget clipboard operations"""
 476:         # Text widgets already have built-in clipboard support, but we can add context menu
 477:         self.widget.bind('<Button-3>', self._show_text_context_menu)
 478:     
 479:     def _copy(self, event=None):
 480:         """Copy selected text to clipboard"""
 481:         try:
 482:             if self.widget.selection_present():
 483:                 self.widget.clipboard_clear()
 484:                 self.widget.clipboard_append(self.widget.selection_get())
 485:         except tk.TclError:
 486:             pass  # No selection
 487:         return 'break'
 488:     
 489:     def _cut(self, event=None):
 490:         """Cut selected text to clipboard"""
 491:         try:
 492:             if self.widget.selection_present():
 493:                 self.widget.clipboard_clear()
 494:                 self.widget.clipboard_append(self.widget.selection_get())
 495:                 self.widget.delete(tk.SEL_FIRST, tk.SEL_LAST)
 496:         except tk.TclError:
 497:             pass  # No selection
 498:         return 'break'
 499:     
 500:     def _paste(self, event=None):
 501:         """Paste from clipboard"""
 502:         try:
 503:             clipboard_text = self.widget.clipboard_get()
 504:             if self.widget.selection_present():
 505:                 self.widget.delete(tk.SEL_FIRST, tk.SEL_LAST)
 506:             self.widget.insert(tk.INSERT, clipboard_text)
 507:         except tk.TclError:
 508:             pass  # No clipboard content
 509:         return 'break'
 510:     
 511:     def _select_all(self, event=None):
 512:         """Select all text"""
 513:         self.widget.select_range(0, tk.END)
 514:         self.widget.icursor(tk.END)
 515:         return 'break'
 516:     
 517:     def _copy_combobox(self, event=None):
 518:         """Copy from combobox"""
 519:         try:
 520:             if self.widget.selection_present():
 521:                 self.widget.clipboard_clear()
 522:                 self.widget.clipboard_append(self.widget.selection_get())
 523:         except (tk.TclError, AttributeError):
 524:             # Fallback: copy entire value if no selection
 525:             try:
 526:                 self.widget.clipboard_clear()
 527:                 self.widget.clipboard_append(self.widget.get())
 528:             except:
 529:                 pass
 530:         return 'break'
 531:     
 532:     def _cut_combobox(self, event=None):
 533:         """Cut from combobox"""
 534:         try:
 535:             if self.widget.selection_present():
 536:                 self.widget.clipboard_clear()
 537:                 self.widget.clipboard_append(self.widget.selection_get())
 538:                 # For combobox, we can delete selected text
 539:                 start = self.widget.index(tk.SEL_FIRST)
 540:                 end = self.widget.index(tk.SEL_LAST)
 541:                 current_value = self.widget.get()
 542:                 new_value = current_value[:start] + current_value[end:]
 543:                 self.widget.set(new_value)
 544:         except (tk.TclError, AttributeError):
 545:             pass
 546:         return 'break'
 547:     
 548:     def _paste_combobox(self, event=None):
 549:         """Paste to combobox"""
 550:         try:
 551:             clipboard_text = self.widget.clipboard_get()
 552:             if self.widget.selection_present():
 553:                 # Replace selection
 554:                 start = self.widget.index(tk.SEL_FIRST)
 555:                 end = self.widget.index(tk.SEL_LAST)
 556:                 current_value = self.widget.get()
 557:                 new_value = current_value[:start] + clipboard_text + current_value[end:]
 558:                 self.widget.set(new_value)
 559:             else:
 560:                 # Insert at cursor position
 561:                 cursor_pos = self.widget.index(tk.INSERT)
 562:                 current_value = self.widget.get()
 563:                 new_value = current_value[:cursor_pos] + clipboard_text + current_value[cursor_pos:]
 564:                 self.widget.set(new_value)
 565:         except tk.TclError:
 566:             pass
 567:         return 'break'
 568:     
 569:     def _select_all_combobox(self, event=None):
 570:         """Select all text in combobox"""
 571:         try:
 572:             self.widget.selection_range(0, tk.END)
 573:             self.widget.icursor(tk.END)
 574:         except (tk.TclError, AttributeError):
 575:             pass
 576:         return 'break'
 577:     
 578:     def _show_context_menu(self, event):
 579:         """Show right-click context menu for Entry"""
 580:         context_menu = tk.Menu(self.widget, tearoff=0)
 581:         
 582:         # Check if there's a selection
 583:         has_selection = False
 584:         try:
 585:             has_selection = self.widget.selection_present()
 586:         except:
 587:             pass
 588:         
 589:         # Check if clipboard has content
 590:         has_clipboard = False
 591:         try:
 592:             self.widget.clipboard_get()
 593:             has_clipboard = True
 594:         except:
 595:             pass
 596:         
 597:         context_menu.add_command(label="Cut", command=self._cut, 
 598:                                state=tk.NORMAL if has_selection else tk.DISABLED)
 599:         context_menu.add_command(label="Copy", command=self._copy,
 600:                                state=tk.NORMAL if has_selection else tk.DISABLED)
 601:         context_menu.add_command(label="Paste", command=self._paste,
 602:                                state=tk.NORMAL if has_clipboard else tk.DISABLED)
 603:         context_menu.add_separator()
 604:         context_menu.add_command(label="Select All", command=self._select_all)
 605:         
 606:         try:
 607:             context_menu.tk_popup(event.x_root, event.y_root)
 608:         finally:
 609:             context_menu.grab_release()
 610:     
 611:     def _show_combobox_context_menu(self, event):
 612:         """Show right-click context menu for Combobox"""
 613:         context_menu = tk.Menu(self.widget, tearoff=0)
 614:         
 615:         # Check if there's a selection
 616:         has_selection = False
 617:         try:
 618:             has_selection = self.widget.selection_present()
 619:         except:
 620:             pass
 621:         
 622:         # Check if clipboard has content
 623:         has_clipboard = False
 624:         try:
 625:             self.widget.clipboard_get()
 626:             has_clipboard = True
 627:         except:
 628:             pass
 629:         
 630:         context_menu.add_command(label="Cut", command=self._cut_combobox,
 631:                                state=tk.NORMAL if has_selection else tk.DISABLED)
 632:         context_menu.add_command(label="Copy", command=self._copy_combobox,
 633:                                state=tk.NORMAL if (has_selection or self.widget.get()) else tk.DISABLED)
 634:         context_menu.add_command(label="Paste", command=self._paste_combobox,
 635:                                state=tk.NORMAL if has_clipboard else tk.DISABLED)
 636:         context_menu.add_separator()
 637:         context_menu.add_command(label="Select All", command=self._select_all_combobox,
 638:                                state=tk.NORMAL if self.widget.get() else tk.DISABLED)
 639:         
 640:         try:
 641:             context_menu.tk_popup(event.x_root, event.y_root)
 642:         finally:
 643:             context_menu.grab_release()
 644:     
 645:     def _show_text_context_menu(self, event):
 646:         """Show right-click context menu for Text widget"""
 647:         # Text widgets have built-in context menus in some systems,
 648:         # but we can provide a custom one for consistency
 649:         context_menu = tk.Menu(self.widget, tearoff=0)
 650:         
 651:         # Check if there's a selection
 652:         has_selection = False
 653:         try:
 654:             has_selection = bool(self.widget.tag_ranges(tk.SEL))
 655:         except:
 656:             pass
 657:         
 658:         # Check if clipboard has content
 659:         has_clipboard = False
 660:         try:
 661:             self.widget.clipboard_get()
 662:             has_clipboard = True
 663:         except:
 664:             pass
 665:         
 666:         context_menu.add_command(label="Cut", command=lambda: self.widget.event_generate("<<Cut>>"),
 667:                                state=tk.NORMAL if has_selection else tk.DISABLED)
 668:         context_menu.add_command(label="Copy", command=lambda: self.widget.event_generate("<<Copy>>"),
 669:                                state=tk.NORMAL if has_selection else tk.DISABLED)
 670:         context_menu.add_command(label="Paste", command=lambda: self.widget.event_generate("<<Paste>>"),
 671:                                state=tk.NORMAL if has_clipboard else tk.DISABLED)
 672:         context_menu.add_separator()
 673:         context_menu.add_command(label="Select All", command=lambda: self.widget.tag_add(tk.SEL, "1.0", tk.END))
 674:         
 675:         try:
 676:             context_menu.tk_popup(event.x_root, event.y_root)
 677:         finally:
 678:             context_menu.grab_release()
 679:     
 680:     def pack(self, **kwargs):
 681:         self.frame.pack(**kwargs)
 682:         return self
 683:     
 684:     def grid(self, **kwargs):
 685:         self.frame.grid(**kwargs)
 686:         return self
 687:     
 688:     def get(self):
 689:         if hasattr(self.widget, 'get'):
 690:             return self.widget.get()
 691:         return ""
 692:     
 693:     def set(self, value):
 694:         if hasattr(self.widget, 'delete') and hasattr(self.widget, 'insert'):
 695:             self.widget.delete(0, tk.END)
 696:             self.widget.insert(0, value)
 697:         elif hasattr(self.widget, 'set'):
 698:             self.widget.set(value)
 699: 
 700: class StyledButton(tk.Button):
 701:     """Custom styled button"""
 702:     
 703:     def __init__(self, parent, text, style='primary', **kwargs):
 704:         # Set default styling based on style type
 705:         if style == 'primary':
 706:             bg_color = Colors.DARK_GREEN
 707:             fg_color = Colors.WHITE
 708:         elif style == 'secondary':
 709:             bg_color = Colors.MEDIUM_GREEN
 710:             fg_color = Colors.BLACK
 711:         elif style == 'success':
 712:             bg_color = Colors.LIGHT_GREEN
 713:             fg_color = Colors.BLACK
 714:         else:  # 'danger' or other
 715:             bg_color = Colors.INACTIVE_GRAY
 716:             fg_color = Colors.WHITE
 717:         
 718:         defaults = {
 719:             'bg': bg_color,
 720:             'fg': fg_color,
 721:             'font': Fonts.DIALOG_BUTTON,
 722:             'relief': tk.RAISED,
 723:             'bd': 1,
 724:             'cursor': 'hand2',
 725:             'activebackground': Colors.HOVER_GREEN,
 726:             'activeforeground': Colors.WHITE
 727:         }
 728:         
 729:         # Override defaults with provided kwargs
 730:         defaults.update(kwargs)
 731:         
 732:         super().__init__(parent, text=text, **defaults)
 733: 
 734: class CategoryHeader(tk.Frame):
 735:     """Styled category header for lists"""
 736:     
 737:     def __init__(self, parent, title, **kwargs):
 738:         super().__init__(parent, bg=Colors.MEDIUM_GREEN, relief=tk.RAISED, bd=1, **kwargs)
 739:         
 740:         self.title_label = tk.Label(self, text=title, bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 741:                                    font=Fonts.MENU_HEADER, height=1)
 742:         self.title_label.pack(pady=1)
 743:     
 744:     def set_title(self, title):
 745:         self.title_label.config(text=title)

────────────────────────────────────────────────────────────────────────────────
FILE: utils.py
────────────────────────────────────────────────────────────────────────────────
Path: utils.py
Size: 7.0 KB
Lines: 211 total, 182 non-empty
Characters: 6,974
Type: Utility functions and helper classes
────────────────────────────────────────────────────────────────────────────────

   1: # utils.py
   2: """
   3: Utility functions for SuiteView Taskbar Application
   4: Contains Windows API calls, file operations, and common helper functions
   5: """
   6: 
   7: import ctypes
   8: from ctypes import wintypes
   9: import os
  10: import webbrowser
  11: from pathlib import Path
  12: from config import WindowsAPI
  13: 
  14: class WindowsUtils:
  15:     """Windows-specific utility functions"""
  16:     
  17:     @staticmethod
  18:     def get_windows_taskbar_height():
  19:         """Get the height of Windows taskbar"""
  20:         try:
  21:             work_area = wintypes.RECT()
  22:             ctypes.windll.user32.SystemParametersInfoW(
  23:                 WindowsAPI.SPI_GETWORKAREA, 0, ctypes.byref(work_area), 0
  24:             )
  25:             screen_height = ctypes.windll.user32.GetSystemMetrics(1)  # SM_CYSCREEN
  26:             taskbar_height = screen_height - work_area.bottom
  27:             return taskbar_height if taskbar_height > 0 else 40
  28:         except:
  29:             return 40
  30:     
  31:     @staticmethod
  32:     def get_screen_dimensions():
  33:         """Get screen width and height"""
  34:         try:
  35:             width = ctypes.windll.user32.GetSystemMetrics(0)   # SM_CXSCREEN
  36:             height = ctypes.windll.user32.GetSystemMetrics(1)  # SM_CYSCREEN
  37:             return width, height
  38:         except:
  39:             # Fallback values
  40:             return 1920, 1080
  41:     
  42:     @staticmethod
  43:     def set_window_topmost(window_id):
  44:         """Force window to stay on top using Windows API"""
  45:         try:
  46:             hwnd = ctypes.windll.user32.GetParent(window_id)
  47:             ctypes.windll.user32.SetWindowPos(
  48:                 hwnd, WindowsAPI.HWND_TOPMOST, 0, 0, 0, 0, 
  49:                 WindowsAPI.SWP_NOMOVE | WindowsAPI.SWP_NOSIZE
  50:             )
  51:         except:
  52:             pass
  53:     
  54:     @staticmethod
  55:     def get_work_area():
  56:         """Get current desktop work area"""
  57:         work_area = wintypes.RECT()
  58:         try:
  59:             ctypes.windll.user32.SystemParametersInfoW(
  60:                 WindowsAPI.SPI_GETWORKAREA, 0, ctypes.byref(work_area), 0
  61:             )
  62:             return work_area
  63:         except:
  64:             return None
  65:     
  66:     @staticmethod
  67:     def set_work_area(rect):
  68:         """Set desktop work area"""
  69:         try:
  70:             ctypes.windll.user32.SystemParametersInfoW(
  71:                 WindowsAPI.SPI_SETWORKAREA, 0, ctypes.byref(rect), 0
  72:             )
  73:             return True
  74:         except:
  75:             return False
  76:     
  77:     @staticmethod
  78:     def restore_work_area(original_rect):
  79:         """Restore original work area with proper flags"""
  80:         try:
  81:             ctypes.windll.user32.SystemParametersInfoW(
  82:                 WindowsAPI.SPI_SETWORKAREA, 0, ctypes.byref(original_rect), 
  83:                 WindowsAPI.SPIF_SENDCHANGE
  84:             )
  85:             return True
  86:         except:
  87:             return False
  88: 
  89: class FileUtils:
  90:     """File and path utility functions"""
  91:     
  92:     @staticmethod
  93:     def normalize_path(path):
  94:         """
  95:         Convert any path to Windows format with backslashes
  96:         Handles forward slashes, mixed slashes, and Path objects
  97:         """
  98:         if not path:
  99:             return ""
 100:         
 101:         # Convert Path object to string first
 102:         if isinstance(path, Path):
 103:             path = str(path)
 104:         
 105:         # Convert string paths
 106:         path_str = str(path).strip()
 107:         
 108:         # Skip URLs
 109:         if path_str.startswith(('http://', 'https://', 'www.')):
 110:             return path_str
 111:         
 112:         # Convert forward slashes to backslashes and normalize
 113:         normalized = os.path.normpath(path_str.replace('/', '\\'))
 114:         
 115:         return normalized
 116:     
 117:     @staticmethod
 118:     def open_path(path, parent=None):
 119:         """Open a file, folder, or URL"""
 120:         try:
 121:             # Normalize the path first
 122:             normalized_path = FileUtils.normalize_path(path)
 123:             
 124:             if normalized_path.startswith(('http://', 'https://', 'www.')):
 125:                 webbrowser.open(normalized_path)
 126:                 return True
 127:             elif os.path.exists(normalized_path):
 128:                 os.startfile(normalized_path)
 129:                 return True
 130:             else:
 131:                 FileUtils._show_error(parent, "Error", f"Path not found: {normalized_path}")
 132:                 return False
 133:         except Exception as e:
 134:             FileUtils._show_error(parent, "Error", f"Could not open: {str(e)}")
 135:             return False
 136:     
 137:     @staticmethod
 138:     def _show_error(parent, title, message):
 139:         """Show error dialog - uses custom dialog if parent provided, fallback to messagebox"""
 140:         if parent:
 141:             try:
 142:                 # Import here to avoid circular imports
 143:                 from ui_components import ErrorDialog
 144:                 ErrorDialog.show(parent, title, message)
 145:             except ImportError:
 146:                 # Fallback to standard messagebox if ui_components not available
 147:                 from tkinter import messagebox
 148:                 messagebox.showerror(title, message)
 149:         else:
 150:             # No parent provided, use console output
 151:             print(f"{title}: {message}")
 152:     
 153:     @staticmethod
 154:     def validate_path(path):
 155:         """Validate if a path exists or is a valid URL"""
 156:         if not path or not path.strip():
 157:             return False
 158:         
 159:         path = path.strip()
 160:         
 161:         # Check if it's a URL
 162:         if path.startswith(('http://', 'https://', 'www.')):
 163:             return True
 164:         
 165:         # Check if file/folder exists
 166:         return os.path.exists(path)
 167: 
 168: class UIUtils:
 169:     """UI-related utility functions"""
 170:     
 171:     @staticmethod
 172:     def center_window(window, width, height):
 173:         """Center a window on screen"""
 174:         screen_width = window.winfo_screenwidth()
 175:         screen_height = window.winfo_screenheight()
 176:         x = (screen_width - width) // 2
 177:         y = (screen_height - height) // 2
 178:         window.geometry(f"{width}x{height}+{x}+{y}")
 179:     
 180:     @staticmethod
 181:     def apply_hover_effect(widget, normal_bg, hover_bg, normal_fg='black', hover_fg='white'):
 182:         """Apply hover effect to a widget"""
 183:         def on_enter(e):
 184:             widget.configure(bg=hover_bg, fg=hover_fg)
 185:             # Apply to children if they exist
 186:             for child in widget.winfo_children():
 187:                 try:
 188:                     child.configure(bg=hover_bg, fg=hover_fg)
 189:                 except:
 190:                     pass
 191:         
 192:         def on_leave(e):
 193:             widget.configure(bg=normal_bg, fg=normal_fg)
 194:             # Apply to children if they exist
 195:             for child in widget.winfo_children():
 196:                 try:
 197:                     child.configure(bg=normal_bg, fg=normal_fg)
 198:                 except:
 199:                     pass
 200:         
 201:         widget.bind("<Enter>", on_enter)
 202:         widget.bind("<Leave>", on_leave)
 203:         
 204:         return on_enter, on_leave
 205:     
 206:     @staticmethod
 207:     def create_separator(parent, bg_color, width=2):
 208:         """Create a vertical separator"""
 209:         import tkinter as tk
 210:         separator = tk.Frame(parent, bg=bg_color, width=width)
 211:         return separator

────────────────────────────────────────────────────────────────────────────────
FILE: window_manager.py
────────────────────────────────────────────────────────────────────────────────
Path: window_manager.py
Size: 9.4 KB
Lines: 244 total, 200 non-empty
Characters: 9,413
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # window_manager.py
   2: """
   3: Windows detection and management functionality for SuiteView Taskbar
   4: Handles window enumeration, filtering, hiding/showing, and pinning
   5: """
   6: 
   7: import win32gui
   8: import win32api
   9: import win32con
  10: import win32process
  11: import psutil
  12: from typing import List, Dict, Optional
  13: import re
  14: 
  15: class ManagedWindow:
  16:     """Represents a managed window with its state"""
  17:     
  18:     def __init__(self, hwnd: int, title: str, process_name: str):
  19:         self.hwnd = hwnd
  20:         self.title = title
  21:         self.process_name = process_name
  22:         self.app_name = self._extract_app_name()
  23:         self.display_name = self._create_display_name()
  24:         self.is_hidden = False
  25:         self.is_pinned = False
  26:         self.original_ex_style = win32gui.GetWindowLong(hwnd, win32con.GWL_EXSTYLE)
  27:     
  28:     def _extract_app_name(self) -> str:
  29:         """Extract application name from process name"""
  30:         # Remove .exe extension
  31:         app = self.process_name.replace('.exe', '')
  32:         
  33:         # Capitalize common apps
  34:         common_apps = {
  35:             'chrome': 'Chrome',
  36:             'firefox': 'Firefox',
  37:             'winword': 'Word',
  38:             'excel': 'Excel',
  39:             'powerpnt': 'PowerPoint',
  40:             'outlook': 'Outlook',
  41:             'notepad': 'Notepad',
  42:             'notepad++': 'Notepad++',
  43:             'code': 'VS Code',
  44:             'devenv': 'Visual Studio',
  45:             'acrobat': 'Acrobat',
  46:             'acrord32': 'Acrobat Reader'
  47:         }
  48:         
  49:         return common_apps.get(app.lower(), app.title())
  50:     
  51:     def _create_display_name(self) -> str:
  52:         """Create display name in format 'AppName - WindowTitle'"""
  53:         if self.title.startswith(self.app_name):
  54:             # Avoid duplication if app name is already in title
  55:             return self.title
  56:         return f"{self.app_name} - {self.title}"
  57:     
  58:     def hide(self) -> bool:
  59:         """Hide the window (remove from Alt+Tab and taskbar)"""
  60:         try:
  61:             # Get current extended style
  62:             ex_style = win32gui.GetWindowLong(self.hwnd, win32con.GWL_EXSTYLE)
  63:             
  64:             # Add WS_EX_TOOLWINDOW to hide from Alt+Tab and taskbar
  65:             new_ex_style = ex_style | win32con.WS_EX_TOOLWINDOW
  66:             
  67:             # Remove WS_EX_APPWINDOW to ensure it's hidden from taskbar
  68:             new_ex_style = new_ex_style & ~win32con.WS_EX_APPWINDOW
  69:             
  70:             # Apply new style
  71:             win32gui.SetWindowLong(self.hwnd, win32con.GWL_EXSTYLE, new_ex_style)
  72:             
  73:             # Hide the window
  74:             win32gui.ShowWindow(self.hwnd, win32con.SW_HIDE)
  75:             
  76:             self.is_hidden = True
  77:             return True
  78:         except Exception as e:
  79:             print(f"Error hiding window {self.display_name}: {e}")
  80:             return False
  81:     
  82:     def show(self) -> bool:
  83:         """Show the window (restore to Alt+Tab and taskbar)"""
  84:         try:
  85:             # Restore original extended style
  86:             win32gui.SetWindowLong(self.hwnd, win32con.GWL_EXSTYLE, self.original_ex_style)
  87:             
  88:             # Show the window
  89:             win32gui.ShowWindow(self.hwnd, win32con.SW_SHOW)
  90:             
  91:             self.is_hidden = False
  92:             return True
  93:         except Exception as e:
  94:             print(f"Error showing window {self.display_name}: {e}")
  95:             return False
  96:     
  97:     def bring_to_front(self) -> bool:
  98:         """Bring window to front and give it focus without changing size"""
  99:         try:
 100:             if self.is_hidden:
 101:                 self.show()
 102:             
 103:             # Bring to front without changing window state (no resizing)
 104:             win32gui.SetForegroundWindow(self.hwnd)
 105:             # Only show if it's actually hidden, don't restore from minimized/maximized
 106:             if not win32gui.IsWindowVisible(self.hwnd):
 107:                 win32gui.ShowWindow(self.hwnd, win32con.SW_SHOW)
 108:             return True
 109:         except Exception as e:
 110:             print(f"Error bringing window to front {self.display_name}: {e}")
 111:             return False
 112:     
 113:     def is_valid(self) -> bool:
 114:         """Check if window still exists"""
 115:         return win32gui.IsWindow(self.hwnd)
 116: 
 117: class WindowManager:
 118:     """Manages window detection, filtering, and state"""
 119:     
 120:     def __init__(self):
 121:         self.managed_windows: Dict[int, ManagedWindow] = {}
 122:         self.excluded_processes = {
 123:             'explorer.exe', 'searchui.exe', 'shellexperiencehost.exe',
 124:             'applicationframehost.exe', 'systemsettings.exe', 'textinputhost.exe',
 125:             'lockapp.exe', 'searchapp.exe', 'startmenuexperiencehost.exe',
 126:             'runtimebroker.exe', 'svchost.exe', 'system', 'registry',
 127:             'smss.exe', 'csrss.exe', 'wininit.exe', 'services.exe',
 128:             'lsass.exe', 'winlogon.exe', 'dwm.exe', 'taskhostw.exe',
 129:             'searchindexer.exe', 'backgroundtaskhost.exe'
 130:         }
 131:     
 132:     def get_relevant_windows(self) -> List[ManagedWindow]:
 133:         """Get all relevant open windows on current desktop"""
 134:         windows = []
 135:         
 136:         def enum_callback(hwnd, _):
 137:             if self._is_relevant_window(hwnd):
 138:                 try:
 139:                     title = win32gui.GetWindowText(hwnd)
 140:                     if title:  # Skip windows with no title
 141:                         _, pid = win32process.GetWindowThreadProcessId(hwnd)
 142:                         process = psutil.Process(pid)
 143:                         process_name = process.name()
 144:                         
 145:                         # Check if we already manage this window
 146:                         if hwnd in self.managed_windows:
 147:                             window = self.managed_windows[hwnd]
 148:                             # Update title in case it changed
 149:                             window.title = title
 150:                             window.display_name = window._create_display_name()
 151:                         else:
 152:                             window = ManagedWindow(hwnd, title, process_name)
 153:                             self.managed_windows[hwnd] = window
 154:                         
 155:                         windows.append(window)
 156:                 except Exception as e:
 157:                     print(f"Error processing window {hwnd}: {e}")
 158:             return True
 159:         
 160:         win32gui.EnumWindows(enum_callback, None)
 161:         
 162:         # Clean up managed windows that no longer exist
 163:         self._cleanup_invalid_windows()
 164:         
 165:         return sorted(windows, key=lambda w: w.display_name.lower())
 166:     
 167:     def _is_relevant_window(self, hwnd: int) -> bool:
 168:         """Check if window is relevant (user-facing, not system)"""
 169:         try:
 170:             # Window must be visible
 171:             if not win32gui.IsWindowVisible(hwnd):
 172:                 return False
 173:             
 174:             # Get window info
 175:             _, pid = win32process.GetWindowThreadProcessId(hwnd)
 176:             process = psutil.Process(pid)
 177:             process_name = process.name().lower()
 178:             
 179:             # Exclude system processes
 180:             if process_name in self.excluded_processes:
 181:                 return False
 182:             
 183:             # Get window style
 184:             style = win32gui.GetWindowLong(hwnd, win32con.GWL_STYLE)
 185:             ex_style = win32gui.GetWindowLong(hwnd, win32con.GWL_EXSTYLE)
 186:             
 187:             # Must be a normal window (not a tool window, unless we made it one)
 188:             if hwnd not in self.managed_windows:
 189:                 if ex_style & win32con.WS_EX_TOOLWINDOW:
 190:                     return False
 191:             
 192:             # Should have a title bar or be a notable window
 193:             if not (style & win32con.WS_CAPTION):
 194:                 # Some apps like Chrome have windows without WS_CAPTION
 195:                 # Check if it's a main window by other criteria
 196:                 if not (ex_style & win32con.WS_EX_APPWINDOW):
 197:                     return False
 198:             
 199:             # Check if it's a main window (not a dialog or popup)
 200:             owner = win32gui.GetWindow(hwnd, win32con.GW_OWNER)
 201:             if owner:
 202:                 return False
 203:             
 204:             return True
 205:             
 206:         except Exception:
 207:             return False
 208:     
 209:     def _cleanup_invalid_windows(self):
 210:         """Remove windows that no longer exist from managed windows"""
 211:         invalid_hwnds = []
 212:         for hwnd, window in self.managed_windows.items():
 213:             if not window.is_valid():
 214:                 invalid_hwnds.append(hwnd)
 215:         
 216:         for hwnd in invalid_hwnds:
 217:             del self.managed_windows[hwnd]
 218:     
 219:     def toggle_window_visibility(self, window: ManagedWindow) -> bool:
 220:         """Toggle window visibility"""
 221:         if window.is_hidden:
 222:             return window.show()
 223:         else:
 224:             return window.hide()
 225:     
 226:     def pin_window(self, window: ManagedWindow):
 227:         """Mark window as pinned"""
 228:         window.is_pinned = True
 229:     
 230:     def unpin_window(self, window: ManagedWindow):
 231:         """Unpin window and ensure it's visible"""
 232:         window.is_pinned = False
 233:         if window.is_hidden:
 234:             window.show()
 235:     
 236:     def unhide_all_windows(self):
 237:         """Unhide all hidden windows (for app cleanup)"""
 238:         for window in self.managed_windows.values():
 239:             if window.is_hidden:
 240:                 window.show()
 241:     
 242:     def get_pinned_windows(self) -> List[ManagedWindow]:
 243:         """Get all currently pinned windows"""
 244:         return [w for w in self.managed_windows.values() if w.is_pinned]

────────────────────────────────────────────────────────────────────────────────
FILE: windows_menu.py
────────────────────────────────────────────────────────────────────────────────
Path: windows_menu.py
Size: 16.2 KB
Lines: 402 total, 323 non-empty
Characters: 16,175
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # windows_menu.py (modified)
   2: """
   3: Windows menu UI for SuiteView Taskbar
   4: Shows list of open windows with hide/pin functionality
   5: Now excludes pinned windows from the list
   6: """
   7: 
   8: import tkinter as tk
   9: from config import Colors, Fonts, Dimensions
  10: from window_manager import WindowManager, ManagedWindow
  11: from typing import Callable, Optional
  12: 
  13: class WindowsMenu(tk.Toplevel):
  14:     """Windows management menu"""
  15:     
  16:     def __init__(self, parent, window_manager: WindowManager, on_pin_callback: Callable, 
  17:                  stored_geometry: Optional[str] = None):
  18:         super().__init__(parent)
  19:         self.parent = parent
  20:         self.window_manager = window_manager
  21:         self.on_pin_callback = on_pin_callback
  22:         self.stored_geometry = stored_geometry
  23:         
  24:         # Window setup
  25:         self.title("")  # No title for custom window
  26:         self.configure(bg=Colors.DARK_GREEN)
  27:         self.attributes('-topmost', True)
  28:         self.attributes('-alpha', 0.98)
  29:         
  30:         # Important: Make window resizable
  31:         self.resizable(True, True)
  32:         
  33:         # Remove default window decorations for custom look
  34:         self.overrideredirect(True)
  35:         
  36:         # Track window items for updates
  37:         self.window_items = {}
  38:         
  39:         # Resize variables
  40:         self.is_resizing = False
  41:         self.resize_edge = None
  42:         self.resize_start_x = 0
  43:         self.resize_start_y = 0
  44:         self.original_geometry = None
  45:         
  46:         # Main container with visible border
  47:         self.main_frame = tk.Frame(self, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=3)
  48:         self.main_frame.pack(fill=tk.BOTH, expand=True)
  49:         
  50:         # Create header
  51:         self.create_header()
  52:         
  53:         # Create scrollable content area
  54:         self.create_content_area()
  55:         
  56:         # Create resize handles
  57:         self.create_resize_handles()
  58:         
  59:         # Populate with windows
  60:         self.refresh_window_list()
  61:         
  62:         # Apply stored geometry or default size and position
  63:         if stored_geometry:
  64:             self.geometry(stored_geometry)
  65:             print(f"Applied stored geometry: {stored_geometry}")  # Debug
  66:         else:
  67:             # Set default size and position (bottom-right)
  68:             default_width = 700
  69:             default_height = 600
  70:             screen_width = self.winfo_screenwidth()
  71:             screen_height = self.winfo_screenheight() - Dimensions.TASKBAR_HEIGHT 
  72:             x = screen_width - default_width - 5  # 20px from right edge
  73:             # Position above taskbar (assuming taskbar height of 40)
  74:             y = screen_height - default_height - Dimensions.TASKBAR_HEIGHT - 10  # 5px above taskbar
  75:             
  76:             self.geometry(f"{default_width}x{default_height}+{x}+{y}")
  77:         
  78:         # Bind window close event
  79:         self.protocol("WM_DELETE_WINDOW", self.close_window)
  80:         
  81:         # Ensure window is visible
  82:         self.deiconify()
  83:         self.lift()
  84:     
  85:     def create_header(self):
  86:         """Create menu header"""
  87:         header_frame = tk.Frame(self.main_frame, bg=Colors.DARK_GREEN, height=30)
  88:         header_frame.pack(fill=tk.X, padx=1, pady=1)
  89:         header_frame.pack_propagate(False)
  90:         
  91:         # Make header draggable
  92:         header_frame.bind("<Button-1>", self.start_drag)
  93:         header_frame.bind("<B1-Motion>", self.do_drag)
  94:         
  95:         # Title
  96:         title = tk.Label(header_frame, text="🪟 Windows Manager", 
  97:                         bg=Colors.DARK_GREEN, fg=Colors.WHITE,
  98:                         font=Fonts.MENU_HEADER, cursor='fleur')
  99:         title.pack(side=tk.LEFT, padx=10, pady=5)
 100:         title.bind("<Button-1>", self.start_drag)
 101:         title.bind("<B1-Motion>", self.do_drag)
 102:         
 103:         # Refresh button
 104:         refresh_btn = tk.Button(header_frame, text="↻ Refresh", 
 105:                                bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 106:                                relief=tk.RAISED, bd=1, cursor='hand2',
 107:                                font=Fonts.MENU_ITEM, command=self.refresh_window_list)
 108:         refresh_btn.pack(side=tk.RIGHT, padx=10, pady=5)
 109:         
 110:         # Close button
 111:         close_btn = tk.Button(header_frame, text="X", 
 112:                              bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 113:                              relief=tk.RAISED, bd=1, cursor='hand2',
 114:                              font=Fonts.MENU_ITEM, width=3,
 115:                              command=self.close_window)
 116:         close_btn.pack(side=tk.RIGHT, padx=5, pady=5)
 117:     
 118:     def create_resize_handles(self):
 119:         """Create resize handles for top, left, and right edges"""
 120:         # Top resize handle
 121:         top_handle = tk.Frame(self, cursor='size_ns', height=5)
 122:         top_handle.place(relx=0.0, rely=0.0, relwidth=1.0, anchor='nw')
 123:         top_handle.configure(bg=Colors.DARK_GREEN)
 124:         
 125:         # Bind resize events for top
 126:         top_handle.bind("<Button-1>", lambda e: self.start_resize(e, 't'))
 127:         top_handle.bind("<B1-Motion>", self.do_resize)
 128:         top_handle.bind("<ButtonRelease-1>", self.end_resize)
 129:         
 130:         # Left resize handle
 131:         left_handle = tk.Frame(self, cursor='size_we', width=5)
 132:         left_handle.place(relx=0.0, rely=0.0, relheight=1.0, anchor='nw')
 133:         left_handle.configure(bg=Colors.DARK_GREEN)
 134:         
 135:         # Bind resize events for left
 136:         left_handle.bind("<Button-1>", lambda e: self.start_resize(e, 'l'))
 137:         left_handle.bind("<B1-Motion>", self.do_resize)
 138:         left_handle.bind("<ButtonRelease-1>", self.end_resize)
 139:         
 140:         # Right resize handle
 141:         right_handle = tk.Frame(self, cursor='size_we', width=5)
 142:         right_handle.place(relx=1.0, rely=0.0, relheight=1.0, anchor='ne')
 143:         right_handle.configure(bg=Colors.DARK_GREEN)
 144:         
 145:         # Bind resize events for right
 146:         right_handle.bind("<Button-1>", lambda e: self.start_resize(e, 'r'))
 147:         right_handle.bind("<B1-Motion>", self.do_resize)
 148:         right_handle.bind("<ButtonRelease-1>", self.end_resize)
 149:         
 150:         # Visual feedback on hover
 151:         top_handle.bind("<Enter>", lambda e: self.configure(cursor='size_ns'))
 152:         top_handle.bind("<Leave>", lambda e: self.configure(cursor=''))
 153:         left_handle.bind("<Enter>", lambda e: self.configure(cursor='size_we'))
 154:         left_handle.bind("<Leave>", lambda e: self.configure(cursor=''))
 155:         right_handle.bind("<Enter>", lambda e: self.configure(cursor='size_we'))
 156:         right_handle.bind("<Leave>", lambda e: self.configure(cursor=''))
 157: 
 158:     def start_drag(self, event):
 159:         """Start dragging the window"""
 160:         self.drag_start_x = event.x_root
 161:         self.drag_start_y = event.y_root
 162:         self.original_x = self.winfo_x()
 163:         self.original_y = self.winfo_y()
 164: 
 165:     def do_drag(self, event):
 166:         """Handle window dragging"""
 167:         dx = event.x_root - self.drag_start_x
 168:         dy = event.y_root - self.drag_start_y
 169:         
 170:         new_x = self.original_x + dx
 171:         new_y = self.original_y + dy
 172:         
 173:         # Keep window on screen
 174:         screen_width = self.winfo_screenwidth()
 175:         screen_height = self.winfo_screenheight()
 176:         window_width = self.winfo_width()
 177:         window_height = self.winfo_height()
 178:         
 179:         new_x = max(0, min(new_x, screen_width - window_width))
 180:         new_y = max(0, min(new_y, screen_height - window_height))
 181:         
 182:         self.geometry(f"+{int(new_x)}+{int(new_y)}")
 183:         
 184:         # Update stored geometry in parent
 185:         if hasattr(self.parent, 'windows_menu_geometry'):
 186:             self.parent.windows_menu_geometry = self.get_current_geometry()
 187:     
 188:     def start_resize(self, event, edge):
 189:         """Start resizing operation"""
 190:         self.is_resizing = True
 191:         self.resize_edge = edge
 192:         self.resize_start_x = event.x_root
 193:         self.resize_start_y = event.y_root
 194:         
 195:         # Store original geometry
 196:         self.original_geometry = {
 197:             'x': self.winfo_x(),
 198:             'y': self.winfo_y(),
 199:             'width': self.winfo_width(),
 200:             'height': self.winfo_height()
 201:         }
 202:         
 203:         # Visual feedback
 204:         self.main_frame.configure(relief=tk.SUNKEN)
 205: 
 206:     def do_resize(self, event):
 207:         """Handle resize drag for all edges"""
 208:         if not self.is_resizing or not self.resize_edge:
 209:             return
 210:         
 211:         dx = event.x_root - self.resize_start_x
 212:         dy = event.y_root - self.resize_start_y
 213:         
 214:         x = self.original_geometry['x']
 215:         y = self.original_geometry['y']
 216:         width = self.original_geometry['width']
 217:         height = self.original_geometry['height']
 218:         
 219:         min_width = 400
 220:         min_height = 300
 221:         
 222:         # Handle different edges
 223:         if self.resize_edge == 't':  # Top edge
 224:             new_height = max(min_height, height - dy)
 225:             if new_height != height:
 226:                 y = y + (height - new_height)
 227:                 height = new_height
 228:                 
 229:         elif self.resize_edge == 'l':  # Left edge
 230:             new_width = max(min_width, width - dx)
 231:             if new_width != width:
 232:                 x = x + (width - new_width)
 233:                 width = new_width
 234:                 
 235:         elif self.resize_edge == 'r':  # Right edge
 236:             new_width = max(min_width, width + dx)
 237:             width = new_width
 238:         
 239:         # Apply new geometry
 240:         self.geometry(f"{int(width)}x{int(height)}+{int(x)}+{int(y)}")
 241: 
 242:     def end_resize(self, event):
 243:         """End resizing operation"""
 244:         self.is_resizing = False
 245:         self.resize_edge = None
 246:         
 247:         # Remove visual feedback
 248:         self.main_frame.configure(relief=tk.RAISED)
 249:         
 250:         # Update stored geometry in parent
 251:         if hasattr(self.parent, 'windows_menu_geometry'):
 252:             self.parent.windows_menu_geometry = self.get_current_geometry()
 253:             print(f"Stored geometry after resize: {self.parent.windows_menu_geometry}")  # Debug
 254:     
 255:     def create_content_area(self):
 256:         """Create scrollable content area"""
 257:         # Create canvas and scrollbar for scrolling
 258:         self.canvas = tk.Canvas(self.main_frame, bg=Colors.LIGHT_GREEN, 
 259:                                highlightthickness=0)
 260:         scrollbar = tk.Scrollbar(self.main_frame, orient="vertical", 
 261:                                 command=self.canvas.yview)
 262:         self.scrollable_frame = tk.Frame(self.canvas, bg=Colors.LIGHT_GREEN)
 263:         
 264:         self.scrollable_frame.bind(
 265:             "<Configure>",
 266:             lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
 267:         )
 268:         
 269:         self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
 270:         self.canvas.configure(yscrollcommand=scrollbar.set)
 271:         
 272:         self.canvas.pack(side="left", fill="both", expand=True, padx=2, pady=2)
 273:         scrollbar.pack(side="right", fill="y")
 274:         
 275:         # Bind mouse wheel
 276:         self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
 277:     
 278:     def _on_mousewheel(self, event):
 279:         """Handle mouse wheel scrolling"""
 280:         if self.canvas.winfo_exists():
 281:             self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
 282:     
 283:     def refresh_window_list(self):
 284:         """Refresh the list of windows"""
 285:         # Clear existing items
 286:         for widget in self.scrollable_frame.winfo_children():
 287:             widget.destroy()
 288:         self.window_items.clear()
 289:         
 290:         # Get current windows and filter out pinned ones
 291:         all_windows = self.window_manager.get_relevant_windows()
 292:         windows = [w for w in all_windows if not w.is_pinned]  # Exclude pinned windows
 293:         
 294:         if not windows:
 295:             label = tk.Label(self.scrollable_frame, text="No unpinned windows found", 
 296:                            bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 297:                            font=Fonts.MENU_ITEM)
 298:             label.pack(pady=20)
 299:             return
 300:         
 301:         # Create item for each window
 302:         for window in windows:
 303:             self.create_window_item(window)
 304:     
 305:     def create_window_item(self, window: ManagedWindow):
 306:         """Create a single window item in the list"""
 307:         # Item container
 308:         item_frame = tk.Frame(self.scrollable_frame, bg=Colors.LIGHT_GREEN, 
 309:                              relief=tk.RAISED, bd=1)
 310:         item_frame.pack(fill=tk.X, padx=5, pady=2)
 311:         
 312:         # Pin button on the LEFT side
 313:         pin_btn = tk.Button(item_frame, text="Pin", 
 314:                            bg=Colors.PIN_BUTTON_COLOR, fg=Colors.BLACK,
 315:                            relief=tk.RAISED, bd=1, cursor='hand2',
 316:                            font=Fonts.MENU_ITEM, width=6,
 317:                            command=lambda: self.toggle_pin(window))
 318:         pin_btn.pack(side=tk.LEFT, padx=5, pady=2)  # Changed to LEFT
 319:         
 320:         # Window name label (clickable to toggle visibility)
 321:         label_bg = Colors.WINDOW_HIDDEN if window.is_hidden else Colors.WINDOW_VISIBLE
 322:         label_fg = Colors.WHITE if window.is_hidden else Colors.BLACK
 323:         
 324:         name_label = tk.Label(item_frame, text=window.display_name, 
 325:                              bg=label_bg, fg=label_fg,
 326:                              font=Fonts.MENU_ITEM, anchor='w',
 327:                              cursor='hand2', padx=5, pady=3)
 328:         name_label.pack(side=tk.LEFT, fill=tk.X, expand=True)  # Still LEFT but after pin button
 329:         
 330:         # Bind click to toggle visibility
 331:         name_label.bind("<Button-1>", lambda e: self.toggle_window_visibility(window))
 332:         
 333:         # Store references for updating
 334:         self.window_items[window.hwnd] = {
 335:             'frame': item_frame,
 336:             'label': name_label,
 337:             'pin_btn': pin_btn,
 338:             'window': window
 339:         }
 340:     
 341:     def toggle_window_visibility(self, window: ManagedWindow):
 342:         """Toggle window visibility and update UI"""
 343:         if self.window_manager.toggle_window_visibility(window):
 344:             self.update_window_item(window)
 345:     
 346:     def toggle_pin(self, window: ManagedWindow):
 347:         """Toggle window pin state"""
 348:         print(f"\n=== TOGGLE PIN DEBUG ===")
 349:         print(f"Window: {window.display_name}")
 350:         print(f"Was pinned: {window.is_pinned}")
 351:         
 352:         if window.is_pinned:
 353:             self.window_manager.unpin_window(window)
 354:         else:
 355:             self.window_manager.pin_window(window)
 356:         
 357:         print(f"Now pinned: {window.is_pinned}")
 358:         
 359:         # Notify callback to update taskbar
 360:         if self.on_pin_callback:
 361:             print(f"Calling on_pin_callback: {self.on_pin_callback}")
 362:             self.on_pin_callback()
 363:         else:
 364:             print("ERROR: on_pin_callback is None!")
 365:         
 366:         # Remove this window from the list since it's now pinned
 367:         if window.is_pinned:
 368:             self.refresh_window_list()
 369:         
 370:         # List all pinned windows
 371:         pinned = self.window_manager.get_pinned_windows()
 372:         print(f"Total pinned windows: {len(pinned)}")
 373:         for pw in pinned:
 374:             print(f"  - {pw.display_name}")
 375:         print("=== END DEBUG ===\n")
 376:     
 377:     def update_window_item(self, window: ManagedWindow):
 378:         """Update the UI for a specific window item"""
 379:         if window.hwnd not in self.window_items:
 380:             return
 381:         
 382:         item = self.window_items[window.hwnd]
 383:         
 384:         # Update label color based on visibility
 385:         label_bg = Colors.WINDOW_HIDDEN if window.is_hidden else Colors.WINDOW_VISIBLE
 386:         label_fg = Colors.WHITE if window.is_hidden else Colors.BLACK
 387:         item['label'].configure(bg=label_bg, fg=label_fg)
 388:     
 389:     def get_current_geometry(self):
 390:         """Get current window geometry string"""
 391:         return self.geometry()
 392:     
 393:     def close_window(self):
 394:         """Close the windows menu"""
 395:         # Store geometry in parent before closing
 396:         if hasattr(self.parent, 'windows_menu_geometry'):
 397:             self.parent.windows_menu_geometry = self.get_current_geometry()
 398:             print(f"Storing geometry on close: {self.parent.windows_menu_geometry}")  # Debug
 399:         
 400:         # Unbind mousewheel to prevent errors
 401:         self.canvas.unbind_all("<MouseWheel>")
 402:         self.destroy()

────────────────────────────────────────────────────────────────────────────────
FILE: requirements.txt
────────────────────────────────────────────────────────────────────────────────
Path: requirements.txt
Size: 42.0 B
Lines: 5 total, 5 non-empty
Characters: 38
Type: Python package dependencies
────────────────────────────────────────────────────────────────────────────────

PySide6
pywin32
Pillow
psutil
comtypes


================================================================================
                           EXPORT SUMMARY
================================================================================

Files Processed: 19
Total Size: 239.2 KB
Total Python Lines: 6,002

File Breakdown:
    README.md                  718.0 B (  31 lines)
    browse_choice_dialog.py     7.0 KB ( 187 lines)
    config.py                   2.7 KB (  86 lines)
    enhanced_folder_inventory.py  23.5 KB ( 569 lines)
    explorer_utils.py           8.9 KB ( 226 lines)
    folder_inventory.py        24.5 KB ( 593 lines)
    inventory_view_window.py   21.1 KB ( 498 lines)
    links_manager.py           11.1 KB ( 306 lines)
    main.py                     1.1 KB (  42 lines)
    pinned_windows.py           7.3 KB ( 177 lines)
    quick_links.py             36.3 KB ( 867 lines)
    restore_deskop.py           1.5 KB (  41 lines)
    snip_feature.py            16.1 KB ( 410 lines)
    taskbar.py                 16.1 KB ( 398 lines)
    ui_components.py           28.7 KB ( 745 lines)
    utils.py                    7.0 KB ( 211 lines)
    window_manager.py           9.4 KB ( 244 lines)
    windows_menu.py            16.2 KB ( 402 lines)
    requirements.txt            42.0 B (   5 lines)

================================================================================
                    END OF SUITEVIEW SOURCE CODE
================================================================================
