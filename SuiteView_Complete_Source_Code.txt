
================================================================================
                    SUITEVIEW TASKBAR APPLICATION
                         COMPLETE SOURCE CODE
================================================================================

Export Information:
    Generated on: 2025-06-28 19:53:28
    Project Directory: C:\Users\rober\Documents\Code\TaskBarApp
    Export Tool: SuiteView Code Exporter v1.0

Description:
    This file contains the complete source code for the SuiteView Taskbar 
    Application - a customizable Windows taskbar replacement with quick links
    functionality, drag-and-drop support, and modern UI components.

Project Structure:
    • Main Application Files: main.py, taskbar.py
    • UI Components: ui_components.py, quick_links.py
    • Data Management: links_manager.py, config.py
    • Utilities: utils.py, browse_choice_dialog.py, restore_deskop.py
    • Configuration: requirements.txt, README.md

================================================================================


────────────────────────────────────────────────────────────────────────────────
FILE: README.md
────────────────────────────────────────────────────────────────────────────────
Path: README.md
Size: 718.0 B
Lines: 31 total, 26 non-empty
Characters: 688
Type: Project documentation and setup instructions
────────────────────────────────────────────────────────────────────────────────

# SuiteView Taskbar App

A simple, customizable taskbar app for Windows 11, built with PySide2.

## Features
- Always-on-top, borderless taskbar bar
- Two-tone green theme
- System tray integration
- Easy to extend with new buttons and features

## Setup
1. Install Python 3.8+
2. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```
3. Run the app:
   ```bash
   python main.py
   ```

## Packaging (Optional)
To create a standalone executable, install PyInstaller:
```bash
pip install pyinstaller
pyinstaller --onefile --windowed main.py
```

## Customization
- Add new buttons and features by editing `main.py`.
- Update colors and styles in the code as desired. 

────────────────────────────────────────────────────────────────────────────────
FILE: browse_choice_dialog.py
────────────────────────────────────────────────────────────────────────────────
Path: browse_choice_dialog.py
Size: 7.0 KB
Lines: 187 total, 153 non-empty
Characters: 6,939
Type: File/folder selection dialog
────────────────────────────────────────────────────────────────────────────────

   1: # browse_choice_dialog.py
   2: """
   3: Custom dialog for choosing between file and folder browsing
   4: Replaces messagebox with properly styled, topmost dialog
   5: """
   6: 
   7: import tkinter as tk
   8: from tkinter import filedialog
   9: from config import Colors, Fonts, Dimensions
  10: from ui_components import CustomDialog
  11: 
  12: class BrowseChoiceDialog(CustomDialog):
  13:     """Custom dialog for choosing between File or Folder browsing"""
  14:     
  15:     def __init__(self, parent):
  16:         super().__init__(parent, "Browse Type", width=350, height=350)
  17:         
  18:         self.choice_result = None  # Will store 'file', 'folder', or None
  19:         self.selected_path = None  # Will store the selected path
  20:         
  21:         # Make sure dialog stays on top of everything
  22:         self.attributes('-topmost', True)
  23:         self.lift()
  24:         self.focus_force()
  25:         
  26:         self.create_content()
  27:         self.create_buttons()
  28:         
  29:         # Bind keyboard shortcuts
  30:         self.bind('<F>', lambda e: self.choose_file())
  31:         self.bind('<f>', lambda e: self.choose_file())
  32:         self.bind('<D>', lambda e: self.choose_folder())
  33:         self.bind('<d>', lambda e: self.choose_folder())
  34:         self.bind('<Escape>', lambda e: self.cancel())
  35:     
  36:     def create_content(self):
  37:         """Create the dialog content"""
  38:         # Icon
  39:         icon_label = tk.Label(self.dialog_content, text="📁", bg=Colors.LIGHT_GREEN,
  40:                              fg=Colors.DARK_GREEN, font=('Arial', 24))
  41:         icon_label.pack(pady=10)
  42:         
  43:         # Main message
  44:         message_label = tk.Label(self.dialog_content, 
  45:                                text="What would you like to browse for?", 
  46:                                bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
  47:                                font=Fonts.DIALOG_LABEL, wraplength=300)
  48:         message_label.pack(pady=5)
  49:         
  50:         # Instructions
  51:         instruction_label = tk.Label(self.dialog_content, 
  52:                                    text="Choose File for documents, applications, etc.\nChoose Folder for directories", 
  53:                                    bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
  54:                                    font=(Fonts.DIALOG_LABEL[0], Fonts.DIALOG_LABEL[1] - 1),
  55:                                    justify=tk.CENTER)
  56:         instruction_label.pack(pady=5)
  57:     
  58:     def create_buttons(self):
  59:         """Create the choice buttons"""
  60:         # Make sure button frame is visible and has proper height
  61:         self.button_frame.configure(height=80)
  62:         self.button_frame.pack_propagate(False)
  63:         
  64:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
  65:         button_container.pack(expand=True, fill=tk.BOTH, pady=10)
  66:         
  67:         # File button (primary choice)
  68:         file_btn = tk.Button(button_container, text="File", 
  69:                            bg=Colors.DARK_GREEN, fg=Colors.WHITE,
  70:                            command=self.choose_file, 
  71:                            width=10, height=20,
  72:                            font=Fonts.DIALOG_BUTTON, 
  73:                            relief=tk.RAISED, bd=2,
  74:                            cursor='hand2')
  75:         file_btn.pack(side=tk.LEFT, padx=15, pady=10)
  76:         
  77:         # Folder button
  78:         folder_btn = tk.Button(button_container, text="Folder", 
  79:                              bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
  80:                              command=self.choose_folder, 
  81:                              width=10, height=20,
  82:                              font=Fonts.DIALOG_BUTTON, 
  83:                              relief=tk.RAISED, bd=2,
  84:                              cursor='hand2')
  85:         folder_btn.pack(side=tk.LEFT, padx=15, pady=10)
  86:         
  87:         # Cancel button
  88:         cancel_btn = tk.Button(button_container, text="Cancel", 
  89:                              bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
  90:                              command=self.cancel, 
  91:                              width=8, height=20,
  92:                              font=Fonts.DIALOG_BUTTON, 
  93:                              relief=tk.RAISED, bd=1)
  94:         cancel_btn.pack(side=tk.LEFT, padx=15, pady=10)
  95:         
  96:         # Set focus on File button (most common choice)
  97:         file_btn.focus_set()
  98:     
  99:     def choose_file(self):
 100:         """Handle file selection"""
 101:         self.choice_result = 'file'
 102:         
 103:         # Disable topmost and hide this dialog temporarily
 104:         self.attributes('-topmost', False)
 105:         self.withdraw()  # Hide this dialog temporarily
 106:         
 107:         # Use the parent window for the file dialog
 108:         try:
 109:             path = filedialog.askopenfilename(
 110:                 parent=self.parent,
 111:                 title="Select File",
 112:                 filetypes=[
 113:                     ("All Files", "*.*"),
 114:                     ("Executables", "*.exe"),
 115:                     ("Documents", "*.pdf;*.doc;*.docx;*.txt"),
 116:                     ("Spreadsheets", "*.xls;*.xlsx;*.csv"),
 117:                     ("Images", "*.png;*.jpg;*.jpeg;*.gif;*.bmp")
 118:                 ]
 119:             )
 120:             
 121:             if path:
 122:                 self.selected_path = path
 123:                 self.result = True
 124:             else:
 125:                 self.result = None
 126:                 
 127:         except Exception as e:
 128:             print(f"Error in file dialog: {e}")
 129:             self.result = None
 130:         
 131:         self.destroy()
 132:     
 133:     def choose_folder(self):
 134:         """Handle folder selection"""
 135:         self.choice_result = 'folder'
 136:                 
 137:         # Disable topmost and hide this dialog temporarily
 138:         self.attributes('-topmost', False)
 139:         self.withdraw()  # Hide this dialog temporarily
 140:         
 141:         # Use the parent window for the folder dialog
 142:         try:
 143:             path = filedialog.askdirectory(
 144:                 parent=self.parent,
 145:                 title="Select Folder"
 146:             )
 147:             
 148:             if path:
 149:                 self.selected_path = path
 150:                 self.result = True
 151:             else:
 152:                 self.result = None
 153:                 
 154:         except Exception as e:
 155:             print(f"Error in folder dialog: {e}")
 156:             self.result = None
 157:         
 158:         self.destroy()
 159:     
 160:     def cancel(self):
 161:         """Cancel the dialog"""
 162:         self.choice_result = None
 163:         self.selected_path = None
 164:         self.result = None
 165:         self.destroy()
 166:     
 167:     @classmethod
 168:     def get_path(cls, parent):
 169:         """
 170:         Show the browse choice dialog and return the selected path
 171:         
 172:         Returns:
 173:             tuple: (choice_type, selected_path) where choice_type is 'file', 'folder', or None
 174:         """
 175:         dialog = cls(parent)
 176:         
 177:         # Ensure dialog is visible and on top
 178:         dialog.deiconify()
 179:         dialog.lift()
 180:         dialog.attributes('-topmost', True)
 181:         dialog.focus_force()
 182:         dialog.grab_set()
 183:         
 184:         # Wait for dialog to complete
 185:         parent.wait_window(dialog)
 186:         
 187:         return dialog.choice_result, dialog.selected_path

────────────────────────────────────────────────────────────────────────────────
FILE: config.py
────────────────────────────────────────────────────────────────────────────────
Path: config.py
Size: 7.1 KB
Lines: 175 total, 147 non-empty
Characters: 7,098
Type: Application configuration and constants
────────────────────────────────────────────────────────────────────────────────

   1: # config.py
   2: """
   3: Configuration constants for SuiteView Taskbar Application
   4: Contains colors, sizes, paths, and other application settings
   5: """
   6: 
   7: from pathlib import Path
   8: 
   9: # Color Scheme (Two-Tone Green)
  10: class Colors:
  11:     DARK_GREEN = '#006600'      # Main taskbar, headers, borders
  12:     MEDIUM_GREEN = '#00AA00'    # Menu backgrounds, inactive elements  
  13:     LIGHT_GREEN = '#B3FFB3'     # Input fields, hover states, active elements (lighter green)
  14:     #LIGHT_GREEN = '#00CC00'
  15:     HOVER_GREEN = '#008800'     # Hover effects
  16:     INACTIVE_GRAY = '#666666'   # Cancel buttons, disabled elements
  17:     WHITE = '#FFFFFF'
  18:     BLACK = '#000000'
  19: 
  20:     WINDOW_HIDDEN = '#FF6666'      # Red tint for hidden windows
  21:     WINDOW_VISIBLE = '#66FF66'     # Green tint for visible windows
  22:     PINNED_SECTION_BG = '#004400'  # Darker green for pinned section
  23:     PIN_BUTTON_COLOR = '#FFFF00'   # Yellow for pin buttons
  24: 
  25: # Font Settings
  26: class Fonts:
  27:     TASKBAR_TITLE = ('Arial', 14, 'bold italic')
  28:     TASKBAR_BUTTON = ('Arial', 10)
  29:     MENU_HEADER = ('Arial', 10, 'bold')
  30:     MENU_ITEM = ('Arial', 8)
  31:     DIALOG_TITLE = ('Arial', 10, 'bold')
  32:     DIALOG_LABEL = ('Arial', 9)
  33:     DIALOG_BUTTON = ('Arial', 9)
  34:     WARNING_ICON = ('Arial', 20)
  35: 
  36: # Window Dimensions
  37: class Dimensions:
  38:     TASKBAR_HEIGHT = 40
  39:     MENU_MIN_WIDTH = 200
  40:     MENU_MIN_HEIGHT = 100
  41:     DIALOG_BUTTON_WIDTH = 8
  42:     DIALOG_PADDING = 10
  43: 
  44: # File Paths
  45: class Paths:
  46:     CONFIG_DIR = Path.home() / '.suiteview'
  47:     LINKS_FILE = CONFIG_DIR / 'links.json'
  48:     
  49:     @classmethod
  50:     def ensure_config_dir(cls):
  51:         """Ensure configuration directory exists"""
  52:         cls.CONFIG_DIR.mkdir(exist_ok=True)
  53:     
  54:     @classmethod
  55:     def get_config_dir_str(cls):
  56:         """Get configuration directory as normalized Windows path string"""
  57:         import os
  58:         return os.path.normpath(str(cls.CONFIG_DIR))
  59:     
  60:     @classmethod
  61:     def get_links_file_str(cls):
  62:         """Get links file path as normalized Windows path string"""
  63:         import os
  64:         return os.path.normpath(str(cls.LINKS_FILE))
  65: 
  66: # Windows API Constants
  67: class WindowsAPI:
  68:     SPI_SETWORKAREA = 0x002F
  69:     SPI_GETWORKAREA = 0x0030
  70:     HWND_TOPMOST = -1
  71:     SWP_NOMOVE = 0x0002
  72:     SWP_NOSIZE = 0x0001
  73:     SPIF_SENDCHANGE = 0x0002
  74: 
  75: # Default Categories for Links
  76: DEFAULT_CATEGORIES = ["Quick Links", "Applications", "Folders", "Websites"]
  77: 
  78: # Application Settings
  79: class Settings:
  80:     APP_NAME = "SuiteView"
  81:     VERSION = "2.0"
  82:     TASKBAR_OPACITY = 0.98
  83:     MENU_OPACITY = 0.98
  84:     AUTO_REFRESH_INTERVAL = 1000  # milliseconds
  85:     PINNED_SECTION_WIDTH = 400     # Width allocated for pinned windows
  86:     PINNED_BUTTON_WIDTH = 80       # Width of each pinned window button
  87: 
  88: 
  89: class AppColors:
  90:     """Application-specific color schemes"""
  91:     
  92:     # Define app colors with background and appropriate foreground colors
  93:     APP_COLORS = {
  94:         # Microsoft Office
  95:         'winword': {'bg': '#2B579A', 'fg': '#FFFFFF'},      # Word Blue
  96:         'excel': {'bg': '#217346', 'fg': '#FFFFFF'},        # Excel Green
  97:         'powerpnt': {'bg': '#D24726', 'fg': '#FFFFFF'},     # PowerPoint Orange
  98:         'outlook': {'bg': '#0072C6', 'fg': '#FFFFFF'},      # Outlook Blue
  99:         'msaccess': {'bg': '#A4373A', 'fg': '#FFFFFF'},     # Access Red
 100:         'onenote': {'bg': '#7719AA', 'fg': '#FFFFFF'},      # OneNote Purple
 101:         'mspub': {'bg': '#077568', 'fg': '#FFFFFF'},        # Publisher Teal
 102:         'teams': {'bg': '#6264A7', 'fg': '#FFFFFF'},        # Teams Purple
 103:         
 104:         # Browsers
 105:         'chrome': {'bg': '#4285F4', 'fg': '#FFFFFF'},       # Chrome Blue
 106:         'firefox': {'bg': '#FF7139', 'fg': '#FFFFFF'},      # Firefox Orange
 107:         'msedge': {'bg': '#0078D7', 'fg': '#FFFFFF'},       # Edge Blue
 108:         'opera': {'bg': '#FF1B2D', 'fg': '#FFFFFF'},        # Opera Red
 109:         'brave': {'bg': '#FB542B', 'fg': '#FFFFFF'},        # Brave Orange
 110:         
 111:         # Development Tools
 112:         'code': {'bg': '#007ACC', 'fg': '#FFFFFF'},         # VS Code Blue
 113:         'devenv': {'bg': '#5C2D91', 'fg': '#FFFFFF'},       # Visual Studio Purple
 114:         'pycharm64': {'bg': '#21D789', 'fg': '#FFFFFF'},    # PyCharm Green
 115:         'sublime_text': {'bg': '#FF9800', 'fg': '#FFFFFF'}, # Sublime Orange
 116:         'notepad++': {'bg': '#90C53F', 'fg': '#FFFFFF'},    # Notepad++ Green
 117:         'cursor': {'bg': '#000000', 'fg': '#FFFFFF'},       # Cursor AI Black
 118:         
 119:         # File Types/Readers
 120:         'acrobat': {'bg': '#EC1C24', 'fg': '#FFFFFF'},      # Adobe Acrobat Red
 121:         'acrord32': {'bg': '#EC1C24', 'fg': '#FFFFFF'},     # Adobe Reader Red
 122:         
 123:         # Communication
 124:         'slack': {'bg': '#4A154B', 'fg': '#FFFFFF'},        # Slack Purple
 125:         'discord': {'bg': '#5865F2', 'fg': '#FFFFFF'},      # Discord Blurple
 126:         'zoom': {'bg': '#2D8CFF', 'fg': '#FFFFFF'},         # Zoom Blue
 127:         'skype': {'bg': '#00AFF0', 'fg': '#FFFFFF'},        # Skype Blue
 128:         
 129:         # Media/Creative
 130:         'photoshop': {'bg': '#31A8FF', 'fg': '#FFFFFF'},    # Photoshop Blue
 131:         'illustrator': {'bg': '#FF9A00', 'fg': '#FFFFFF'},  # Illustrator Orange
 132:         'premiere': {'bg': '#EA77FF', 'fg': '#000000'},     # Premiere Purple
 133:         'spotify': {'bg': '#1DB954', 'fg': '#FFFFFF'},      # Spotify Green
 134:         'vlc': {'bg': '#FF8800', 'fg': '#FFFFFF'},          # VLC Orange
 135:         
 136:         # System/Utilities
 137:         'explorer': {'bg': '#FFB900', 'fg': '#000000'},     # File Explorer Yellow
 138:         'cmd': {'bg': '#0C0C0C', 'fg': '#FFFFFF'},          # Command Prompt Black
 139:         'powershell': {'bg': '#012456', 'fg': '#FFFFFF'},   # PowerShell Blue
 140:         'taskmgr': {'bg': '#0078D7', 'fg': '#FFFFFF'},      # Task Manager Blue
 141:         'notepad': {'bg': '#D0D0D0', 'fg': '#000000'},      # Notepad Light Gray
 142:         
 143:         # Default
 144:         'default': {'bg': '#6B6B6B', 'fg': '#FFFFFF'}       # Default Gray
 145:     }
 146:     
 147:     @classmethod
 148:     def get_app_colors(cls, process_name):
 149:         """Get colors for an application based on process name"""
 150:         # Remove .exe extension and convert to lowercase
 151:         app_name = process_name.replace('.exe', '').lower()
 152:         
 153:         # Check for file extensions in the window title
 154:         # This will be handled in the ManagedWindow class
 155:         
 156:         return cls.APP_COLORS.get(app_name, cls.APP_COLORS['default'])
 157:     
 158:     @classmethod
 159:     def get_colors_for_file_type(cls, title):
 160:         """Get colors based on file type in window title"""
 161:         title_lower = title.lower()
 162:         
 163:         # Check for file types in title
 164:         if '.xlsx' in title_lower or '.xls' in title_lower or '.csv' in title_lower:
 165:             return cls.APP_COLORS['excel']
 166:         elif '.docx' in title_lower or '.doc' in title_lower:
 167:             return cls.APP_COLORS['winword']
 168:         elif '.pptx' in title_lower or '.ppt' in title_lower:
 169:             return cls.APP_COLORS['powerpnt']
 170:         elif '.pdf' in title_lower:
 171:             return cls.APP_COLORS['acrobat']
 172:         elif '.accdb' in title_lower or '.mdb' in title_lower:
 173:             return cls.APP_COLORS['msaccess']
 174:         
 175:         return None

────────────────────────────────────────────────────────────────────────────────
FILE: email_manager.py
────────────────────────────────────────────────────────────────────────────────
Path: email_manager.py
Size: 20.0 KB
Lines: 480 total, 398 non-empty
Characters: 19,998
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # email_manager.py
   2: """
   3: Updated email attachment management with support for both received and sent emails
   4: """
   5: 
   6: import win32com.client
   7: from datetime import datetime, timedelta
   8: import tkinter as tk
   9: import json
  10: import os
  11: from pathlib import Path
  12: import threading
  13: import time
  14: 
  15: # Keep existing EmailCache class as-is
  16: class EmailCache:
  17:     """Handles caching of email scan results"""
  18:     
  19:     def __init__(self, cache_dir: str | Path = None):
  20:         """Initialize the email cache"""
  21:         if cache_dir is None:
  22:             # Use app config directory
  23:             self.cache_dir = Path.home() / '.suiteview' / 'email_cache'
  24:         else:
  25:             self.cache_dir = cache_dir
  26:         
  27:         # Ensure cache directory exists
  28:         self.cache_dir.mkdir(parents=True, exist_ok=True)
  29:     
  30:     def get_cache_file(self, scan_type: str) -> Path:
  31:         """Get the cache file path for a specific scan type"""
  32:         return self.cache_dir / f"{scan_type}_cache.json"
  33:     
  34:     def save_scan(self, scan_type: str, data: list[dict], metadata: dict):
  35:         """Save scan results to cache"""
  36:         cache_file = self.get_cache_file(scan_type)
  37:         cache_data = {
  38:             'metadata': metadata,
  39:             'data': data,
  40:             'cached_at': datetime.now().isoformat()
  41:         }
  42:         
  43:         try:
  44:             with open(cache_file, 'w', encoding='utf-8') as f:
  45:                 json.dump(cache_data, f, indent=2, ensure_ascii=False)
  46:             return True
  47:         except Exception as e:
  48:             print(f"Error saving cache: {e}")
  49:             return False
  50:     
  51:     def load_scan(self, scan_type: str) -> dict | None:
  52:         """Load scan results from cache"""
  53:         cache_file = self.get_cache_file(scan_type)
  54:         
  55:         if not cache_file.exists():
  56:             return None
  57:         
  58:         try:
  59:             with open(cache_file, 'r', encoding='utf-8') as f:
  60:                 cache_data = json.load(f)
  61:             
  62:             # Convert cached_at back to datetime
  63:             cache_data['cached_at'] = datetime.fromisoformat(cache_data['cached_at'])
  64:             return cache_data
  65:         except Exception as e:
  66:             print(f"Error loading cache: {e}")
  67:             return None
  68:     
  69:     def is_cache_valid(self, scan_type: str, max_age_minutes: int = 60) -> bool:
  70:         """Check if cache exists and is still valid"""
  71:         cache_data = self.load_scan(scan_type)
  72:         if not cache_data:
  73:             return False
  74:         
  75:         cached_at = cache_data['cached_at']
  76:         age = datetime.now() - cached_at
  77:         return age.total_seconds() < (max_age_minutes * 60)
  78:     
  79:     def clear_cache(self, scan_type: str | None = None):
  80:         """Clear cache for specific scan type or all caches"""
  81:         if scan_type:
  82:             cache_file = self.get_cache_file(scan_type)
  83:             if cache_file.exists():
  84:                 cache_file.unlink()
  85:         else:
  86:             # Clear all cache files
  87:             for cache_file in self.cache_dir.glob("*_cache.json"):
  88:                 cache_file.unlink()
  89: 
  90: 
  91: class EmailManager:
  92:     """Enhanced email manager with caching and support for received/sent emails"""
  93:     
  94:     # Scan type constants
  95:     SCAN_ATTACHMENTS = "attachments"
  96:     SCAN_ATTACHMENTS_SENT = "attachments_sent"
  97:     SCAN_IMPORTANT = "important"
  98:     SCAN_FLAGGED = "flagged"
  99:     SCAN_UNREAD = "unread"
 100:     
 101:     def __init__(self, weeks_back: int = 2):
 102:         """Initialize the email manager"""
 103:         self.weeks_back = weeks_back
 104:         self.outlook = None
 105:         self.cache = EmailCache()
 106:         self._initialize_outlook()
 107:         
 108:         # Track if a scan is in progress
 109:         self.scan_in_progress = False
 110:         self.current_scan_thread = None
 111:     
 112:     def _initialize_outlook(self):
 113:         """Initialize Outlook connection"""
 114:         try:
 115:             self.outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
 116:         except Exception as e:
 117:             print(f"Error initializing Outlook: {e}")
 118:             self.outlook = None
 119:     
 120:     def get_emails_with_attachments(self, use_cache: bool = True, 
 121:                                    force_refresh: bool = False,
 122:                                    email_type: str = 'received') -> dict:
 123:         """
 124:         Get emails with attachments, using cache if available
 125:         
 126:         Args:
 127:             use_cache: Whether to use cached data
 128:             force_refresh: Force a fresh scan
 129:             email_type: 'received' or 'sent'
 130:         
 131:         Returns:
 132:             Dictionary with 'data', 'metadata', and 'from_cache' keys
 133:         """
 134:         scan_type = self.SCAN_ATTACHMENTS if email_type == 'received' else self.SCAN_ATTACHMENTS_SENT
 135:         
 136:         # Check cache first if requested
 137:         if use_cache and not force_refresh:
 138:             cached_data = self.cache.load_scan(scan_type)
 139:             if cached_data and self.cache.is_cache_valid(scan_type):
 140:                 return {
 141:                     'data': cached_data['data'],
 142:                     'metadata': cached_data['metadata'],
 143:                     'from_cache': True,
 144:                     'cached_at': cached_data['cached_at']
 145:                 }
 146:         
 147:         # Perform fresh scan
 148:         if email_type == 'received':
 149:             return self._scan_emails_with_attachments()
 150:         else:
 151:             return self._scan_sent_emails_with_attachments()
 152:     
 153:     def _scan_sent_emails_with_attachments(self) -> dict:
 154:         """Scan sent emails for attachments"""
 155:         start_time = datetime.now()
 156:         email_attachments = []
 157:         
 158:         try:
 159:             # Create a new Outlook instance for this thread
 160:             import pythoncom
 161:             pythoncom.CoInitialize()
 162:             
 163:             # Create fresh Outlook connection for this scan
 164:             outlook_app = win32com.client.Dispatch("Outlook.Application")
 165:             namespace = outlook_app.GetNamespace("MAPI")
 166:             
 167:             # Get the Sent Items folder (5 = olFolderSentMail)
 168:             sent_folder = namespace.GetDefaultFolder(5)
 169:             messages = sent_folder.Items
 170:             
 171:             # Filter messages by date
 172:             start_date = datetime.now() - timedelta(weeks=self.weeks_back)
 173:             date_filter = f"[SentOn] >= '{start_date.strftime('%m/%d/%Y %H:%M %p')}'"
 174:             messages = messages.Restrict(date_filter)
 175:             
 176:             total_scanned = 0
 177:             total_emails_with_attachments = 0
 178:             
 179:             for message in messages:
 180:                 total_scanned += 1
 181:                 try:
 182:                     if message.Attachments.Count > 0:
 183:                         total_emails_with_attachments += 1
 184:                         
 185:                         # Get recipients
 186:                         recipients = []
 187:                         for i in range(1, message.Recipients.Count + 1):
 188:                             try:
 189:                                 recipient = message.Recipients.Item(i)
 190:                                 recipients.append(recipient.Name)
 191:                             except:
 192:                                 pass
 193:                         to_string = "; ".join(recipients) if recipients else "Unknown"
 194:                         
 195:                         # Create one entry per attachment
 196:                         for i in range(1, message.Attachments.Count + 1):
 197:                             try:
 198:                                 attachment = message.Attachments.Item(i)
 199:                                 attachment_name = attachment.FileName
 200:                                 
 201:                                 # Get file extension
 202:                                 if '.' in attachment_name:
 203:                                     extension = attachment_name.rsplit('.', 1)[1].upper()
 204:                                 else:
 205:                                     extension = 'NONE'
 206:                                 
 207:                                 # Try to get size
 208:                                 try:
 209:                                     attachment_size = attachment.Size
 210:                                 except:
 211:                                     attachment_size = 0
 212:                                 
 213:                                 attachment_data = {
 214:                                     'Date': message.SentOn.strftime("%Y-%m-%d %H:%M"),
 215:                                     'To': to_string,  # Changed from 'From' to 'To'
 216:                                     'Subject': message.Subject,
 217:                                     'AttachmentName': attachment_name,
 218:                                     'Extension': extension,
 219:                                     'Size': attachment_size,
 220:                                     'SizeFormatted': self._format_size(attachment_size) if attachment_size > 0 else "Unknown",
 221:                                     'EntryID': message.EntryID,
 222:                                     'AttachmentIndex': i,
 223:                                     'SentOn': message.SentOn.isoformat(),
 224:                                 }
 225:                                 email_attachments.append(attachment_data)
 226:                                 
 227:                             except Exception as e:
 228:                                 print(f"Error processing attachment {i}: {e}")
 229:                                 # Still add an entry for failed attachments
 230:                                 attachment_data = {
 231:                                     'Date': message.SentOn.strftime("%Y-%m-%d %H:%M"),
 232:                                     'To': to_string,
 233:                                     'Subject': message.Subject,
 234:                                     'AttachmentName': "(Error reading attachment)",
 235:                                     'Extension': 'ERROR',
 236:                                     'Size': 0,
 237:                                     'SizeFormatted': "Error",
 238:                                     'EntryID': message.EntryID,
 239:                                     'AttachmentIndex': i,
 240:                                     'SentOn': message.SentOn.isoformat(),
 241:                                 }
 242:                                 email_attachments.append(attachment_data)
 243:                                 
 244:                 except Exception as e:
 245:                     print(f"Error processing message: {e}")
 246:                     continue
 247:             
 248:             # Sort by date, newest first
 249:             email_attachments.sort(key=lambda x: x['SentOn'], reverse=True)
 250:             
 251:             # Prepare metadata
 252:             metadata = {
 253:                 'scan_type': self.SCAN_ATTACHMENTS_SENT,
 254:                 'weeks_back': self.weeks_back,
 255:                 'start_date': start_date.isoformat(),
 256:                 'end_date': datetime.now().isoformat(),
 257:                 'total_scanned': total_scanned,
 258:                 'total_emails_with_attachments': total_emails_with_attachments,
 259:                 'total_attachment_lines': len(email_attachments),
 260:                 'scan_duration': (datetime.now() - start_time).total_seconds()
 261:             }
 262:             
 263:             # Save to cache
 264:             self.cache.save_scan(self.SCAN_ATTACHMENTS_SENT, email_attachments, metadata)
 265:             
 266:             return {
 267:                 'data': email_attachments,
 268:                 'metadata': metadata,
 269:                 'from_cache': False
 270:             }
 271:         
 272:         except Exception as e:
 273:             print(f"Error retrieving sent emails: {e}")
 274:             return {'data': [], 'metadata': {}, 'from_cache': False}
 275:             
 276:         finally:
 277:             # Uninitialize COM for this thread
 278:             try:
 279:                 pythoncom.CoUninitialize()
 280:             except:
 281:                 pass
 282:     
 283:     def _scan_emails_with_attachments(self) -> dict:
 284:         """Perform a fresh scan for emails with attachments - one line per attachment"""
 285:         
 286:         start_time = datetime.now()
 287:         email_attachments = []
 288:         
 289:         try:
 290:             # Create a new Outlook instance for this thread
 291:             import pythoncom
 292:             pythoncom.CoInitialize()
 293:             
 294:             # Create fresh Outlook connection for this scan
 295:             outlook_app = win32com.client.Dispatch("Outlook.Application")
 296:             namespace = outlook_app.GetNamespace("MAPI")
 297:             
 298:             # Try to get the default inbox
 299:             inbox = namespace.GetDefaultFolder(6)  # 6 = olFolderInbox
 300:             messages = inbox.Items
 301:             
 302:             # Filter messages by date
 303:             start_date = datetime.now() - timedelta(weeks=self.weeks_back)
 304:             date_filter = f"[ReceivedTime] >= '{start_date.strftime('%m/%d/%Y %H:%M %p')}'"
 305:             messages = messages.Restrict(date_filter)
 306:             
 307:             total_scanned = 0
 308:             total_emails_with_attachments = 0
 309:             
 310:             for message in messages:
 311:                 total_scanned += 1
 312:                 try:
 313:                     if message.Attachments.Count > 0:
 314:                         total_emails_with_attachments += 1
 315:                         
 316:                         # Create one entry per attachment
 317:                         for i in range(1, message.Attachments.Count + 1):
 318:                             try:
 319:                                 attachment = message.Attachments.Item(i)
 320:                                 attachment_name = attachment.FileName
 321:                                 
 322:                                 # Get file extension
 323:                                 if '.' in attachment_name:
 324:                                     extension = attachment_name.rsplit('.', 1)[1].upper()
 325:                                 else:
 326:                                     extension = 'NONE'
 327:                                 
 328:                                 # Try to get size
 329:                                 try:
 330:                                     attachment_size = attachment.Size
 331:                                 except:
 332:                                     attachment_size = 0
 333:                                 
 334:                                 attachment_data = {
 335:                                     'Date': message.ReceivedTime.strftime("%Y-%m-%d %H:%M"),
 336:                                     'From': message.SenderName,
 337:                                     'Subject': message.Subject,
 338:                                     'AttachmentName': attachment_name,
 339:                                     'Extension': extension,
 340:                                     'Size': attachment_size,
 341:                                     'SizeFormatted': self._format_size(attachment_size) if attachment_size > 0 else "Unknown",
 342:                                     'EntryID': message.EntryID,
 343:                                     'AttachmentIndex': i,
 344:                                     'ReceivedTime': message.ReceivedTime.isoformat(),
 345:                                 }
 346:                                 email_attachments.append(attachment_data)
 347:                                 
 348:                             except Exception as e:
 349:                                 print(f"Error processing attachment {i}: {e}")
 350:                                 # Still add an entry for failed attachments
 351:                                 attachment_data = {
 352:                                     'Date': message.ReceivedTime.strftime("%Y-%m-%d %H:%M"),
 353:                                     'From': message.SenderName,
 354:                                     'Subject': message.Subject,
 355:                                     'AttachmentName': "(Error reading attachment)",
 356:                                     'Extension': 'ERROR',
 357:                                     'Size': 0,
 358:                                     'SizeFormatted': "Error",
 359:                                     'EntryID': message.EntryID,
 360:                                     'AttachmentIndex': i,
 361:                                     'ReceivedTime': message.ReceivedTime.isoformat(),
 362:                                 }
 363:                                 email_attachments.append(attachment_data)
 364:                                 
 365:                 except Exception as e:
 366:                     print(f"Error processing message: {e}")
 367:                     continue
 368:             
 369:             # Sort by date, newest first
 370:             email_attachments.sort(key=lambda x: x['ReceivedTime'], reverse=True)
 371:             
 372:             # Prepare metadata
 373:             metadata = {
 374:                 'scan_type': self.SCAN_ATTACHMENTS,
 375:                 'weeks_back': self.weeks_back,
 376:                 'start_date': start_date.isoformat(),
 377:                 'end_date': datetime.now().isoformat(),
 378:                 'total_scanned': total_scanned,
 379:                 'total_emails_with_attachments': total_emails_with_attachments,
 380:                 'total_attachment_lines': len(email_attachments),
 381:                 'scan_duration': (datetime.now() - start_time).total_seconds()
 382:             }
 383:             
 384:             # Save to cache
 385:             self.cache.save_scan(self.SCAN_ATTACHMENTS, email_attachments, metadata)
 386:             
 387:             return {
 388:                 'data': email_attachments,
 389:                 'metadata': metadata,
 390:                 'from_cache': False
 391:             }
 392:         
 393:         except Exception as e:
 394:             print(f"Error retrieving emails: {e}")
 395:             return {'data': [], 'metadata': {}, 'from_cache': False}
 396:             
 397:         finally:
 398:             # Uninitialize COM for this thread
 399:             try:
 400:                 pythoncom.CoUninitialize()
 401:             except:
 402:                 pass
 403:     
 404:     def open_attachment(self, entry_id: str, attachment_index: int):
 405:         """Open a specific attachment from an email"""
 406:         if not self.outlook:
 407:             self._initialize_outlook()
 408:             
 409:         if not self.outlook:
 410:             print("Cannot connect to Outlook")
 411:             return
 412:         
 413:         try:
 414:             import tempfile
 415:             import os
 416:             
 417:             outlook_app = win32com.client.Dispatch("Outlook.Application")
 418:             mail_item = outlook_app.Session.GetItemFromID(entry_id)
 419:             
 420:             if attachment_index <= mail_item.Attachments.Count:
 421:                 attachment = mail_item.Attachments.Item(attachment_index)
 422:                 
 423:                 # Save attachment to temp directory
 424:                 temp_dir = tempfile.gettempdir()
 425:                 temp_path = os.path.join(temp_dir, attachment.FileName)
 426:                 attachment.SaveAsFile(temp_path)
 427:                 
 428:                 # Open the file
 429:                 os.startfile(temp_path)
 430:             else:
 431:                 print(f"Attachment index {attachment_index} not found")
 432:                 
 433:         except Exception as e:
 434:             print(f"Error opening attachment: {e}")
 435:     
 436:     def _format_size(self, size_bytes: int) -> str:
 437:         """Format file size in human readable format"""
 438:         if size_bytes == 0:
 439:             return "0 B"
 440:         
 441:         size_names = ["B", "KB", "MB", "GB"]
 442:         i = 0
 443:         size = float(size_bytes)
 444:         
 445:         while size >= 1024.0 and i < len(size_names) - 1:
 446:             size /= 1024.0
 447:             i += 1
 448:         
 449:         if i == 0:
 450:             return f"{int(size)} {size_names[i]}"
 451:         else:
 452:             return f"{size:.1f} {size_names[i]}"
 453:     
 454:     def open_email(self, entry_id: str):
 455:         """Open a specific email in Outlook"""
 456:         if not self.outlook:
 457:             return
 458:         
 459:         try:
 460:             outlook_app = win32com.client.Dispatch("Outlook.Application")
 461:             mail_item = outlook_app.Session.GetItemFromID(entry_id)
 462:             mail_item.Display()
 463:         except Exception as e:
 464:             print(f"Error opening email: {e}")
 465:     
 466:     def clear_cache(self, scan_type: str | None = None):
 467:         """Clear email cache"""
 468:         self.cache.clear_cache(scan_type)
 469:     
 470:     def get_cache_info(self, scan_type: str) -> dict | None:
 471:         """Get information about cached data"""
 472:         cached_data = self.cache.load_scan(scan_type)
 473:         if not cached_data:
 474:             return None
 475:         
 476:         return {
 477:             'cached_at': cached_data['cached_at'],
 478:             'item_count': len(cached_data['data']),
 479:             'metadata': cached_data['metadata']
 480:         }

────────────────────────────────────────────────────────────────────────────────
FILE: email_menu.py
────────────────────────────────────────────────────────────────────────────────
Path: email_menu.py
Size: 15.0 KB
Lines: 348 total, 292 non-empty
Characters: 14,985
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # email_menu.py
   2: """
   3: Updated email attachments menu with support for both received and sent emails
   4: """
   5: 
   6: import tkinter as tk
   7: from inventory_view_window import InventoryViewWindow
   8: from email_manager import EmailManager
   9: from ui_components import CustomDialog, WarningDialog
  10: from config import Colors, Fonts, Dimensions
  11: import threading
  12: 
  13: class EmailAttachmentsMenu:
  14:     """Enhanced email attachments menu with caching and support for sent/received"""
  15:     
  16:     def __init__(self, parent_window):
  17:         """Initialize the email attachments menu"""
  18:         self.parent = parent_window
  19:         self.email_manager = EmailManager(weeks_back=8)
  20:         self.inventory_window = None
  21:         self.loading_dialog = None
  22:     
  23:     def show_email_attachments(self, force_refresh: bool = False, email_type: str = 'received'):
  24:         """
  25:         Display the email attachments in an inventory view window
  26:         
  27:         Args:
  28:             force_refresh: Force a fresh scan
  29:             email_type: 'received' or 'sent'
  30:         """
  31:         # Check if we need to do a fresh scan
  32:         scan_type = EmailManager.SCAN_ATTACHMENTS if email_type == 'received' else EmailManager.SCAN_ATTACHMENTS_SENT
  33:         cache_exists = self.email_manager.get_cache_info(scan_type) is not None
  34:         needs_fresh_scan = force_refresh or not cache_exists or not self.email_manager.cache.is_cache_valid(scan_type)
  35:         
  36:         if needs_fresh_scan:
  37:             # Show loading indicator and scan in background
  38:             self.show_loading_dialog(email_type)
  39:             
  40:             scan_thread = threading.Thread(
  41:                 target=self._perform_scan,
  42:                 args=(email_type,),
  43:                 daemon=True
  44:             )
  45:             scan_thread.start()
  46:         else:
  47:             # Use cached data directly
  48:             result = self.email_manager.get_emails_with_attachments(
  49:                 use_cache=True, 
  50:                 force_refresh=False,
  51:                 email_type=email_type
  52:             )
  53:             self._display_emails_from_result(result, email_type)
  54:     
  55:     def _perform_scan(self, email_type: str):
  56:         """Perform email scan in background thread"""
  57:         result = self.email_manager.get_emails_with_attachments(
  58:             use_cache=False,
  59:             force_refresh=True,
  60:             email_type=email_type
  61:         )
  62:         
  63:         if self.loading_dialog:
  64:             self.loading_dialog.after(0, lambda: self._scan_complete(result, email_type))
  65:     
  66:     def _scan_complete(self, result: dict, email_type: str):
  67:         """Handle scan completion"""
  68:         # Close loading dialog
  69:         if self.loading_dialog:
  70:             self.loading_dialog.destroy()
  71:             self.loading_dialog = None
  72:         
  73:         # Display results
  74:         self._display_emails_from_result(result, email_type)
  75:     
  76:     def _display_emails_from_result(self, result: dict, email_type: str):
  77:         """Display emails from scan result"""
  78:         attachments = result['data']
  79:         metadata = result.get('metadata', {})
  80:         from_cache = result.get('from_cache', False)
  81:         
  82:         if not attachments:
  83:             self._show_no_emails_message(email_type)
  84:             return
  85:         
  86:         # Prepare additional info
  87:         additional_info = {
  88:             'Period': f"Last {metadata.get('weeks_back', 2)} weeks",
  89:             'Total Emails': metadata.get('total_emails_with_attachments', 'Unknown'),
  90:             'Total Attachments': len(attachments),
  91:             'Source': 'Cached' if from_cache else 'Fresh Scan',
  92:             'Type': 'Sent' if email_type == 'sent' else 'Received'
  93:         }
  94:         
  95:         if from_cache and 'cached_at' in result:
  96:             cached_time = result['cached_at'].strftime('%Y-%m-%d %H:%M')
  97:             additional_info['Cached At'] = cached_time
  98:         
  99:         if 'scan_duration' in metadata and not from_cache:
 100:             additional_info['Scan Time'] = f"{metadata['scan_duration']:.1f}s"
 101:         
 102:         # Configure columns based on email type
 103:         if email_type == 'sent':
 104:             columns = [
 105:                 {'key': 'Date', 'header': 'Date', 'width': 120, 'type': 'date'},
 106:                 {'key': 'To', 'header': 'To', 'width': 180, 'type': 'text'},
 107:                 {'key': 'Subject', 'header': 'Subject', 'width': 300, 'type': 'text'},
 108:                 {'key': 'AttachmentName', 'header': 'Attachment', 'width': 250, 'type': 'text'},
 109:                 {'key': 'Extension', 'header': 'Type', 'width': 60, 'type': 'text'},
 110:                 {'key': 'SizeFormatted', 'header': 'Size', 'width': 80, 'type': 'text'}
 111:             ]
 112:             title = 'Sent Email Attachments'
 113:         else:
 114:             columns = [
 115:                 {'key': 'Date', 'header': 'Date', 'width': 120, 'type': 'date'},
 116:                 {'key': 'From', 'header': 'From', 'width': 180, 'type': 'text'},
 117:                 {'key': 'Subject', 'header': 'Subject', 'width': 300, 'type': 'text'},
 118:                 {'key': 'AttachmentName', 'header': 'Attachment', 'width': 250, 'type': 'text'},
 119:                 {'key': 'Extension', 'header': 'Type', 'width': 60, 'type': 'text'},
 120:                 {'key': 'SizeFormatted', 'header': 'Size', 'width': 80, 'type': 'text'}
 121:             ]
 122:             title = 'Received Email Attachments'
 123:         
 124:         # Configure the inventory view window
 125:         window_config = {
 126:             'title': title,
 127:             'columns': columns,
 128:             'on_item_click': self._handle_item_click,
 129:             'on_item_double_click': self._open_email,
 130:             'show_stats': True,
 131:             'allow_export': True,
 132:             'window_width': 1200,
 133:             'window_height': 600,
 134:             'additional_info': additional_info
 135:         }
 136:         
 137:         # Create custom inventory window with refresh button
 138:         self.inventory_window = EmailInventoryWindow(
 139:             self.parent, 
 140:             attachments, 
 141:             window_config,
 142:             lambda: self.refresh_emails(email_type),
 143:             lambda: self.full_refresh_emails(email_type),
 144:             email_type
 145:         )
 146:     
 147:     def _handle_item_click(self, item: dict, column_key: str = None):
 148:         """Handle clicks on specific columns"""
 149:         if not column_key:
 150:             return
 151:             
 152:         if column_key == 'Subject':
 153:             # Open the email
 154:             self._open_email(item)
 155:         elif column_key == 'AttachmentName':
 156:             # Open the attachment
 157:             self._open_attachment(item)
 158:     
 159:     def _open_attachment(self, attachment_data: dict):
 160:         """Handle click on attachment to open it"""
 161:         if 'EntryID' in attachment_data and 'AttachmentIndex' in attachment_data:
 162:             self.email_manager.open_attachment(
 163:                 attachment_data['EntryID'], 
 164:                 attachment_data['AttachmentIndex']
 165:             )
 166: 
 167:     def refresh_emails(self, email_type: str):
 168:         """Quick refresh - check for new emails only"""
 169:         if self.inventory_window and hasattr(self.inventory_window, 'show_refreshing'):
 170:             self.inventory_window.show_refreshing()
 171:         
 172:         # For now, just do a full refresh
 173:         # Could be optimized later to only check recent emails
 174:         thread = threading.Thread(
 175:             target=self._perform_quick_refresh,
 176:             args=(email_type,),
 177:             daemon=True
 178:         )
 179:         thread.start()
 180:     
 181:     def _perform_quick_refresh(self, email_type: str):
 182:         """Perform quick refresh in background"""
 183:         result = self.email_manager.get_emails_with_attachments(
 184:             use_cache=False,
 185:             force_refresh=True,
 186:             email_type=email_type
 187:         )
 188:         
 189:         if self.inventory_window:
 190:             self.inventory_window.after(0, lambda: self._update_inventory(result))
 191:     
 192:     def full_refresh_emails(self, email_type: str):
 193:         """Full refresh - rescan all emails"""
 194:         if self.inventory_window:
 195:             self.inventory_window.destroy()
 196:         self.show_email_attachments(force_refresh=True, email_type=email_type)
 197:     
 198:     def _update_inventory(self, result: dict):
 199:         """Update inventory window with new data"""
 200:         if self.inventory_window and self.inventory_window.winfo_exists():
 201:             # Update the data
 202:             self.inventory_window.original_data = result['data']
 203:             self.inventory_window.filtered_data = result['data']
 204:             self.inventory_window.populate_grid()
 205:             self.inventory_window.update_stats()
 206:             
 207:             # Show refresh complete message
 208:             self.inventory_window.show_refresh_complete("Refresh complete")
 209:     
 210:     def _open_email(self, email_data: dict):
 211:         """Handle double-click on email item to open it"""
 212:         if 'EntryID' in email_data:
 213:             self.email_manager.open_email(email_data['EntryID'])
 214:     
 215:     def _show_no_emails_message(self, email_type: str):
 216:         """Show a message when no emails with attachments are found"""
 217:         email_type_text = "sent" if email_type == 'sent' else "received"
 218:         WarningDialog.show(
 219:             self.parent,
 220:             "No Emails Found",
 221:             f"No {email_type_text} emails with attachments found in the last {self.email_manager.weeks_back} weeks."
 222:         )
 223:     
 224:     def show_loading_dialog(self, email_type: str):
 225:         """Show loading dialog during email scan"""
 226:         email_type_text = "sent" if email_type == 'sent' else "received"
 227:         self.loading_dialog = LoadingDialog(self.parent, f"Scanning {email_type_text} emails...")
 228: 
 229: 
 230: class EmailInventoryWindow(InventoryViewWindow):
 231:     """Extended inventory window with refresh capabilities"""
 232:     
 233:     def __init__(self, parent, data, config, quick_refresh_callback, full_refresh_callback, email_type):
 234:         self.quick_refresh_callback = quick_refresh_callback
 235:         self.full_refresh_callback = full_refresh_callback
 236:         self.email_type = email_type
 237:         super().__init__(parent, data, config)
 238:     
 239:     def create_footer(self):
 240:         """Override to add refresh buttons"""
 241:         footer_frame = tk.Frame(self.content_frame, bg=Colors.DARK_GREEN, height=50)
 242:         footer_frame.pack(fill=tk.X, side=tk.BOTTOM, padx=2, pady=2)
 243:         footer_frame.pack_propagate(False)
 244:         
 245:         # Left side - filter status and refresh status
 246:         left_frame = tk.Frame(footer_frame, bg=Colors.DARK_GREEN)
 247:         left_frame.pack(side=tk.LEFT, fill=tk.Y)
 248:         
 249:         self.filter_status_label = tk.Label(left_frame, text="No filters applied", 
 250:                                            bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 251:                                            font=Fonts.MENU_ITEM)
 252:         self.filter_status_label.pack(side=tk.LEFT, padx=10, pady=5)
 253:         
 254:         # Refresh status label
 255:         self.refresh_status_label = tk.Label(left_frame, text="", 
 256:                                            bg=Colors.DARK_GREEN, fg=Colors.LIGHT_GREEN,
 257:                                            font=Fonts.MENU_ITEM)
 258:         self.refresh_status_label.pack(side=tk.LEFT, padx=10, pady=5)
 259:         
 260:         # Right side - action buttons
 261:         button_frame = tk.Frame(footer_frame, bg=Colors.DARK_GREEN)
 262:         button_frame.pack(side=tk.RIGHT, fill=tk.Y)
 263:         
 264:         # Quick Refresh button
 265:         quick_refresh_btn = tk.Button(button_frame, text="↻ Quick Refresh", 
 266:                                      bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 267:                                      relief=tk.RAISED, bd=1, cursor='hand2',
 268:                                      font=Fonts.MENU_ITEM, padx=10,
 269:                                      command=self.quick_refresh_callback)
 270:         quick_refresh_btn.pack(side=tk.LEFT, padx=5, pady=5)
 271:         
 272:         # Full Refresh button
 273:         full_refresh_btn = tk.Button(button_frame, text="⟳ Full Refresh", 
 274:                                     bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 275:                                     relief=tk.RAISED, bd=1, cursor='hand2',
 276:                                     font=Fonts.MENU_ITEM, padx=10,
 277:                                     command=self.full_refresh_callback)
 278:         full_refresh_btn.pack(side=tk.LEFT, padx=5, pady=5)
 279:         
 280:         # Clear Filters
 281:         clear_btn = tk.Button(button_frame, text="Clear All Filters", 
 282:                              bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 283:                              relief=tk.RAISED, bd=1, cursor='hand2',
 284:                              font=Fonts.MENU_ITEM, padx=10,
 285:                              command=self.clear_all_filters)
 286:         clear_btn.pack(side=tk.LEFT, padx=5, pady=5)
 287:         
 288:         # Export to Excel
 289:         if self.allow_export:
 290:             export_btn = tk.Button(button_frame, text="Export to Excel", 
 291:                                   bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 292:                                   relief=tk.RAISED, bd=1, cursor='hand2',
 293:                                   font=Fonts.MENU_ITEM, padx=10,
 294:                                   command=self.export_to_excel)
 295:             export_btn.pack(side=tk.LEFT, padx=5, pady=5)
 296:         
 297:         # Close button
 298:         close_btn = tk.Button(button_frame, text="Close", 
 299:                              bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 300:                              relief=tk.RAISED, bd=1, cursor='hand2',
 301:                              font=Fonts.MENU_ITEM, padx=10,
 302:                              command=self.on_closing)
 303:         close_btn.pack(side=tk.LEFT, padx=5, pady=5)
 304:     
 305:     def show_refreshing(self):
 306:         """Show refreshing status"""
 307:         self.refresh_status_label.config(text="Refreshing...")
 308:     
 309:     def show_refresh_complete(self, message: str):
 310:         """Show refresh complete status"""
 311:         self.refresh_status_label.config(text=message)
 312:         # Clear message after 3 seconds
 313:         self.after(3000, lambda: self.refresh_status_label.config(text=""))
 314: 
 315: 
 316: class LoadingDialog(CustomDialog):
 317:     """Simple loading dialog"""
 318:     
 319:     def __init__(self, parent, message="Loading..."):
 320:         super().__init__(parent, "Please Wait", width=300, height=150)
 321:         
 322:         # Loading message
 323:         msg_label = tk.Label(self.dialog_content, text=message,
 324:                            bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 325:                            font=Fonts.DIALOG_LABEL)
 326:         msg_label.pack(pady=20)
 327:         
 328:         # Progress indicator (simple animation)
 329:         self.progress_label = tk.Label(self.dialog_content, text="⏳",
 330:                                      bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 331:                                      font=('Arial', 24))
 332:         self.progress_label.pack(pady=10)
 333:         
 334:         # Remove button frame
 335:         self.button_frame.pack_forget()
 336:         
 337:         # Start animation
 338:         self.animate_progress()
 339:     
 340:     def animate_progress(self):
 341:         """Simple progress animation"""
 342:         current = self.progress_label.cget("text")
 343:         if current == "⏳":
 344:             self.progress_label.config(text="⌛")
 345:         else:
 346:             self.progress_label.config(text="⏳")
 347:         
 348:         self.after(500, self.animate_progress)

────────────────────────────────────────────────────────────────────────────────
FILE: email_options_menu.py
────────────────────────────────────────────────────────────────────────────────
Path: email_options_menu.py
Size: 6.5 KB
Lines: 173 total, 138 non-empty
Characters: 6,473
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # email_options_menu.py
   2: """
   3: Email options popup menu for SuiteView Taskbar
   4: Shows options for viewing received and sent attachments
   5: """
   6: 
   7: import tkinter as tk
   8: from config import Colors, Fonts
   9: from email_menu import EmailAttachmentsMenu
  10: 
  11: class EmailOptionsMenu(tk.Toplevel):
  12:     """Popup menu for email options"""
  13:     
  14:     def __init__(self, parent, x, y, taskbar_instance):
  15:         super().__init__(parent)
  16:         self.parent = parent
  17:         self.taskbar_instance = taskbar_instance
  18:         
  19:         # Window setup
  20:         self.overrideredirect(True)
  21:         self.configure(bg=Colors.DARK_GREEN)
  22:         # NO TOPMOST - This makes everything simpler!
  23:         # self.attributes('-topmost', True)  # REMOVED
  24:         self.attributes('-alpha', 0.98)
  25:         
  26:         # Main container
  27:         self.main_frame = tk.Frame(self, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=2)
  28:         self.main_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
  29:         
  30:         # Create menu items
  31:         self.create_menu_items()
  32:         
  33:         # Update to get proper dimensions
  34:         self.update_idletasks()
  35:         width = max(250, self.winfo_reqwidth())
  36:         height = self.winfo_reqheight()
  37:         
  38:         # Position menu with bottom edge at top of taskbar
  39:         self.geometry(f"{width}x{height}+{x}+{y}")
  40:         
  41:         # Simple focus-based closing
  42:         self.focus_set()
  43:         self.grab_set()  # Grab all mouse/keyboard events
  44:         
  45:         # Bind simple click handler
  46:         self.bind("<Button-1>", self.on_click)
  47:     
  48:     def on_click(self, event):
  49:         """Handle clicks - close if outside menu"""
  50:         # Check if click was on a menu item or the menu itself
  51:         clicked_widget = self.winfo_containing(event.x_root, event.y_root)
  52:         
  53:         if clicked_widget != self:
  54:             # Click was outside - close menu
  55:             self.destroy()
  56:     
  57:     def destroy(self):
  58:         """Clean up and destroy"""
  59:         try:
  60:             self.grab_release()
  61:         except:
  62:             pass
  63:         super().destroy()
  64:     
  65:     def create_menu_items(self):
  66:         """Create the menu options"""
  67:         # Header with larger icon
  68:         header_frame = tk.Frame(self.main_frame, bg=Colors.DARK_GREEN)
  69:         header_frame.pack(fill=tk.X, pady=5)
  70:         
  71:         # Larger icon for header
  72:         header_icon = tk.Label(header_frame, text="📧", 
  73:                              bg=Colors.DARK_GREEN, fg=Colors.WHITE,
  74:                              font=('Arial', 20))
  75:         header_icon.pack(side=tk.LEFT, padx=(10, 5))
  76:         
  77:         header_text = tk.Label(header_frame, text="Email Options", 
  78:                              bg=Colors.DARK_GREEN, fg=Colors.WHITE,
  79:                              font=Fonts.MENU_HEADER)
  80:         header_text.pack(side=tk.LEFT)
  81:         
  82:         # Separator
  83:         separator = tk.Frame(self.main_frame, height=1, bg=Colors.MEDIUM_GREEN)
  84:         separator.pack(fill=tk.X, padx=5, pady=2)
  85:         
  86:         # Menu items container
  87:         items_frame = tk.Frame(self.main_frame, bg=Colors.LIGHT_GREEN)
  88:         items_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
  89:         
  90:         # Attachments Received option with larger icon
  91:         received_item = self.create_menu_item(
  92:             items_frame, 
  93:             "📥",
  94:             "Attachments Received", 
  95:             self.show_received_attachments
  96:         )
  97:         received_item.pack(fill=tk.X, padx=2, pady=1)
  98:         
  99:         # Attachments Sent option with larger icon
 100:         sent_item = self.create_menu_item(
 101:             items_frame, 
 102:             "📤",
 103:             "Attachments Sent", 
 104:             self.show_sent_attachments
 105:         )
 106:         sent_item.pack(fill=tk.X, padx=2, pady=1)
 107:     
 108:     def create_menu_item(self, parent, icon, text, command):
 109:         """Create a single menu item with separate icon and text"""
 110:         item_frame = tk.Frame(parent, bg=Colors.LIGHT_GREEN)
 111:         
 112:         # Large icon on the left
 113:         icon_label = tk.Label(item_frame, text=icon, bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 114:                             font=('Arial', 18), width=2, anchor='center')
 115:         icon_label.pack(side=tk.LEFT, padx=(10, 5))
 116:         
 117:         # Text label
 118:         text_label = tk.Label(item_frame, text=text, bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 119:                             font=Fonts.MENU_ITEM, anchor='w')
 120:         text_label.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
 121:         
 122:         # Hover effect for the entire frame
 123:         def on_enter(e):
 124:             item_frame.configure(bg=Colors.HOVER_GREEN)
 125:             icon_label.configure(bg=Colors.HOVER_GREEN, fg=Colors.WHITE)
 126:             text_label.configure(bg=Colors.HOVER_GREEN, fg=Colors.WHITE)
 127:         
 128:         def on_leave(e):
 129:             item_frame.configure(bg=Colors.LIGHT_GREEN)
 130:             icon_label.configure(bg=Colors.LIGHT_GREEN, fg=Colors.BLACK)
 131:             text_label.configure(bg=Colors.LIGHT_GREEN, fg=Colors.BLACK)
 132:         
 133:         # Bind events to all components
 134:         for widget in [item_frame, icon_label, text_label]:
 135:             widget.bind("<Enter>", on_enter)
 136:             widget.bind("<Leave>", on_leave)
 137:             widget.bind("<Button-1>", lambda e: self.execute_command(command))
 138:             widget.configure(cursor='hand2')
 139:         
 140:         # Set minimum height for the frame
 141:         item_frame.configure(height=35)
 142:         item_frame.pack_propagate(False)
 143:         
 144:         return item_frame
 145:     
 146:     def execute_command(self, command):
 147:         """Execute menu command and close menu"""
 148:         self.destroy()
 149:         command()
 150:     
 151:     def show_received_attachments(self):
 152:         """Show received email attachments"""
 153:         # Get the taskbar instance
 154:         taskbar = self.taskbar_instance
 155:             
 156:         if not hasattr(taskbar, 'email_menu'):
 157:             from email_menu import EmailAttachmentsMenu
 158:             taskbar.email_menu = EmailAttachmentsMenu(taskbar.root)
 159:         
 160:         # Show received attachments (default behavior)
 161:         taskbar.email_menu.show_email_attachments(email_type='received')
 162:     
 163:     def show_sent_attachments(self):
 164:         """Show sent email attachments"""
 165:         # Get the taskbar instance
 166:         taskbar = self.taskbar_instance
 167:             
 168:         if not hasattr(taskbar, 'email_menu'):
 169:             from email_menu import EmailAttachmentsMenu
 170:             taskbar.email_menu = EmailAttachmentsMenu(taskbar.root)
 171:         
 172:         # Show sent attachments
 173:         taskbar.email_menu.show_email_attachments(email_type='sent')

────────────────────────────────────────────────────────────────────────────────
FILE: enhanced_folder_inventory.py
────────────────────────────────────────────────────────────────────────────────
Path: enhanced_folder_inventory.py
Size: 23.5 KB
Lines: 569 total, 459 non-empty
Characters: 23,495
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # enhanced_folder_inventory.py
   2: """
   3: Enhanced Folder Inventory feature for SuiteView Taskbar
   4: Adds View option with Excel-like filtering capabilities
   5: """
   6: 
   7: import os
   8: import threading
   9: import time
  10: from datetime import datetime
  11: from pathlib import Path
  12: import tkinter as tk
  13: from tkinter import ttk, filedialog, messagebox
  14: from openpyxl import Workbook
  15: from openpyxl.styles import Font, PatternFill
  16: import tempfile
  17: import subprocess
  18: from inventory_view_window import InventoryViewWindow
  19: 
  20: from config import Colors, Fonts, Dimensions
  21: from ui_components import CustomDialog, FormField, WarningDialog, ErrorDialog
  22: from utils import UIUtils
  23: 
  24: class FolderInventoryDialog(CustomDialog):
  25:     """Enhanced dialog for configuring folder inventory scan with View/Print options"""
  26:     
  27:     def __init__(self, parent):
  28:         super().__init__(parent, "Folder Inventory", width=500, height=400)
  29:         
  30:         self.selected_folder = ""
  31:         self.scan_thread = None
  32:         self.cancel_scan = False
  33:         self.progress_window = None
  34:         
  35:         self.create_form()
  36:         self.add_buttons()
  37:         
  38:         # Set focus on folder field
  39:         self.folder_field.widget.focus_set()
  40:     
  41:     def create_form(self):
  42:         """Create the configuration form"""
  43:         # Folder selection
  44:         folder_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
  45:         folder_frame.pack(fill=tk.X, pady=5)
  46:         
  47:         self.folder_field = FormField(folder_frame, "Folder to scan:", width=35)
  48:         self.folder_field.pack(side=tk.LEFT, fill=tk.X, expand=True)
  49:         
  50:         browse_btn = tk.Button(folder_frame, text="Browse...", 
  51:                               command=self.browse_folder,
  52:                               bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
  53:                               font=Fonts.DIALOG_BUTTON, cursor='hand2')
  54:         browse_btn.pack(side=tk.RIGHT, padx=(5, 0))
  55:         
  56:         # Depth selection
  57:         self.depth_field = FormField(
  58:             self.dialog_content, "Scan depth:", 
  59:             field_type='combobox',
  60:             values=["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Unlimited"],
  61:             width=15
  62:         )
  63:         self.depth_field.set("1")
  64:         self.depth_field.widget.configure(state='readonly')
  65:         self.depth_field.pack(fill=tk.X, pady=5)
  66:         
  67:         # Content type selection
  68:         content_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
  69:         content_frame.pack(fill=tk.X, pady=10)
  70:         
  71:         tk.Label(content_frame, text="Include:", bg=Colors.LIGHT_GREEN, 
  72:                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).pack(anchor='w')
  73:         
  74:         self.content_type = tk.StringVar(value="both")
  75:         
  76:         radio_frame = tk.Frame(content_frame, bg=Colors.LIGHT_GREEN)
  77:         radio_frame.pack(fill=tk.X, pady=5)
  78:         
  79:         tk.Radiobutton(radio_frame, text="Files Only", variable=self.content_type, 
  80:                       value="files", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
  81:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
  82:         
  83:         tk.Radiobutton(radio_frame, text="Folders Only", variable=self.content_type, 
  84:                       value="folders", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
  85:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
  86:         
  87:         tk.Radiobutton(radio_frame, text="Both", variable=self.content_type, 
  88:                       value="both", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
  89:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
  90:         
  91:         # Output option selection (NEW)
  92:         output_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
  93:         output_frame.pack(fill=tk.X, pady=10)
  94:         
  95:         tk.Label(output_frame, text="Output to:", bg=Colors.LIGHT_GREEN, 
  96:                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).pack(anchor='w')
  97:         
  98:         self.output_type = tk.StringVar(value="view")  # Default to View
  99:         
 100:         output_radio_frame = tk.Frame(output_frame, bg=Colors.LIGHT_GREEN)
 101:         output_radio_frame.pack(fill=tk.X, pady=5)
 102:         
 103:         tk.Radiobutton(output_radio_frame, text="View (Interactive)", variable=self.output_type, 
 104:                       value="view", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 105:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
 106:         
 107:         tk.Radiobutton(output_radio_frame, text="Excel File", variable=self.output_type, 
 108:                       value="excel", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 109:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
 110:         
 111:         # Information text
 112:         info_text = ("View will show results in an interactive grid with filtering.\n"
 113:                     "Excel will create a spreadsheet file.\n"
 114:                     "Large operations (>20,000 items) will show a warning.")
 115:         info_label = tk.Label(self.dialog_content, text=info_text, 
 116:                              bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 117:                              font=(Fonts.DIALOG_LABEL[0], Fonts.DIALOG_LABEL[1]-1),
 118:                              wraplength=450, justify=tk.LEFT)
 119:         info_label.pack(pady=10)
 120:     
 121:     def browse_folder(self):
 122:         """Browse for folder to scan"""
 123:         folder = filedialog.askdirectory(parent=self, title="Select Folder to Inventory")
 124:         if folder:
 125:             self.folder_field.set(folder)
 126:             self.selected_folder = folder
 127:     
 128:     def add_buttons(self):
 129:         """Add Start and Cancel buttons"""
 130:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 131:         button_container.pack(expand=True)
 132:         
 133:         start_btn = tk.Button(button_container, text="Start Scan", 
 134:                              bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 135:                              command=self.start_scan, width=Dimensions.DIALOG_BUTTON_WIDTH,
 136:                              font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1,
 137:                              cursor='hand2')
 138:         start_btn.pack(side=tk.LEFT, padx=10)
 139:         
 140:         cancel_btn = tk.Button(button_container, text="Cancel", 
 141:                               bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 142:                               command=self.cancel, width=Dimensions.DIALOG_BUTTON_WIDTH,
 143:                               font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 144:         cancel_btn.pack(side=tk.LEFT, padx=10)
 145:         
 146:         start_btn.focus_set()
 147:     
 148:     def start_scan(self):
 149:         """Start the folder inventory scan"""
 150:         folder = self.folder_field.get().strip()
 151:         if not folder:
 152:             WarningDialog.show(self, "Invalid Input", "Please select a folder to scan.")
 153:             return
 154:         
 155:         if not os.path.exists(folder):
 156:             ErrorDialog.show(self, "Folder Not Found", f"The selected folder does not exist:\n{folder}")
 157:             return
 158:         
 159:         # Get scan parameters
 160:         depth_str = self.depth_field.get()
 161:         max_depth = None if depth_str == "Unlimited" else int(depth_str)
 162:         content_type = self.content_type.get()
 163:         output_type = self.output_type.get()
 164:         
 165:         # Quick estimation for large operation warning
 166:         if self.should_warn_large_operation(folder, max_depth):
 167:             result = WarningDialog.show(self, "Large Operation Warning", 
 168:                                        "This operation may scan more than 20,000 items and could take several minutes.\n\n"
 169:                                        "Do you want to continue?")
 170:             if not result:
 171:                 return
 172:         
 173:         # Start the scan
 174:         self.destroy()
 175:         self.start_inventory_scan(folder, max_depth, content_type, output_type)
 176:     
 177:     def should_warn_large_operation(self, folder, max_depth):
 178:         """Quick check to estimate if operation will be large"""
 179:         try:
 180:             sample_count = 0
 181:             with os.scandir(folder) as entries:
 182:                 for entry in entries:
 183:                     sample_count += 1
 184:                     if sample_count >= 1000:
 185:                         break
 186:             
 187:             if sample_count >= 1000:
 188:                 return True
 189:             
 190:             if max_depth is None or max_depth > 1:
 191:                 with os.scandir(folder) as entries:
 192:                     for entry in entries:
 193:                         if entry.is_dir():
 194:                             return True
 195:             
 196:             return False
 197:         except:
 198:             return False
 199:     
 200:     def start_inventory_scan(self, folder, max_depth, content_type, output_type):
 201:         """Start the actual inventory scan in background thread"""
 202:         self.cancel_scan = False
 203:         
 204:         # Create progress window
 205:         self.progress_window = ProgressWindow(self.parent, self.cancel_scan_operation)
 206:         
 207:         # Start scan in background thread
 208:         self.scan_thread = threading.Thread(
 209:             target=self.perform_scan,
 210:             args=(folder, max_depth, content_type, output_type),
 211:             daemon=True
 212:         )
 213:         self.scan_thread.start()
 214:     
 215:     def cancel_scan_operation(self):
 216:         """Cancel the running scan operation"""
 217:         self.cancel_scan = True
 218:         if self.progress_window:
 219:             self.progress_window.destroy()
 220:     
 221:     def perform_scan(self, folder, max_depth, content_type, output_type):
 222:         """Perform the actual folder scan (runs in background thread)"""
 223:         try:
 224:             scanner = FolderScanner(folder, max_depth, content_type, self.update_progress)
 225:             inventory_data, error_data = scanner.scan()
 226:             
 227:             if not self.cancel_scan:
 228:                 if output_type == "excel":
 229:                     # Create Excel file (existing functionality)
 230:                     excel_creator = ExcelInventoryCreator()
 231:                     excel_creator.create_workbook(inventory_data, error_data, folder)
 232:                 else:
 233:                     # Show in interactive view (NEW)
 234:                     scan_info = {
 235:                         'folder': folder,
 236:                         'generated': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
 237:                         'total_items': len(inventory_data),
 238:                         'max_depth': max_depth,
 239:                         'content_type': content_type
 240:                     }
 241:                     self.show_inventory_view(inventory_data, error_data, scan_info)
 242:                 
 243:                 # Close progress window
 244:                 if self.progress_window:
 245:                     self.progress_window.after(0, self.progress_window.destroy)
 246:                 
 247:         except Exception as e:
 248:             # Show error in main thread
 249:             if self.progress_window:
 250:                 self.progress_window.after(0, lambda: self.show_scan_error(str(e)))
 251:     
 252:     def show_inventory_view(self, inventory_data, error_data, scan_info):
 253:         """Show the inventory data in an interactive view"""
 254:         if self.progress_window:
 255:             self.progress_window.after(0, lambda: InventoryViewWindow(
 256:                 self.parent, inventory_data, error_data, scan_info))
 257:     
 258:     def update_progress(self, count, current_path):
 259:         """Update progress display (called from background thread)"""
 260:         if self.progress_window and not self.cancel_scan:
 261:             self.progress_window.after(0, lambda: self.progress_window.update_progress(count, current_path))
 262:     
 263:     def show_scan_error(self, error_message):
 264:         """Show scan error (called in main thread)"""
 265:         if self.progress_window:
 266:             self.progress_window.destroy()
 267:         ErrorDialog.show(self.parent, "Scan Error", f"An error occurred during scanning:\n{error_message}")
 268: 
 269: 
 270: class ProgressWindow(CustomDialog):
 271:     """Progress window for folder scanning"""
 272:     
 273:     def __init__(self, parent, cancel_callback):
 274:         super().__init__(parent, "Scanning Folder", width=450, height=200)
 275:         
 276:         self.cancel_callback = cancel_callback
 277:         
 278:         # Progress info
 279:         self.progress_label = tk.Label(self.dialog_content, text="Starting scan...", 
 280:                                       bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 281:                                       font=Fonts.DIALOG_LABEL, wraplength=400)
 282:         self.progress_label.pack(pady=10)
 283:         
 284:         self.count_label = tk.Label(self.dialog_content, text="Items processed: 0", 
 285:                                    bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 286:                                    font=Fonts.DIALOG_LABEL)
 287:         self.count_label.pack(pady=5)
 288:         
 289:         self.path_label = tk.Label(self.dialog_content, text="", 
 290:                                   bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 291:                                   font=(Fonts.DIALOG_LABEL[0], Fonts.DIALOG_LABEL[1]-1),
 292:                                   wraplength=400, anchor='w')
 293:         self.path_label.pack(pady=5, fill=tk.X)
 294:         
 295:         # Cancel button
 296:         cancel_btn = tk.Button(self.button_frame, text="Cancel Scan", 
 297:                               bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 298:                               command=self.cancel_callback, width=12,
 299:                               font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 300:         cancel_btn.pack()
 301:         
 302:         # Override close button to call cancel
 303:         self.protocol("WM_DELETE_WINDOW", self.cancel_callback)
 304:     
 305:     def update_progress(self, count, current_path):
 306:         """Update progress display"""
 307:         self.count_label.config(text=f"Items processed: {count:,}")
 308:         
 309:         # Truncate long paths
 310:         display_path = current_path
 311:         if len(display_path) > 60:
 312:             display_path = "..." + display_path[-57:]
 313:         
 314:         self.path_label.config(text=f"Current: {display_path}")
 315: 
 316: 
 317: class FolderScanner:
 318:     """Core folder scanning logic"""
 319:     
 320:     def __init__(self, root_folder, max_depth, content_type, progress_callback):
 321:         self.root_folder = root_folder
 322:         self.max_depth = max_depth
 323:         self.content_type = content_type
 324:         self.progress_callback = progress_callback
 325:         self.cancel_scan = False
 326:         
 327:         self.inventory_data = []
 328:         self.error_data = []
 329:         self.item_count = 0
 330:     
 331:     def scan(self):
 332:         """Main scan method"""
 333:         self._scan_directory(self.root_folder, 0)
 334:         return self.inventory_data, self.error_data
 335:     
 336:     def _scan_directory(self, directory, current_depth):
 337:         """Recursively scan directory"""
 338:         if self.cancel_scan:
 339:             return
 340:         
 341:         # Check depth limit
 342:         if self.max_depth is not None and current_depth >= self.max_depth:
 343:             return
 344:         
 345:         try:
 346:             with os.scandir(directory) as entries:
 347:                 for entry in entries:
 348:                     if self.cancel_scan:
 349:                         return
 350:                     
 351:                     try:
 352:                         self._process_entry(entry, current_depth)
 353:                     except Exception as e:
 354:                         self._log_error(entry.path, str(e))
 355:                     
 356:                     # Update progress every 100 items
 357:                     if self.item_count % 100 == 0:
 358:                         self.progress_callback(self.item_count, entry.path)
 359:         
 360:         except Exception as e:
 361:             self._log_error(directory, str(e))
 362:     
 363:     def _process_entry(self, entry, current_depth):
 364:         """Process a single file/folder entry"""
 365:         is_file = entry.is_file()
 366:         is_dir = entry.is_dir()
 367:         
 368:         # Check if we should include this type
 369:         if self.content_type == "files" and not is_file:
 370:             pass  # Skip folders
 371:         elif self.content_type == "folders" and not is_dir:
 372:             pass  # Skip files
 373:         else:
 374:             # Include this item
 375:             self._add_inventory_item(entry, is_file)
 376:         
 377:         # Recurse into subdirectories
 378:         if is_dir:
 379:             self._scan_directory(entry.path, current_depth + 1)
 380:     
 381:     def _add_inventory_item(self, entry, is_file):
 382:         """Add item to inventory data"""
 383:         try:
 384:             stat_info = entry.stat()
 385:             
 386:             # Get size (only for files)
 387:             if is_file:
 388:                 size_bytes = stat_info.st_size
 389:                 size_human = self._format_size(size_bytes)
 390:             else:
 391:                 size_bytes = 0
 392:                 size_human = "N/A"
 393:             
 394:             # Get modified date
 395:             modified_date = datetime.fromtimestamp(stat_info.st_mtime).strftime("%Y-%m-%d %H:%M:%S")
 396:             
 397:             item_data = {
 398:                 'Name': entry.name,
 399:                 'Full Path': entry.path,
 400:                 'Type': 'File' if is_file else 'Folder',
 401:                 'Size (Bytes)': size_bytes if is_file else '',
 402:                 'Size': size_human,
 403:                 'Modified Date': modified_date
 404:             }
 405:             
 406:             self.inventory_data.append(item_data)
 407:             self.item_count += 1
 408:             
 409:         except Exception as e:
 410:             self._log_error(entry.path, str(e))
 411:     
 412:     def _format_size(self, bytes_size):
 413:         """Format file size in human readable format"""
 414:         if bytes_size == 0:
 415:             return "0 B"
 416:         
 417:         size_names = ["B", "KB", "MB", "GB", "TB"]
 418:         i = 0
 419:         size = float(bytes_size)
 420:         
 421:         while size >= 1024.0 and i < len(size_names) - 1:
 422:             size /= 1024.0
 423:             i += 1
 424:         
 425:         if i == 0:
 426:             return f"{int(size)} {size_names[i]}"
 427:         else:
 428:             return f"{size:.1f} {size_names[i]}"
 429:     
 430:     def _log_error(self, path, error_message):
 431:         """Log access error"""
 432:         self.error_data.append({
 433:             'Path': path,
 434:             'Error': error_message,
 435:             'Timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
 436:         })
 437: 
 438: 
 439: class ExcelInventoryCreator:
 440:     """Creates Excel workbook with inventory data (existing functionality)"""
 441:     
 442:     def create_workbook(self, inventory_data, error_data, scanned_folder):
 443:         """Create and open Excel workbook"""
 444:         try:
 445:             # Create workbook
 446:             wb = Workbook()
 447:             
 448:             # Create inventory sheet
 449:             ws_inventory = wb.active
 450:             ws_inventory.title = "Inventory"
 451:             self._create_inventory_sheet(ws_inventory, inventory_data, scanned_folder)
 452:             
 453:             # Create errors sheet if there are errors
 454:             if error_data:
 455:                 ws_errors = wb.create_sheet("Access Errors")
 456:                 self._create_errors_sheet(ws_errors, error_data)
 457:             
 458:             # Save to temp file
 459:             temp_dir = tempfile.gettempdir()
 460:             timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
 461:             filename = f"Folder_Inventory_{timestamp}.xlsx"
 462:             filepath = os.path.join(temp_dir, filename)
 463:             
 464:             wb.save(filepath)
 465:             
 466:             # Open in Excel
 467:             self._open_excel_file(filepath)
 468:             
 469:         except Exception as e:
 470:             raise Exception(f"Failed to create Excel file: {str(e)}")
 471:     
 472:     def _create_inventory_sheet(self, worksheet, data, scanned_folder):
 473:         """Create the main inventory sheet"""
 474:         # Header
 475:         worksheet['A1'] = f"Folder Inventory: {scanned_folder}"
 476:         worksheet['A1'].font = Font(bold=True, size=14)
 477:         worksheet['A2'] = f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
 478:         worksheet['A3'] = f"Total Items: {len(data):,}"
 479:         
 480:         # Column headers
 481:         headers = ['Name', 'Full Path', 'Type', 'Size', 'Modified Date']
 482:         for col, header in enumerate(headers, 1):
 483:             cell = worksheet.cell(row=5, column=col, value=header)
 484:             cell.font = Font(bold=True)
 485:             cell.fill = PatternFill(start_color="90EE90", end_color="90EE90", fill_type="solid")
 486:         
 487:         # Data rows
 488:         for row, item in enumerate(data, 6):
 489:             worksheet.cell(row=row, column=1, value=item['Name'])
 490:             worksheet.cell(row=row, column=2, value=item['Full Path'])
 491:             worksheet.cell(row=row, column=3, value=item['Type'])
 492:             worksheet.cell(row=row, column=4, value=item['Size'])
 493:             worksheet.cell(row=row, column=5, value=item['Modified Date'])
 494:         
 495:         # Auto-adjust column widths
 496:         for column in worksheet.columns:
 497:             max_length = 0
 498:             column_letter = column[0].column_letter
 499:             for cell in column:
 500:                 try:
 501:                     if len(str(cell.value)) > max_length:
 502:                         max_length = len(str(cell.value))
 503:                 except:
 504:                     pass
 505:             adjusted_width = min(max_length + 2, 50)
 506:             worksheet.column_dimensions[column_letter].width = adjusted_width
 507:     
 508:     def _create_errors_sheet(self, worksheet, error_data):
 509:         """Create the errors sheet"""
 510:         # Header
 511:         worksheet['A1'] = "Access Errors"
 512:         worksheet['A1'].font = Font(bold=True, size=14)
 513:         worksheet['A2'] = f"Total Errors: {len(error_data)}"
 514:         
 515:         # Column headers
 516:         headers = ['Path', 'Error', 'Timestamp']
 517:         for col, header in enumerate(headers, 1):
 518:             cell = worksheet.cell(row=4, column=col, value=header)
 519:             cell.font = Font(bold=True)
 520:             cell.fill = PatternFill(start_color="FFB6C1", end_color="FFB6C1", fill_type="solid")
 521:         
 522:         # Error rows
 523:         for row, error in enumerate(error_data, 5):
 524:             worksheet.cell(row=row, column=1, value=error['Path'])
 525:             worksheet.cell(row=row, column=2, value=error['Error'])
 526:             worksheet.cell(row=row, column=3, value=error['Timestamp'])
 527:         
 528:         # Auto-adjust column widths
 529:         for column in worksheet.columns:
 530:             max_length = 0
 531:             column_letter = column[0].column_letter
 532:             for cell in column:
 533:                 try:
 534:                     if len(str(cell.value)) > max_length:
 535:                         max_length = len(str(cell.value))
 536:                 except:
 537:                     pass
 538:             adjusted_width = min(max_length + 2, 50)
 539:             worksheet.column_dimensions[column_letter].width = adjusted_width
 540:     
 541:     def _open_excel_file(self, filepath):
 542:         """Open Excel file"""
 543:         try:
 544:             os.startfile(filepath)
 545:         except:
 546:             try:
 547:                 subprocess.run(['start', 'excel', filepath], shell=True)
 548:             except:
 549:                 messagebox.showinfo("File Created", f"Excel file created at:\n{filepath}")
 550: 
 551: 
 552: # Integration function for taskbar.py
 553: def add_folder_inventory_to_taskbar(taskbar_instance):
 554:     """Add Folder Inventory button to the taskbar"""
 555:     
 556:     def show_inventory_dialog():
 557:         """Show the folder inventory dialog"""
 558:         dialog = FolderInventoryDialog(taskbar_instance.root)
 559:         dialog.lift()
 560:         dialog.focus_force()
 561:     
 562:     # Create the inventory button
 563:     inventory_btn = tk.Button(taskbar_instance.main_frame, text="Inventory", 
 564:                              bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 565:                              relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, 
 566:                              cursor='hand2', activebackground=Colors.HOVER_GREEN, 
 567:                              bd=0, padx=15, command=show_inventory_dialog)
 568:     
 569:     return inventory_btn

────────────────────────────────────────────────────────────────────────────────
FILE: explorer_utils.py
────────────────────────────────────────────────────────────────────────────────
Path: explorer_utils.py
Size: 8.9 KB
Lines: 226 total, 183 non-empty
Characters: 8,916
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # explorer_utils.py
   2: """
   3: Utility functions for detecting and interacting with File Explorer windows
   4: """
   5: 
   6: import win32gui
   7: import win32process
   8: import psutil
   9: from pathlib import Path
  10: import os
  11: 
  12: class ExplorerDetector:
  13:     """Utility class for detecting open File Explorer windows"""
  14:     
  15:     @staticmethod
  16:     def get_open_explorer_folders():
  17:         """
  18:         Get a list of currently open File Explorer folder paths
  19:         Returns list of folder paths, ordered by most recently active
  20:         """
  21:         explorer_folders = []
  22:         
  23:         def enum_window_callback(hwnd, folders_list):
  24:             """Callback function for window enumeration"""
  25:             try:
  26:                 # Check if window is visible
  27:                 if not win32gui.IsWindowVisible(hwnd):
  28:                     return True
  29:                 
  30:                 # Get window class name
  31:                 class_name = win32gui.GetClassName(hwnd)
  32:                 
  33:                 # Check if it's a File Explorer window
  34:                 if class_name in ['CabinetWClass', 'ExploreWClass']:
  35:                     # Get process information
  36:                     _, pid = win32process.GetWindowThreadProcessId(hwnd)
  37:                     
  38:                     try:
  39:                         process = psutil.Process(pid)
  40:                         if process.name().lower() == 'explorer.exe':
  41:                             # Try to get the folder path from the window
  42:                             folder_path = ExplorerDetector._get_explorer_path(hwnd)
  43:                             if folder_path and os.path.exists(folder_path):
  44:                                 folders_list.append({
  45:                                     'path': folder_path,
  46:                                     'hwnd': hwnd,
  47:                                     'title': win32gui.GetWindowText(hwnd)
  48:                                 })
  49:                     except (psutil.NoSuchProcess, psutil.AccessDenied):
  50:                         pass
  51:                         
  52:             except Exception as e:
  53:                 print(f"Error processing window {hwnd}: {e}")
  54:                 
  55:             return True
  56:         
  57:         # Enumerate all top-level windows
  58:         win32gui.EnumWindows(enum_window_callback, explorer_folders)
  59:         
  60:         # Sort by Z-order (topmost first) - approximate by hwnd order
  61:         # The most recently active windows typically have higher hwnd values
  62:         explorer_folders.sort(key=lambda x: x['hwnd'], reverse=True)
  63:         
  64:         return [folder['path'] for folder in explorer_folders]
  65:     
  66:     @staticmethod
  67:     def _get_explorer_path(hwnd):
  68:         """
  69:         Extract the current folder path from a File Explorer window
  70:         This uses the window title to determine the path
  71:         """
  72:         try:
  73:             window_title = win32gui.GetWindowText(hwnd)
  74:             
  75:             # File Explorer titles usually contain the folder name
  76:             # Try different approaches to extract the path
  77:             
  78:             # Method 1: Direct path in title (Windows 11 style)
  79:             normalized_title = os.path.normpath(window_title)
  80:             if os.path.exists(normalized_title):
  81:                 return normalized_title
  82:             
  83:             # Method 2: Parse common File Explorer title formats
  84:             # Remove common prefixes/suffixes
  85:             title_cleaned = window_title
  86:             
  87:             # Remove " - File Explorer" suffix if present
  88:             if title_cleaned.endswith(' - File Explorer'):
  89:                 title_cleaned = title_cleaned[:-15]
  90:             
  91:             # Remove " - Windows Explorer" suffix if present  
  92:             if title_cleaned.endswith(' - Windows Explorer'):
  93:                 title_cleaned = title_cleaned[:-18]
  94:             
  95:             # Normalize and check if cleaned title is a valid path
  96:             title_cleaned = os.path.normpath(title_cleaned)
  97:             if os.path.exists(title_cleaned):
  98:                 return title_cleaned
  99:             
 100:             # Method 3: Try to construct common paths
 101:             common_paths = [
 102:                 os.path.expanduser('~'),  # User home
 103:                 os.path.expanduser('~/Desktop'),
 104:                 os.path.expanduser('~/Documents'),
 105:                 os.path.expanduser('~/Downloads'),
 106:                 'C:\\',
 107:                 'D:\\',
 108:             ]
 109:             
 110:             for base_path in common_paths:
 111:                 potential_path = os.path.normpath(os.path.join(base_path, title_cleaned))
 112:                 if os.path.exists(potential_path):
 113:                     return potential_path
 114:             
 115:             # Method 4: Check if it's a special folder name
 116:             special_folders = {
 117:                 'Desktop': os.path.expanduser('~/Desktop'),
 118:                 'Documents': os.path.expanduser('~/Documents'),
 119:                 'Downloads': os.path.expanduser('~/Downloads'),
 120:                 'Pictures': os.path.expanduser('~/Pictures'),
 121:                 'Videos': os.path.expanduser('~/Videos'),
 122:                 'Music': os.path.expanduser('~/Music'),
 123:                 'This PC': os.path.expanduser('~'),
 124:                 'Computer': os.path.expanduser('~'),
 125:             }
 126:             
 127:             if title_cleaned in special_folders:
 128:                 return os.path.normpath(special_folders[title_cleaned])
 129:             
 130:             # Method 5: Advanced COM-based approach (fallback)
 131:             try:
 132:                 return ExplorerDetector._get_explorer_path_com(hwnd)
 133:             except:
 134:                 pass
 135:             
 136:             return None
 137:             
 138:         except Exception as e:
 139:             print(f"Error getting explorer path for window {hwnd}: {e}")
 140:             return None
 141:     
 142:     @staticmethod
 143:     def _get_explorer_path_com(hwnd):
 144:         """
 145:         Use COM interface to get the actual path from File Explorer
 146:         This is more reliable but also more complex
 147:         """
 148:         try:
 149:             import win32com.client
 150:             
 151:             # Get Shell Windows collection
 152:             shell_windows = win32com.client.Dispatch("Shell.Application").Windows()
 153:             
 154:             for window in shell_windows:
 155:                 try:
 156:                     # Check if this window matches our hwnd
 157:                     if hasattr(window, 'HWND') and window.HWND == hwnd:
 158:                         # Get the location URL and convert to path
 159:                         location = window.LocationURL
 160:                         if location.startswith('file:///'):
 161:                             # Convert file URL to local path
 162:                             import urllib.parse
 163:                             path = urllib.parse.unquote(location[8:])  # Remove 'file:///'
 164:                             path = path.replace('/', '\\')  # Convert to Windows path
 165:                             # Normalize the path to fix any mixed slash issues
 166:                             path = os.path.normpath(path)
 167:                             if os.path.exists(path):
 168:                                 return path
 169:                 except:
 170:                     continue
 171:                     
 172:         except Exception as e:
 173:             print(f"COM approach failed: {e}")
 174:             
 175:         return None
 176:     
 177:     @staticmethod
 178:     def get_topmost_explorer_folder():
 179:         """
 180:         Get the path of the topmost (most recently active) File Explorer folder
 181:         Returns None if no File Explorer windows are open
 182:         """
 183:         folders = ExplorerDetector.get_open_explorer_folders()
 184:         return folders[0] if folders else None
 185:     
 186:     @staticmethod
 187:     def get_best_default_folder():
 188:         """
 189:         Get the best folder to use as default for scanning
 190:         Priority: 1) Topmost Explorer folder, 2) User Documents, 3) User Home
 191:         All paths are normalized to use consistent backslashes
 192:         """
 193:         # Try to get topmost explorer folder first
 194:         explorer_folder = ExplorerDetector.get_topmost_explorer_folder()
 195:         if explorer_folder:
 196:             return os.path.normpath(explorer_folder)
 197:         
 198:         # Fallback to Documents folder
 199:         documents_folder = os.path.expanduser('~/Documents')
 200:         if os.path.exists(documents_folder):
 201:             return os.path.normpath(documents_folder)
 202:         
 203:         # Final fallback to user home
 204:         return os.path.normpath(os.path.expanduser('~'))
 205: 
 206: 
 207: # Test function for debugging
 208: def test_explorer_detection():
 209:     """Test function to see what Explorer windows are detected"""
 210:     print("Testing Explorer Detection...")
 211:     
 212:     folders = ExplorerDetector.get_open_explorer_folders()
 213:     print(f"Found {len(folders)} open File Explorer folders:")
 214:     
 215:     for i, folder in enumerate(folders, 1):
 216:         print(f"  {i}. {folder}")
 217:     
 218:     topmost = ExplorerDetector.get_topmost_explorer_folder()
 219:     print(f"\nTopmost folder: {topmost}")
 220:     
 221:     best_default = ExplorerDetector.get_best_default_folder()
 222:     print(f"Best default folder: {best_default}")
 223: 
 224: 
 225: if __name__ == "__main__":
 226:     test_explorer_detection()

────────────────────────────────────────────────────────────────────────────────
FILE: folder_inventory.py
────────────────────────────────────────────────────────────────────────────────
Path: folder_inventory.py
Size: 25.8 KB
Lines: 619 total, 504 non-empty
Characters: 25,829
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # folder_inventory.py (FIXED)
   2: """
   3: Enhanced Folder Inventory feature for SuiteView Taskbar
   4: Updated to work with new InventoryViewWindow pattern
   5: """
   6: 
   7: import os
   8: import threading
   9: import time
  10: from datetime import datetime
  11: from pathlib import Path
  12: import tkinter as tk
  13: from tkinter import ttk, filedialog, messagebox
  14: from openpyxl import Workbook
  15: from openpyxl.styles import Font, PatternFill
  16: import tempfile
  17: import subprocess
  18: from inventory_view_window import InventoryViewWindow
  19: from explorer_utils import ExplorerDetector
  20: 
  21: from config import Colors, Fonts, Dimensions
  22: from ui_components import CustomDialog, FormField, WarningDialog, ErrorDialog
  23: from utils import UIUtils
  24: 
  25: class FolderInventoryDialog(CustomDialog):
  26:     """Enhanced dialog for configuring folder inventory scan with View/Print options"""
  27:     
  28:     def __init__(self, parent):
  29:         super().__init__(parent, "Folder Inventory", width=500, height=400, resizable=True)
  30:         
  31:         self.selected_folder = ""
  32:         self.scan_thread = None
  33:         self.cancel_scan = False
  34:         self.progress_window = None
  35:         
  36:         self.create_form()
  37:         self.add_buttons()
  38:         
  39:         # Auto-populate folder field with topmost Explorer folder (NEW)
  40:         self.auto_populate_folder()
  41:         
  42:         # Set focus on folder field
  43:         self.folder_field.widget.focus_set()
  44:     
  45:     def auto_populate_folder(self):
  46:         """Auto-populate the folder field with the topmost open File Explorer folder"""
  47:         try:
  48:             best_folder = ExplorerDetector.get_best_default_folder()
  49:             if best_folder:
  50:                 self.folder_field.set(best_folder)
  51:                 self.selected_folder = best_folder
  52:         except Exception as e:
  53:             print(f"Error auto-populating folder: {e}")
  54:             # Fallback to user home directory
  55:             try:
  56:                 fallback_folder = os.path.expanduser('~')
  57:                 self.folder_field.set(fallback_folder)
  58:                 self.selected_folder = fallback_folder
  59:             except:
  60:                 pass  # If all else fails, leave empty
  61:         
  62:     def create_form(self):
  63:         """Create the configuration form"""
  64:         # Folder selection using FormField with stacked layout
  65:         folder_container = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
  66:         folder_container.pack(fill=tk.X, pady=(0, 10))
  67:         
  68:         self.folder_field = FormField(folder_container, "Folder to scan:", layout='stacked')
  69:         self.folder_field.pack(side=tk.LEFT, fill=tk.X, expand=True)
  70:         
  71:         browse_btn = tk.Button(folder_container, text="Browse...", 
  72:                             command=self.browse_folder,
  73:                             bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
  74:                             font=Fonts.DIALOG_BUTTON, cursor='hand2')
  75:         browse_btn.pack(side=tk.RIGHT, padx=(5, 0))
  76: 
  77:         # Depth selection
  78:         self.depth_field = FormField(
  79:             self.dialog_content, "Scan depth:", 
  80:             field_type='combobox',
  81:             values=["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Unlimited"],
  82:             width=15
  83:         )
  84:             
  85:         self.depth_field.set("1")
  86:         self.depth_field.widget.configure(state='readonly')
  87:         self.depth_field.pack(fill=tk.X, pady=5)
  88:         
  89:         # Content type selection
  90:         content_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
  91:         content_frame.pack(fill=tk.X, pady=10)
  92:         
  93:         tk.Label(content_frame, text="Include:", bg=Colors.LIGHT_GREEN, 
  94:                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).pack(anchor='w')
  95:         
  96:         self.content_type = tk.StringVar(value="both")
  97:         
  98:         radio_frame = tk.Frame(content_frame, bg=Colors.LIGHT_GREEN)
  99:         radio_frame.pack(fill=tk.X, pady=5)
 100:         
 101:         tk.Radiobutton(radio_frame, text="Files Only", variable=self.content_type, 
 102:                       value="files", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 103:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
 104:         
 105:         tk.Radiobutton(radio_frame, text="Folders Only", variable=self.content_type, 
 106:                       value="folders", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 107:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
 108:         
 109:         tk.Radiobutton(radio_frame, text="Both", variable=self.content_type, 
 110:                       value="both", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 111:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
 112:         
 113:         # Output option selection (NEW)
 114:         output_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
 115:         output_frame.pack(fill=tk.X, pady=10)
 116:         
 117:         tk.Label(output_frame, text="Output to:", bg=Colors.LIGHT_GREEN, 
 118:                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).pack(anchor='w')
 119:         
 120:         self.output_type = tk.StringVar(value="view")  # Default to View
 121:         
 122:         output_radio_frame = tk.Frame(output_frame, bg=Colors.LIGHT_GREEN)
 123:         output_radio_frame.pack(fill=tk.X, pady=5)
 124:         
 125:         tk.Radiobutton(output_radio_frame, text="View (Interactive)", variable=self.output_type, 
 126:                       value="view", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 127:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
 128:         
 129:         tk.Radiobutton(output_radio_frame, text="Excel File", variable=self.output_type, 
 130:                       value="excel", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 131:                       font=Fonts.DIALOG_LABEL, activebackground=Colors.MEDIUM_GREEN).pack(side=tk.LEFT, padx=10)
 132:         
 133:         # Information text
 134:         info_text = ("View will show results in an interactive grid with filtering.\n"
 135:                     "Excel will create a spreadsheet file.\n"
 136:                     "Large operations (>20,000 items) will show a warning.")
 137:         info_label = tk.Label(self.dialog_content, text=info_text, 
 138:                              bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 139:                              font=(Fonts.DIALOG_LABEL[0], Fonts.DIALOG_LABEL[1]-1),
 140:                              wraplength=450, justify=tk.LEFT)
 141:         info_label.pack(pady=10)
 142:     
 143:     def browse_folder(self):
 144:         """Browse for folder to scan"""
 145:         folder = filedialog.askdirectory(parent=self, title="Select Folder to Inventory")
 146:         if folder:
 147:             self.folder_field.set(folder)
 148:             self.selected_folder = folder
 149:     
 150:     def add_buttons(self):
 151:         """Add Start and Cancel buttons"""
 152:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 153:         button_container.pack(expand=True)
 154:         
 155:         start_btn = tk.Button(button_container, text="Start Scan", 
 156:                              bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 157:                              command=self.start_scan, width=Dimensions.DIALOG_BUTTON_WIDTH,
 158:                              font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1,
 159:                              cursor='hand2')
 160:         start_btn.pack(side=tk.LEFT, padx=10)
 161:         
 162:         cancel_btn = tk.Button(button_container, text="Cancel", 
 163:                               bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 164:                               command=self.cancel, width=Dimensions.DIALOG_BUTTON_WIDTH,
 165:                               font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 166:         cancel_btn.pack(side=tk.LEFT, padx=10)
 167:         
 168:         start_btn.focus_set()
 169:     
 170:     def start_scan(self):
 171:         """Start the folder inventory scan"""
 172:         folder = self.folder_field.get().strip()
 173:         if not folder:
 174:             WarningDialog.show(self, "Invalid Input", "Please select a folder to scan.")
 175:             return
 176:         
 177:         if not os.path.exists(folder):
 178:             ErrorDialog.show(self, "Folder Not Found", f"The selected folder does not exist:\n{folder}")
 179:             return
 180:         
 181:         # Get scan parameters
 182:         depth_str = self.depth_field.get()
 183:         max_depth = None if depth_str == "Unlimited" else int(depth_str)
 184:         content_type = self.content_type.get()
 185:         output_type = self.output_type.get()
 186:         
 187:         # Quick estimation for large operation warning
 188:         if self.should_warn_large_operation(folder, max_depth):
 189:             result = WarningDialog.show(self, "Large Operation Warning", 
 190:                                        "This operation may scan more than 20,000 items and could take several minutes.\n\n"
 191:                                        "Do you want to continue?")
 192:             if not result:
 193:                 return
 194:         
 195:         # Start the scan
 196:         self.destroy()
 197:         self.start_inventory_scan(folder, max_depth, content_type, output_type)
 198:     
 199:     def should_warn_large_operation(self, folder, max_depth):
 200:         """Quick check to estimate if operation will be large"""
 201:         try:
 202:             sample_count = 0
 203:             with os.scandir(folder) as entries:
 204:                 for entry in entries:
 205:                     sample_count += 1
 206:                     if sample_count >= 1000:
 207:                         break
 208:             
 209:             if sample_count >= 1000:
 210:                 return True
 211:             
 212:             if max_depth is None or max_depth > 1:
 213:                 with os.scandir(folder) as entries:
 214:                     for entry in entries:
 215:                         if entry.is_dir():
 216:                             return True
 217:             
 218:             return False
 219:         except:
 220:             return False
 221:     
 222:     def start_inventory_scan(self, folder, max_depth, content_type, output_type):
 223:         """Start the actual inventory scan in background thread"""
 224:         self.cancel_scan = False
 225:         
 226:         # Create progress window
 227:         self.progress_window = ProgressWindow(self.parent, self.cancel_scan_operation)
 228:         
 229:         # Start scan in background thread
 230:         self.scan_thread = threading.Thread(
 231:             target=self.perform_scan,
 232:             args=(folder, max_depth, content_type, output_type),
 233:             daemon=True
 234:         )
 235:         self.scan_thread.start()
 236:     
 237:     def cancel_scan_operation(self):
 238:         """Cancel the running scan operation"""
 239:         self.cancel_scan = True
 240:         if self.progress_window:
 241:             self.progress_window.destroy()
 242:     
 243:     def perform_scan(self, folder, max_depth, content_type, output_type):
 244:         """Perform the actual folder scan (runs in background thread)"""
 245:         try:
 246:             scanner = FolderScanner(folder, max_depth, content_type, self.update_progress)
 247:             scanner.cancel_scan = self.cancel_scan  # Pass cancel flag
 248:             inventory_data, error_data = scanner.scan()
 249:             
 250:             if not self.cancel_scan:
 251:                 if output_type == "excel":
 252:                     # Create Excel file (existing functionality)
 253:                     excel_creator = ExcelInventoryCreator()
 254:                     excel_creator.create_workbook(inventory_data, error_data, folder)
 255:                 else:
 256:                     # Show in interactive view (UPDATED)
 257:                     self.show_inventory_view(inventory_data, error_data, folder, max_depth, content_type)
 258:                 
 259:                 # Close progress window
 260:                 if self.progress_window:
 261:                     self.progress_window.after(0, self.progress_window.destroy)
 262:                 
 263:         except Exception as e:
 264:             # Show error in main thread
 265:             if self.progress_window:
 266:                 self.progress_window.after(0, lambda: self.show_scan_error(str(e)))
 267:     
 268:     def show_inventory_view(self, inventory_data, error_data, scanned_folder, max_depth, content_type):
 269:         """Show the inventory data in an interactive view (UPDATED FOR NEW PATTERN)"""
 270:         # Create configuration for the new InventoryViewWindow
 271:         window_config = {
 272:             'title': 'Folder Inventory Results',
 273:             'columns': [
 274:                 {'key': 'Name', 'header': 'Name', 'width': 200, 'type': 'text'},
 275:                 {'key': 'Full Path', 'header': 'Full Path', 'width': 300, 'type': 'text'},
 276:                 {'key': 'Type', 'header': 'Type', 'width': 80, 'type': 'text'},
 277:                 {'key': 'Size', 'header': 'Size', 'width': 100, 'type': 'text'},
 278:                 {'key': 'Modified Date', 'header': 'Modified Date', 'width': 150, 'type': 'date'}
 279:             ],
 280:             'on_item_double_click': self._open_file_or_folder,
 281:             'show_stats': True,
 282:             'allow_export': True,
 283:             'window_width': 1000,
 284:             'window_height': 700,
 285:             'additional_info': {
 286:                 'Scanned Folder': scanned_folder,
 287:                 'Generated': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
 288:                 'Max Depth': max_depth if max_depth else 'Unlimited',
 289:                 'Content Type': content_type.title(),
 290:                 'Errors': len(error_data) if error_data else 0
 291:             }
 292:         }
 293:         
 294:         # Show the inventory view in the main thread
 295:         if self.progress_window:
 296:             self.progress_window.after(0, lambda: InventoryViewWindow(
 297:                 self.parent, inventory_data, window_config))
 298:     
 299:     def _open_file_or_folder(self, item):
 300:         """Handle double-click to open file or folder"""
 301:         try:
 302:             path = item.get('Full Path')
 303:             if path and os.path.exists(path):
 304:                 os.startfile(path)
 305:         except Exception as e:
 306:             print(f"Error opening {path}: {e}")
 307:     
 308:     def update_progress(self, count, current_path):
 309:         """Update progress display (called from background thread)"""
 310:         if self.progress_window and not self.cancel_scan:
 311:             self.progress_window.after(0, lambda: self.progress_window.update_progress(count, current_path))
 312:     
 313:     def show_scan_error(self, error_message):
 314:         """Show scan error (called in main thread)"""
 315:         if self.progress_window:
 316:             self.progress_window.destroy()
 317:         ErrorDialog.show(self.parent, "Scan Error", f"An error occurred during scanning:\n{error_message}")
 318: 
 319: 
 320: class ProgressWindow(CustomDialog):
 321:     """Progress window for folder scanning"""
 322:     
 323:     def __init__(self, parent, cancel_callback):
 324:         super().__init__(parent, "Scanning Folder", width=450, height=200)
 325:         
 326:         self.cancel_callback = cancel_callback
 327:         
 328:         # Progress info
 329:         self.progress_label = tk.Label(self.dialog_content, text="Starting scan...", 
 330:                                       bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 331:                                       font=Fonts.DIALOG_LABEL, wraplength=400)
 332:         self.progress_label.pack(pady=10)
 333:         
 334:         self.count_label = tk.Label(self.dialog_content, text="Items processed: 0", 
 335:                                    bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 336:                                    font=Fonts.DIALOG_LABEL)
 337:         self.count_label.pack(pady=5)
 338:         
 339:         self.path_label = tk.Label(self.dialog_content, text="", 
 340:                                   bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 341:                                   font=(Fonts.DIALOG_LABEL[0], Fonts.DIALOG_LABEL[1]-1),
 342:                                   wraplength=400, anchor='w')
 343:         self.path_label.pack(pady=5, fill=tk.X)
 344:         
 345:         # Cancel button
 346:         cancel_btn = tk.Button(self.button_frame, text="Cancel Scan", 
 347:                               bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 348:                               command=self.cancel_callback, width=12,
 349:                               font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 350:         cancel_btn.pack()
 351:         
 352:         # Override close button to call cancel
 353:         self.protocol("WM_DELETE_WINDOW", self.cancel_callback)
 354:     
 355:     def update_progress(self, count, current_path):
 356:         """Update progress display"""
 357:         self.count_label.config(text=f"Items processed: {count:,}")
 358:         
 359:         # Truncate long paths
 360:         display_path = current_path
 361:         if len(display_path) > 60:
 362:             display_path = "..." + display_path[-57:]
 363:         
 364:         self.path_label.config(text=f"Current: {display_path}")
 365: 
 366: 
 367: class FolderScanner:
 368:     """Core folder scanning logic"""
 369:     
 370:     def __init__(self, root_folder, max_depth, content_type, progress_callback):
 371:         self.root_folder = root_folder
 372:         self.max_depth = max_depth
 373:         self.content_type = content_type
 374:         self.progress_callback = progress_callback
 375:         self.cancel_scan = False
 376:         
 377:         self.inventory_data = []
 378:         self.error_data = []
 379:         self.item_count = 0
 380:     
 381:     def scan(self):
 382:         """Main scan method"""
 383:         self._scan_directory(self.root_folder, 0)
 384:         return self.inventory_data, self.error_data
 385:     
 386:     def _scan_directory(self, directory, current_depth):
 387:         """Recursively scan directory"""
 388:         if self.cancel_scan:
 389:             return
 390:         
 391:         # Check depth limit
 392:         if self.max_depth is not None and current_depth >= self.max_depth:
 393:             return
 394:         
 395:         try:
 396:             with os.scandir(directory) as entries:
 397:                 for entry in entries:
 398:                     if self.cancel_scan:
 399:                         return
 400:                     
 401:                     try:
 402:                         self._process_entry(entry, current_depth)
 403:                     except Exception as e:
 404:                         self._log_error(entry.path, str(e))
 405:                     
 406:                     # Update progress every 100 items
 407:                     if self.item_count % 100 == 0:
 408:                         self.progress_callback(self.item_count, entry.path)
 409:         
 410:         except Exception as e:
 411:             self._log_error(directory, str(e))
 412:     
 413:     def _process_entry(self, entry, current_depth):
 414:         """Process a single file/folder entry"""
 415:         is_file = entry.is_file()
 416:         is_dir = entry.is_dir()
 417:         
 418:         # Check if we should include this type
 419:         if self.content_type == "files" and not is_file:
 420:             pass  # Skip folders
 421:         elif self.content_type == "folders" and not is_dir:
 422:             pass  # Skip files
 423:         else:
 424:             # Include this item
 425:             self._add_inventory_item(entry, is_file)
 426:         
 427:         # Recurse into subdirectories
 428:         if is_dir:
 429:             self._scan_directory(entry.path, current_depth + 1)
 430:     
 431:     def _add_inventory_item(self, entry, is_file):
 432:         """Add item to inventory data"""
 433:         try:
 434:             stat_info = entry.stat()
 435:             
 436:             # Get size (only for files)
 437:             if is_file:
 438:                 size_bytes = stat_info.st_size
 439:                 size_human = self._format_size(size_bytes)
 440:             else:
 441:                 size_bytes = 0
 442:                 size_human = "N/A"
 443:             
 444:             # Get modified date
 445:             modified_date = datetime.fromtimestamp(stat_info.st_mtime).strftime("%Y-%m-%d %H:%M:%S")
 446:             
 447:             item_data = {
 448:                 'Name': entry.name,
 449:                 'Full Path': entry.path,
 450:                 'Type': 'File' if is_file else 'Folder',
 451:                 'Size (Bytes)': size_bytes if is_file else '',
 452:                 'Size': size_human,
 453:                 'Modified Date': modified_date
 454:             }
 455:             
 456:             self.inventory_data.append(item_data)
 457:             self.item_count += 1
 458:             
 459:         except Exception as e:
 460:             self._log_error(entry.path, str(e))
 461:     
 462:     def _format_size(self, bytes_size):
 463:         """Format file size in human readable format"""
 464:         if bytes_size == 0:
 465:             return "0 B"
 466:         
 467:         size_names = ["B", "KB", "MB", "GB", "TB"]
 468:         i = 0
 469:         size = float(bytes_size)
 470:         
 471:         while size >= 1024.0 and i < len(size_names) - 1:
 472:             size /= 1024.0
 473:             i += 1
 474:         
 475:         if i == 0:
 476:             return f"{int(size)} {size_names[i]}"
 477:         else:
 478:             return f"{size:.1f} {size_names[i]}"
 479:     
 480:     def _log_error(self, path, error_message):
 481:         """Log access error"""
 482:         self.error_data.append({
 483:             'Path': path,
 484:             'Error': error_message,
 485:             'Timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
 486:         })
 487: 
 488: 
 489: class ExcelInventoryCreator:
 490:     """Creates Excel workbook with inventory data (existing functionality)"""
 491:     
 492:     def create_workbook(self, inventory_data, error_data, scanned_folder):
 493:         """Create and open Excel workbook"""
 494:         try:
 495:             # Create workbook
 496:             wb = Workbook()
 497:             
 498:             # Create inventory sheet
 499:             ws_inventory = wb.active
 500:             ws_inventory.title = "Inventory"
 501:             self._create_inventory_sheet(ws_inventory, inventory_data, scanned_folder)
 502:             
 503:             # Create errors sheet if there are errors
 504:             if error_data:
 505:                 ws_errors = wb.create_sheet("Access Errors")
 506:                 self._create_errors_sheet(ws_errors, error_data)
 507:             
 508:             # Save to temp file
 509:             temp_dir = tempfile.gettempdir()
 510:             timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
 511:             filename = f"Folder_Inventory_{timestamp}.xlsx"
 512:             filepath = os.path.join(temp_dir, filename)
 513:             
 514:             wb.save(filepath)
 515:             
 516:             # Open in Excel
 517:             self._open_excel_file(filepath)
 518:             
 519:         except Exception as e:
 520:             raise Exception(f"Failed to create Excel file: {str(e)}")
 521:     
 522:     def _create_inventory_sheet(self, worksheet, data, scanned_folder):
 523:         """Create the main inventory sheet"""
 524:         # Header
 525:         worksheet['A1'] = f"Folder Inventory: {scanned_folder}"
 526:         worksheet['A1'].font = Font(bold=True, size=14)
 527:         worksheet['A2'] = f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
 528:         worksheet['A3'] = f"Total Items: {len(data):,}"
 529:         
 530:         # Column headers
 531:         headers = ['Name', 'Full Path', 'Type', 'Size', 'Modified Date']
 532:         for col, header in enumerate(headers, 1):
 533:             cell = worksheet.cell(row=5, column=col, value=header)
 534:             cell.font = Font(bold=True)
 535:             cell.fill = PatternFill(start_color="90EE90", end_color="90EE90", fill_type="solid")
 536:         
 537:         # Data rows
 538:         for row, item in enumerate(data, 6):
 539:             worksheet.cell(row=row, column=1, value=item['Name'])
 540:             worksheet.cell(row=row, column=2, value=item['Full Path'])
 541:             worksheet.cell(row=row, column=3, value=item['Type'])
 542:             worksheet.cell(row=row, column=4, value=item['Size'])
 543:             worksheet.cell(row=row, column=5, value=item['Modified Date'])
 544:         
 545:         # Auto-adjust column widths
 546:         for column in worksheet.columns:
 547:             max_length = 0
 548:             column_letter = column[0].column_letter
 549:             for cell in column:
 550:                 try:
 551:                     if len(str(cell.value)) > max_length:
 552:                         max_length = len(str(cell.value))
 553:                 except:
 554:                     pass
 555:             adjusted_width = min(max_length + 2, 50)
 556:             worksheet.column_dimensions[column_letter].width = adjusted_width
 557:     
 558:     def _create_errors_sheet(self, worksheet, error_data):
 559:         """Create the errors sheet"""
 560:         # Header
 561:         worksheet['A1'] = "Access Errors"
 562:         worksheet['A1'].font = Font(bold=True, size=14)
 563:         worksheet['A2'] = f"Total Errors: {len(error_data)}"
 564:         
 565:         # Column headers
 566:         headers = ['Path', 'Error', 'Timestamp']
 567:         for col, header in enumerate(headers, 1):
 568:             cell = worksheet.cell(row=4, column=col, value=header)
 569:             cell.font = Font(bold=True)
 570:             cell.fill = PatternFill(start_color="FFB6C1", end_color="FFB6C1", fill_type="solid")
 571:         
 572:         # Error rows
 573:         for row, error in enumerate(error_data, 5):
 574:             worksheet.cell(row=row, column=1, value=error['Path'])
 575:             worksheet.cell(row=row, column=2, value=error['Error'])
 576:             worksheet.cell(row=row, column=3, value=error['Timestamp'])
 577:         
 578:         # Auto-adjust column widths
 579:         for column in worksheet.columns:
 580:             max_length = 0
 581:             column_letter = column[0].column_letter
 582:             for cell in column:
 583:                 try:
 584:                     if len(str(cell.value)) > max_length:
 585:                         max_length = len(str(cell.value))
 586:                 except:
 587:                     pass
 588:             adjusted_width = min(max_length + 2, 50)
 589:             worksheet.column_dimensions[column_letter].width = adjusted_width
 590:     
 591:     def _open_excel_file(self, filepath):
 592:         """Open Excel file"""
 593:         try:
 594:             os.startfile(filepath)
 595:         except:
 596:             try:
 597:                 subprocess.run(['start', 'excel', filepath], shell=True)
 598:             except:
 599:                 messagebox.showinfo("File Created", f"Excel file created at:\n{filepath}")
 600: 
 601: 
 602: # Integration function for taskbar.py
 603: def add_folder_inventory_to_taskbar(taskbar_instance):
 604:     """Add Folder Inventory button to the taskbar"""
 605:     
 606:     def show_inventory_dialog():
 607:         """Show the folder inventory dialog"""
 608:         dialog = FolderInventoryDialog(taskbar_instance.root)
 609:         dialog.lift()
 610:         dialog.focus_force()
 611:     
 612:     # Create the inventory button
 613:     inventory_btn = tk.Button(taskbar_instance.main_frame, text="Inventory", 
 614:                              bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 615:                              relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, 
 616:                              cursor='hand2', activebackground=Colors.HOVER_GREEN, 
 617:                              bd=0, padx=15, command=show_inventory_dialog)
 618:     
 619:     return inventory_btn

────────────────────────────────────────────────────────────────────────────────
FILE: inventory_view_examples.py
────────────────────────────────────────────────────────────────────────────────
Path: inventory_view_examples.py
Size: 10.5 KB
Lines: 299 total, 263 non-empty
Characters: 10,493
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # inventory_view_examples.py
   2: """
   3: Examples of using the reusable InventoryViewWindow pattern
   4: Shows how to use it for different types of data throughout the SuiteView application
   5: """
   6: 
   7: from inventory_view_window import InventoryViewWindow
   8: import tkinter as tk
   9: from datetime import datetime, timedelta
  10: import random
  11: 
  12: # Example 1: Email Attachments (as implemented)
  13: def show_email_attachments(parent_window):
  14:     """Example of showing email attachments"""
  15:     # Sample email data
  16:     email_data = [
  17:         {
  18:             'Date': '2025-06-28 10:30',
  19:             'From': 'John Smith',
  20:             'Subject': 'Q2 Financial Report',
  21:             'Attachments': 'Q2_Report.pdf, Q2_Summary.xlsx',
  22:             'AttachmentCount': 2,
  23:             'EntryID': 'EMAIL001'
  24:         },
  25:         {
  26:             'Date': '2025-06-27 14:15',
  27:             'From': 'Mary Johnson',
  28:             'Subject': 'Project Update - Screenshots',
  29:             'Attachments': 'screenshot1.png, screenshot2.png, diagram.vsd',
  30:             'AttachmentCount': 3,
  31:             'EntryID': 'EMAIL002'
  32:         }
  33:     ]
  34:     
  35:     config = {
  36:         'title': 'Email Attachments',
  37:         'columns': [
  38:             {'key': 'Date', 'header': 'Date', 'width': 120, 'type': 'date'},
  39:             {'key': 'From', 'header': 'From', 'width': 200, 'type': 'text'},
  40:             {'key': 'Subject', 'header': 'Subject', 'width': 300, 'type': 'text'},
  41:             {'key': 'Attachments', 'header': 'Attachments', 'width': 250, 'type': 'text'},
  42:             {'key': 'AttachmentCount', 'header': 'Count', 'width': 60, 'type': 'number'}
  43:         ],
  44:         'on_item_double_click': lambda item: print(f"Opening email: {item['Subject']}"),
  45:         'window_width': 1100,
  46:         'window_height': 600
  47:     }
  48:     
  49:     InventoryViewWindow(parent_window, email_data, config)
  50: 
  51: 
  52: # Example 2: Process Monitor
  53: def show_process_monitor(parent_window):
  54:     """Example of showing running processes"""
  55:     # Sample process data
  56:     process_data = [
  57:         {
  58:             'ProcessName': 'chrome.exe',
  59:             'PID': 1234,
  60:             'Memory': 512000000,  # bytes
  61:             'CPU': 15.2,
  62:             'Status': 'Running',
  63:             'User': 'CurrentUser'
  64:         },
  65:         {
  66:             'ProcessName': 'excel.exe',
  67:             'PID': 5678,
  68:             'Memory': 256000000,
  69:             'CPU': 2.5,
  70:             'Status': 'Running',
  71:             'User': 'CurrentUser'
  72:         }
  73:     ]
  74:     
  75:     # Add formatted memory column
  76:     for proc in process_data:
  77:         proc['MemoryMB'] = f"{proc['Memory'] / (1024*1024):.1f} MB"
  78:     
  79:     config = {
  80:         'title': 'Process Monitor',
  81:         'columns': [
  82:             {'key': 'ProcessName', 'header': 'Process', 'width': 150, 'type': 'text'},
  83:             {'key': 'PID', 'header': 'PID', 'width': 80, 'type': 'number'},
  84:             {'key': 'MemoryMB', 'header': 'Memory', 'width': 100, 'type': 'text'},
  85:             {'key': 'CPU', 'header': 'CPU %', 'width': 80, 'type': 'number'},
  86:             {'key': 'Status', 'header': 'Status', 'width': 100, 'type': 'text'},
  87:             {'key': 'User', 'header': 'User', 'width': 120, 'type': 'text'}
  88:         ],
  89:         'on_item_double_click': lambda item: print(f"Process details: {item['ProcessName']}"),
  90:         'window_width': 800,
  91:         'window_height': 500,
  92:         'additional_info': {
  93:             'Total Processes': len(process_data),
  94:             'Last Update': datetime.now().strftime('%H:%M:%S')
  95:         }
  96:     }
  97:     
  98:     InventoryViewWindow(parent_window, process_data, config)
  99: 
 100: 
 101: # Example 3: Network Connections
 102: def show_network_connections(parent_window):
 103:     """Example of showing network connections"""
 104:     connection_data = [
 105:         {
 106:             'LocalAddress': '192.168.1.100:443',
 107:             'RemoteAddress': '142.250.80.46:80',
 108:             'Protocol': 'TCP',
 109:             'State': 'ESTABLISHED',
 110:             'Process': 'chrome.exe',
 111:             'BytesSent': 1024000,
 112:             'BytesReceived': 5120000
 113:         },
 114:         {
 115:             'LocalAddress': '192.168.1.100:1433',
 116:             'RemoteAddress': '10.0.0.5:1433',
 117:             'Protocol': 'TCP',
 118:             'State': 'ESTABLISHED',
 119:             'Process': 'sqlservr.exe',
 120:             'BytesSent': 512000,
 121:             'BytesReceived': 256000
 122:         }
 123:     ]
 124:     
 125:     config = {
 126:         'title': 'Network Connections',
 127:         'columns': [
 128:             {'key': 'LocalAddress', 'header': 'Local Address', 'width': 150, 'type': 'text'},
 129:             {'key': 'RemoteAddress', 'header': 'Remote Address', 'width': 150, 'type': 'text'},
 130:             {'key': 'Protocol', 'header': 'Protocol', 'width': 80, 'type': 'text'},
 131:             {'key': 'State', 'header': 'State', 'width': 120, 'type': 'text'},
 132:             {'key': 'Process', 'header': 'Process', 'width': 120, 'type': 'text'},
 133:             {'key': 'BytesSent', 'header': 'Sent', 'width': 100, 'type': 'number'},
 134:             {'key': 'BytesReceived', 'header': 'Received', 'width': 100, 'type': 'number'}
 135:         ],
 136:         'window_width': 900,
 137:         'window_height': 500
 138:     }
 139:     
 140:     InventoryViewWindow(parent_window, connection_data, config)
 141: 
 142: 
 143: # Example 4: Recent Documents
 144: def show_recent_documents(parent_window):
 145:     """Example of showing recent documents"""
 146:     doc_data = [
 147:         {
 148:             'FileName': 'Budget_2025.xlsx',
 149:             'Type': 'Excel',
 150:             'Modified': '2025-06-28 09:15:00',
 151:             'Size': 1048576,
 152:             'Path': 'C:\\Documents\\Finance\\Budget_2025.xlsx',
 153:             'Author': 'John Doe'
 154:         },
 155:         {
 156:             'FileName': 'Presentation_Q2.pptx',
 157:             'Type': 'PowerPoint',
 158:             'Modified': '2025-06-27 16:30:00',
 159:             'Size': 5242880,
 160:             'Path': 'C:\\Documents\\Presentations\\Presentation_Q2.pptx',
 161:             'Author': 'Jane Smith'
 162:         }
 163:     ]
 164:     
 165:     # Add formatted size
 166:     for doc in doc_data:
 167:         doc['SizeFormatted'] = f"{doc['Size'] / (1024*1024):.1f} MB"
 168:     
 169:     config = {
 170:         'title': 'Recent Documents',
 171:         'columns': [
 172:             {'key': 'FileName', 'header': 'File Name', 'width': 200, 'type': 'text'},
 173:             {'key': 'Type', 'header': 'Type', 'width': 100, 'type': 'text'},
 174:             {'key': 'Modified', 'header': 'Last Modified', 'width': 150, 'type': 'date'},
 175:             {'key': 'SizeFormatted', 'header': 'Size', 'width': 80, 'type': 'text'},
 176:             {'key': 'Author', 'header': 'Author', 'width': 120, 'type': 'text'},
 177:             {'key': 'Path', 'header': 'Location', 'width': 300, 'type': 'text'}
 178:         ],
 179:         'on_item_double_click': lambda item: print(f"Opening: {item['Path']}"),
 180:         'window_width': 1000,
 181:         'window_height': 500
 182:     }
 183:     
 184:     InventoryViewWindow(parent_window, doc_data, config)
 185: 
 186: 
 187: # Example 5: Task List / To-Do Items
 188: def show_task_list(parent_window):
 189:     """Example of showing a task list"""
 190:     task_data = [
 191:         {
 192:             'TaskID': 1,
 193:             'Title': 'Complete quarterly report',
 194:             'Priority': 'High',
 195:             'Status': 'In Progress',
 196:             'DueDate': '2025-06-30',
 197:             'AssignedTo': 'John Doe',
 198:             'Category': 'Finance',
 199:             'Progress': 75
 200:         },
 201:         {
 202:             'TaskID': 2,
 203:             'Title': 'Review budget proposals',
 204:             'Priority': 'Medium',
 205:             'Status': 'Not Started',
 206:             'DueDate': '2025-07-05',
 207:             'AssignedTo': 'Jane Smith',
 208:             'Category': 'Finance',
 209:             'Progress': 0
 210:         }
 211:     ]
 212:     
 213:     config = {
 214:         'title': 'Task Management',
 215:         'columns': [
 216:             {'key': 'TaskID', 'header': 'ID', 'width': 50, 'type': 'number'},
 217:             {'key': 'Title', 'header': 'Task', 'width': 250, 'type': 'text'},
 218:             {'key': 'Priority', 'header': 'Priority', 'width': 80, 'type': 'text'},
 219:             {'key': 'Status', 'header': 'Status', 'width': 100, 'type': 'text'},
 220:             {'key': 'DueDate', 'header': 'Due Date', 'width': 100, 'type': 'date'},
 221:             {'key': 'AssignedTo', 'header': 'Assigned To', 'width': 120, 'type': 'text'},
 222:             {'key': 'Category', 'header': 'Category', 'width': 100, 'type': 'text'},
 223:             {'key': 'Progress', 'header': 'Progress %', 'width': 80, 'type': 'number'}
 224:         ],
 225:         'on_item_double_click': lambda item: print(f"Edit task: {item['Title']}"),
 226:         'window_width': 900,
 227:         'window_height': 500,
 228:         'additional_info': {
 229:             'Total Tasks': len(task_data),
 230:             'High Priority': len([t for t in task_data if t['Priority'] == 'High'])
 231:         }
 232:     }
 233:     
 234:     InventoryViewWindow(parent_window, task_data, config)
 235: 
 236: 
 237: # Example 6: Using auto-generated columns (no configuration)
 238: def show_auto_columns(parent_window):
 239:     """Example of using auto-generated columns"""
 240:     # Simple data - columns will be auto-generated
 241:     simple_data = [
 242:         {
 243:             'name': 'Item 1',
 244:             'value': 100,
 245:             'date_created': '2025-06-28',
 246:             'active': 'Yes'
 247:         },
 248:         {
 249:             'name': 'Item 2',
 250:             'value': 200,
 251:             'date_created': '2025-06-27',
 252:             'active': 'No'
 253:         }
 254:     ]
 255:     
 256:     # Minimal configuration - columns will be auto-generated
 257:     config = {
 258:         'title': 'Auto-Generated Columns Example',
 259:         'window_width': 600,
 260:         'window_height': 400
 261:     }
 262:     
 263:     InventoryViewWindow(parent_window, simple_data, config)
 264: 
 265: 
 266: # Test function to demonstrate all examples
 267: def test_inventory_views():
 268:     """Test function to demonstrate all inventory view examples"""
 269:     root = tk.Tk()
 270:     root.withdraw()  # Hide the root window
 271:     
 272:     # Create a simple menu to launch different examples
 273:     menu_window = tk.Toplevel(root)
 274:     menu_window.title("Inventory View Examples")
 275:     menu_window.geometry("300x400")
 276:     
 277:     examples = [
 278:         ("Email Attachments", show_email_attachments),
 279:         ("Process Monitor", show_process_monitor),
 280:         ("Network Connections", show_network_connections),
 281:         ("Recent Documents", show_recent_documents),
 282:         ("Task List", show_task_list),
 283:         ("Auto Columns", show_auto_columns)
 284:     ]
 285:     
 286:     tk.Label(menu_window, text="Click to view examples:", font=('Arial', 12, 'bold')).pack(pady=10)
 287:     
 288:     for title, func in examples:
 289:         btn = tk.Button(menu_window, text=title, width=25,
 290:                        command=lambda f=func: f(root))
 291:         btn.pack(pady=5)
 292:     
 293:     tk.Button(menu_window, text="Exit", width=25, command=root.quit).pack(pady=20)
 294:     
 295:     root.mainloop()
 296: 
 297: 
 298: if __name__ == "__main__":
 299:     test_inventory_views()

────────────────────────────────────────────────────────────────────────────────
FILE: inventory_view_window.py
────────────────────────────────────────────────────────────────────────────────
Path: inventory_view_window.py
Size: 32.0 KB
Lines: 757 total, 615 non-empty
Characters: 31,998
Type: Inventory view window and filtering
────────────────────────────────────────────────────────────────────────────────

   1: # inventory_view_window.py
   2: """
   3: Interactive inventory view window with Excel-like filtering capabilities
   4: This component is designed to be reused throughout the SuiteView project for displaying any tabular data
   5: """
   6: 
   7: import tkinter as tk
   8: from tkinter import ttk, messagebox
   9: from datetime import datetime
  10: from config import Colors, Fonts, Dimensions
  11: from ui_components import CustomDialog
  12: from typing import Any
  13: 
  14: class InventoryViewWindow(tk.Toplevel):
  15:     """
  16:     Reusable interactive window for viewing any tabular data with Excel-like filtering
  17:     
  18:     Args:
  19:         parent: Parent window
  20:         data: List of dictionaries containing the data to display
  21:         window_config: Configuration dictionary with:
  22:             - title: Window title (default: "Data View")
  23:             - columns: List of column configurations, each with:
  24:                 - key: Dictionary key for this column
  25:                 - header: Display name for column header
  26:                 - width: Column width (default: 100)
  27:                 - type: Data type ('text', 'number', 'date') for sorting (default: 'text')
  28:             - on_item_click: Callback function(item) when item is clicked
  29:             - on_item_double_click: Callback function(item) when item is double-clicked
  30:             - show_stats: Whether to show statistics (default: True)
  31:             - allow_export: Whether to allow Excel export (default: True)
  32:             - window_width: Initial window width (default: 1000)
  33:             - window_height: Initial window height (default: 700)
  34:             - additional_info: Dict of additional info to display in header
  35:     """
  36:     
  37:     def __init__(self, parent, data: list[dict[str, Any]], window_config: dict | None = None):
  38:         super().__init__(parent)
  39:         self.parent = parent
  40:         self.original_data = data.copy() if data else []
  41:         self.filtered_data = self.original_data.copy()
  42:         
  43:         # Parse configuration
  44:         config = window_config or {}
  45:         self.window_title = config.get('title', 'Data View')
  46:         self.column_configs = config.get('columns', self._auto_generate_columns())
  47:         self.on_item_click = config.get('on_item_click')
  48:         self.on_item_double_click = config.get('on_item_double_click')
  49:         self.show_stats = config.get('show_stats', True)
  50:         self.allow_export = config.get('allow_export', True)
  51:         self.window_width = config.get('window_width', 1000)
  52:         self.window_height = config.get('window_height', 700)
  53:         self.additional_info = config.get('additional_info', {})
  54:         
  55:         # Extract column information
  56:         self.columns = [col['key'] for col in self.column_configs]
  57:         self.column_headers = {col['key']: col.get('header', col['key']) for col in self.column_configs}
  58:         self.column_widths = {col['key']: col.get('width', 100) for col in self.column_configs}
  59:         self.column_types = {col['key']: col.get('type', 'text') for col in self.column_configs}
  60:         
  61:         # Filter state tracking
  62:         self.active_filters = {}
  63:         self.column_unique_values = {}
  64:         
  65:         # Window setup
  66:         self.overrideredirect(True)
  67:         self.configure(bg=Colors.DARK_GREEN)
  68:         self.attributes('-topmost', True)
  69:         self.geometry(f"{self.window_width}x{self.window_height}")
  70:         
  71:         # Initialize drag variables
  72:         self.is_dragging = False
  73:         self.drag_start_x = 0
  74:         self.drag_start_y = 0
  75:         
  76:         # Main container
  77:         self.main_frame = tk.Frame(self, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=2)
  78:         self.main_frame.pack(fill=tk.BOTH, expand=True, padx=3, pady=3)
  79:         
  80:         # Create UI components
  81:         self.create_custom_title_bar()
  82:         self.content_frame = tk.Frame(self.main_frame, bg=Colors.LIGHT_GREEN)
  83:         self.content_frame.pack(fill=tk.BOTH, expand=True)
  84:         
  85:         self.create_header()
  86:         self.create_data_grid()
  87:         self.create_footer()
  88:         
  89:         # Populate and center
  90:         self.populate_grid()
  91:         self.update_stats()
  92:         self.center_window()
  93:         
  94:         # Bind close event
  95:         self.protocol("WM_DELETE_WINDOW", self.on_closing)
  96:     
  97:     def _auto_generate_columns(self) -> list[dict]:
  98:         """Auto-generate column configuration from data"""
  99:         if not self.original_data:
 100:             return []
 101:         
 102:         # Get all unique keys from data
 103:         all_keys = set()
 104:         for item in self.original_data:
 105:             all_keys.update(item.keys())
 106:         
 107:         # Create column config for each key
 108:         columns = []
 109:         for key in sorted(all_keys):
 110:             columns.append({
 111:                 'key': key,
 112:                 'header': key.replace('_', ' ').title(),
 113:                 'width': 150,
 114:                 'type': self._guess_column_type(key)
 115:             })
 116:         
 117:         return columns
 118:     
 119:     def _guess_column_type(self, key: str) -> str:
 120:         """Guess column type based on key name and sample data"""
 121:         key_lower = key.lower()
 122:         
 123:         # Check key name patterns
 124:         if any(word in key_lower for word in ['date', 'time', 'created', 'modified', 'updated']):
 125:             return 'date'
 126:         elif any(word in key_lower for word in ['count', 'number', 'size', 'bytes', 'id', 'qty', 'quantity']):
 127:             return 'number'
 128:         
 129:         # Check sample data
 130:         sample_values = []
 131:         for item in self.original_data[:10]:  # Check first 10 items
 132:             if key in item and item[key] is not None:
 133:                 sample_values.append(item[key])
 134:         
 135:         if sample_values:
 136:             # Check if all values are numeric
 137:             try:
 138:                 for val in sample_values:
 139:                     float(str(val).replace(',', ''))
 140:                 return 'number'
 141:             except:
 142:                 pass
 143:         
 144:         return 'text'
 145:     
 146:     def create_custom_title_bar(self):
 147:         """Create custom title bar matching other windows' style"""
 148:         self.title_frame = tk.Frame(self.main_frame, bg=Colors.DARK_GREEN, height=25)
 149:         self.title_frame.pack(fill=tk.X)
 150:         self.title_frame.pack_propagate(False)
 151:         
 152:         # Drag handle
 153:         drag_handle = tk.Label(self.title_frame, text="⋮⋮⋮", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 154:                               font=('Arial', 8), cursor='fleur')
 155:         drag_handle.pack(side=tk.LEFT, padx=3, pady=3)
 156:         
 157:         # Title with icon
 158:         icon = "📊" if "email" in self.window_title.lower() else "📁"
 159:         title_label = tk.Label(self.title_frame, text=f"{icon} {self.window_title}", 
 160:                               bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 161:                               font=Fonts.DIALOG_TITLE, cursor='fleur')
 162:         title_label.pack(side=tk.LEFT, padx=5, pady=3)
 163:         
 164:         # Close button
 165:         close_btn = tk.Label(self.title_frame, text="×", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 166:                             font=('Arial', 12, 'bold'), cursor='hand2')
 167:         close_btn.pack(side=tk.RIGHT, padx=5)
 168:         close_btn.bind("<Button-1>", lambda e: self.on_closing())
 169:         
 170:         # Bind drag events
 171:         for widget in [self.title_frame, drag_handle, title_label]:
 172:             widget.bind("<Button-1>", self.start_drag)
 173:             widget.bind("<B1-Motion>", self.do_drag)
 174:             widget.bind("<ButtonRelease-1>", self.end_drag)
 175:     
 176:     def create_header(self):
 177:         """Create header with information"""
 178:         header_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN, relief=tk.RAISED, bd=1)
 179:         header_frame.pack(fill=tk.X, padx=2, pady=2)
 180:         
 181:         # Title
 182:         title_label = tk.Label(header_frame, text=self.window_title, 
 183:                               bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 184:                               font=('Arial', 14, 'bold'))
 185:         title_label.pack(pady=5)
 186:         
 187:         # Additional information
 188:         if self.additional_info:
 189:             info_frame = tk.Frame(header_frame, bg=Colors.LIGHT_GREEN)
 190:             info_frame.pack(pady=5)
 191:             
 192:             col = 0
 193:             for key, value in self.additional_info.items():
 194:                 tk.Label(info_frame, text=f"{key}:", bg=Colors.LIGHT_GREEN, 
 195:                         fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).grid(row=0, column=col, sticky='w', padx=5)
 196:                 tk.Label(info_frame, text=str(value), bg=Colors.LIGHT_GREEN, 
 197:                         fg=Colors.DARK_GREEN, font=Fonts.DIALOG_LABEL).grid(row=0, column=col+1, sticky='w', padx=5)
 198:                 col += 2
 199:         
 200:         # Stats label
 201:         if self.show_stats:
 202:             self.stats_label = tk.Label(header_frame, text="", bg=Colors.LIGHT_GREEN, 
 203:                                        fg=Colors.BLACK, font=Fonts.DIALOG_LABEL)
 204:             self.stats_label.pack(pady=5)
 205:     
 206:     def create_data_grid(self):
 207:         """Create the main data grid with filtering"""
 208:         grid_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN, relief=tk.SUNKEN, bd=1)
 209:         grid_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
 210:         
 211:         # Create Treeview
 212:         self.tree = ttk.Treeview(grid_frame, show='tree headings')
 213:         self.tree['columns'] = self.columns
 214:         
 215:         # Configure columns
 216:         self.tree.column('#0', width=0, stretch=False)
 217:         self.tree.heading('#0', text='')
 218:         
 219:         for col in self.columns:
 220:             self.tree.column(col, width=self.column_widths.get(col, 100), anchor='w')
 221:             header_text = self.column_headers.get(col, col)
 222:             self.tree.heading(col, text=header_text, command=lambda c=col: self.show_filter_menu(c))
 223:         
 224:         # Scrollbars
 225:         v_scrollbar = ttk.Scrollbar(grid_frame, orient=tk.VERTICAL, command=self.tree.yview)
 226:         h_scrollbar = ttk.Scrollbar(grid_frame, orient=tk.HORIZONTAL, command=self.tree.xview)
 227:         self.tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
 228:         
 229:         # Pack components
 230:         self.tree.grid(row=0, column=0, sticky='nsew')
 231:         v_scrollbar.grid(row=0, column=1, sticky='ns')
 232:         h_scrollbar.grid(row=1, column=0, sticky='ew')
 233:         
 234:         grid_frame.grid_rowconfigure(0, weight=1)
 235:         grid_frame.grid_columnconfigure(0, weight=1)
 236:         
 237:         # Style
 238:         style = ttk.Style()
 239:         style.configure('Treeview', background=Colors.LIGHT_GREEN, 
 240:                        foreground=Colors.BLACK, fieldbackground=Colors.LIGHT_GREEN)
 241:         style.configure('Treeview.Heading', background=Colors.MEDIUM_GREEN,
 242:                        foreground=Colors.BLACK, font=Fonts.MENU_HEADER)
 243:         
 244:         # Bind click events
 245:         if self.on_item_click:
 246:             self.tree.bind('<ButtonRelease-1>', self._handle_item_click)
 247:         if self.on_item_double_click:
 248:             self.tree.bind('<Double-Button-1>', self._handle_item_double_click)
 249:     
 250:     def _handle_item_click(self, event):
 251:         """Handle single click on item with column detection"""
 252:         selection = self.tree.selection()
 253:         if selection and self.on_item_click:
 254:             item_id = selection[0]
 255:             item_index = self.tree.index(item_id)
 256:             
 257:             if 0 <= item_index < len(self.filtered_data):
 258:                 # Determine which column was clicked
 259:                 column_id = self.tree.identify_column(event.x)
 260:                 
 261:                 # Convert column id (#1, #2, etc.) to column index
 262:                 if column_id:
 263:                     try:
 264:                         col_index = int(column_id.replace('#', '')) - 1
 265:                         if 0 <= col_index < len(self.columns):
 266:                             column_key = self.columns[col_index]
 267:                             # Pass both item and column to callback
 268:                             if hasattr(self.on_item_click, '__code__') and self.on_item_click.__code__.co_argcount > 2:
 269:                                 # New style callback with column info
 270:                                 self.on_item_click(self.filtered_data[item_index], column_key)
 271:                             else:
 272:                                 # Old style callback without column info
 273:                                 self.on_item_click(self.filtered_data[item_index])
 274:                     except:
 275:                         # Fallback to just item
 276:                         self.on_item_click(self.filtered_data[item_index])
 277:     
 278:     def _handle_item_double_click(self, event):
 279:         """Handle double click on item"""
 280:         selection = self.tree.selection()
 281:         if selection and self.on_item_double_click:
 282:             item_id = selection[0]
 283:             item_index = self.tree.index(item_id)
 284:             if 0 <= item_index < len(self.filtered_data):
 285:                 self.on_item_double_click(self.filtered_data[item_index])
 286:     
 287:     def create_footer(self):
 288:         """Create footer with action buttons and filter status"""
 289:         footer_frame = tk.Frame(self.content_frame, bg=Colors.DARK_GREEN, height=50)
 290:         footer_frame.pack(fill=tk.X, side=tk.BOTTOM, padx=2, pady=2)
 291:         footer_frame.pack_propagate(False)
 292:         
 293:         # Filter status
 294:         filter_frame = tk.Frame(footer_frame, bg=Colors.DARK_GREEN)
 295:         filter_frame.pack(side=tk.LEFT, fill=tk.Y)
 296:         
 297:         self.filter_status_label = tk.Label(filter_frame, text="No filters applied", 
 298:                                            bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 299:                                            font=Fonts.MENU_ITEM)
 300:         self.filter_status_label.pack(side=tk.LEFT, padx=10, pady=5)
 301:         
 302:         # Action buttons
 303:         button_frame = tk.Frame(footer_frame, bg=Colors.DARK_GREEN)
 304:         button_frame.pack(side=tk.RIGHT, fill=tk.Y)
 305:         
 306:         # Clear Filters
 307:         clear_btn = tk.Button(button_frame, text="Clear All Filters", 
 308:                              bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 309:                              relief=tk.RAISED, bd=1, cursor='hand2',
 310:                              font=Fonts.MENU_ITEM, padx=10,
 311:                              command=self.clear_all_filters)
 312:         clear_btn.pack(side=tk.LEFT, padx=5, pady=5)
 313:         
 314:         # Export to Excel (if enabled)
 315:         if self.allow_export:
 316:             export_btn = tk.Button(button_frame, text="Export to Excel", 
 317:                                   bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 318:                                   relief=tk.RAISED, bd=1, cursor='hand2',
 319:                                   font=Fonts.MENU_ITEM, padx=10,
 320:                                   command=self.export_to_excel)
 321:             export_btn.pack(side=tk.LEFT, padx=5, pady=5)
 322:         
 323:         # Close button
 324:         close_btn = tk.Button(button_frame, text="Close", 
 325:                              bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 326:                              relief=tk.RAISED, bd=1, cursor='hand2',
 327:                              font=Fonts.MENU_ITEM, padx=10,
 328:                              command=self.on_closing)
 329:         close_btn.pack(side=tk.LEFT, padx=5, pady=5)
 330:     
 331:     def populate_grid(self):
 332:         """Populate the grid with current filtered data"""
 333:         # Clear existing items
 334:         for item in self.tree.get_children():
 335:             self.tree.delete(item)
 336:         
 337:         # Add filtered data
 338:         for item in self.filtered_data:
 339:             values = []
 340:             for col in self.columns:
 341:                 value = item.get(col, '')
 342:                 # Format based on type
 343:                 if self.column_types.get(col) == 'number' and value != '':
 344:                     try:
 345:                         # Format numbers with commas
 346:                         if isinstance(value, (int, float)):
 347:                             value = f"{value:,}"
 348:                     except:
 349:                         pass
 350:                 values.append(str(value))
 351:             
 352:             self.tree.insert('', 'end', values=values)
 353:         
 354:         # Calculate unique values
 355:         self.calculate_unique_values()
 356:     
 357:     def calculate_unique_values(self):
 358:         """Calculate unique values for each column from filtered data"""
 359:         self.column_unique_values = {}
 360:         
 361:         for col in self.columns:
 362:             unique_vals = set()
 363:             for item in self.filtered_data:
 364:                 val = item.get(col, '')
 365:                 if val != '':
 366:                     unique_vals.add(str(val))
 367:             self.column_unique_values[col] = sorted(list(unique_vals))
 368:     
 369:     def show_filter_menu(self, column):
 370:         """Show filter menu for a specific column"""
 371:         available_values = self.get_available_values_for_column(column)
 372:         FilterMenuDialog(self, column, self.column_headers.get(column, column),
 373:                         available_values, 
 374:                         self.active_filters.get(column, set()), 
 375:                         self.apply_filter)
 376:     
 377:     def get_available_values_for_column(self, column):
 378:         """Get all possible values for a column considering OTHER column filters"""
 379:         available_values = set()
 380:         
 381:         temp_filters = self.active_filters.copy()
 382:         if column in temp_filters:
 383:             del temp_filters[column]
 384:         
 385:         for item in self.original_data:
 386:             include_item = True
 387:             
 388:             for filter_col, filter_values in temp_filters.items():
 389:                 item_value = str(item.get(filter_col, ''))
 390:                 if item_value not in filter_values:
 391:                     include_item = False
 392:                     break
 393:             
 394:             if include_item:
 395:                 val = item.get(column, '')
 396:                 if val != '':
 397:                     available_values.add(str(val))
 398:         
 399:         return sorted(list(available_values))
 400:     
 401:     def apply_filter(self, column, selected_values):
 402:         """Apply filter to a specific column"""
 403:         if selected_values:
 404:             self.active_filters[column] = set(selected_values)
 405:         else:
 406:             if column in self.active_filters:
 407:                 del self.active_filters[column]
 408:         
 409:         self.filter_data()
 410:         self.update_display()
 411:         self.update_filter_status()
 412:         self.update_column_headers()
 413:     
 414:     def filter_data(self):
 415:         """Apply all active filters to the data"""
 416:         self.filtered_data = []
 417:         
 418:         for item in self.original_data:
 419:             include_item = True
 420:             
 421:             for filter_col, filter_values in self.active_filters.items():
 422:                 item_value = str(item.get(filter_col, ''))
 423:                 if item_value not in filter_values:
 424:                     include_item = False
 425:                     break
 426:             
 427:             if include_item:
 428:                 self.filtered_data.append(item)
 429:     
 430:     def update_display(self):
 431:         """Update the grid display with filtered data"""
 432:         self.populate_grid()
 433:         self.update_stats()
 434:     
 435:     def update_stats(self):
 436:         """Update the statistics display"""
 437:         if not self.show_stats or not hasattr(self, 'stats_label'):
 438:             return
 439:             
 440:         total_original = len(self.original_data)
 441:         total_filtered = len(self.filtered_data)
 442:         
 443:         if total_filtered == total_original:
 444:             stats_text = f"Total Items: {total_original:,}"
 445:         else:
 446:             stats_text = f"Showing: {total_filtered:,} of {total_original:,} items"
 447:         
 448:         self.stats_label.config(text=stats_text)
 449:     
 450:     def update_filter_status(self):
 451:         """Update the filter status display"""
 452:         if not self.active_filters:
 453:             self.filter_status_label.config(text="No filters applied")
 454:         else:
 455:             filter_count = len(self.active_filters)
 456:             filter_text = f"{filter_count} filter{'s' if filter_count > 1 else ''} applied"
 457:             self.filter_status_label.config(text=filter_text)
 458:     
 459:     def update_column_headers(self):
 460:         """Update column headers to show filter indicators"""
 461:         for col in self.columns:
 462:             header_text = self.column_headers.get(col, col)
 463:             if col in self.active_filters:
 464:                 self.tree.heading(col, text=f"{header_text} ▼")
 465:             else:
 466:                 self.tree.heading(col, text=header_text)
 467:     
 468:     def clear_all_filters(self):
 469:         """Clear all active filters"""
 470:         self.active_filters = {}
 471:         self.filtered_data = self.original_data.copy()
 472:         self.update_display()
 473:         self.update_filter_status()
 474:         self.update_column_headers()
 475:     
 476:     def export_to_excel(self):
 477:         """Export the current filtered data to Excel"""
 478:         try:
 479:             from openpyxl import Workbook
 480:             from openpyxl.styles import Font, PatternFill
 481:             import tempfile
 482:             import os
 483:             from datetime import datetime
 484:             
 485:             # Create workbook
 486:             wb = Workbook()
 487:             ws = wb.active
 488:             ws.title = "Data Export"
 489:             
 490:             # Header
 491:             ws['A1'] = self.window_title
 492:             ws['A1'].font = Font(bold=True, size=14)
 493:             ws['A2'] = f"Exported: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
 494:             ws['A3'] = f"Total Items: {len(self.filtered_data):,}"
 495:             
 496:             # Column headers
 497:             for col_idx, col_key in enumerate(self.columns, 1):
 498:                 cell = ws.cell(row=5, column=col_idx, value=self.column_headers.get(col_key, col_key))
 499:                 cell.font = Font(bold=True)
 500:                 cell.fill = PatternFill(start_color="90EE90", end_color="90EE90", fill_type="solid")
 501:             
 502:             # Data rows
 503:             for row_idx, item in enumerate(self.filtered_data, 6):
 504:                 for col_idx, col_key in enumerate(self.columns, 1):
 505:                     value = item.get(col_key, '')
 506:                     ws.cell(row=row_idx, column=col_idx, value=value)
 507:             
 508:             # Auto-adjust column widths
 509:             for column in ws.columns:
 510:                 max_length = 0
 511:                 column_letter = column[0].column_letter
 512:                 for cell in column:
 513:                     try:
 514:                         if len(str(cell.value)) > max_length:
 515:                             max_length = len(str(cell.value))
 516:                     except:
 517:                         pass
 518:                 adjusted_width = min(max_length + 2, 50)
 519:                 ws.column_dimensions[column_letter].width = adjusted_width
 520:             
 521:             # Save and open
 522:             temp_dir = tempfile.gettempdir()
 523:             timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
 524:             filename = f"{self.window_title.replace(' ', '_')}_{timestamp}.xlsx"
 525:             filepath = os.path.join(temp_dir, filename)
 526:             
 527:             wb.save(filepath)
 528:             os.startfile(filepath)
 529:             
 530:             messagebox.showinfo("Export Complete", f"Data exported to:\n{filepath}")
 531:             
 532:         except Exception as e:
 533:             messagebox.showerror("Export Error", f"Failed to export to Excel:\n{str(e)}")
 534:     
 535:     # Drag and window management methods
 536:     def start_drag(self, event):
 537:         """Start dragging the window"""
 538:         self.is_dragging = True
 539:         self.drag_start_x = event.x_root
 540:         self.drag_start_y = event.y_root
 541:         self.title_frame.configure(bg=Colors.HOVER_GREEN)
 542:     
 543:     def do_drag(self, event):
 544:         """Handle drag motion"""
 545:         if not self.is_dragging:
 546:             return
 547:         
 548:         delta_x = event.x_root - self.drag_start_x
 549:         delta_y = event.y_root - self.drag_start_y
 550:         
 551:         new_x = self.winfo_x() + delta_x
 552:         new_y = self.winfo_y() + delta_y
 553:         
 554:         self.geometry(f"+{new_x}+{new_y}")
 555:         
 556:         self.drag_start_x = event.x_root
 557:         self.drag_start_y = event.y_root
 558:     
 559:     def end_drag(self, event):
 560:         """End dragging operation"""
 561:         self.is_dragging = False
 562:         self.title_frame.configure(bg=Colors.DARK_GREEN)
 563:     
 564:     def center_window(self):
 565:         """Center the window on screen"""
 566:         self.update_idletasks()
 567:         width = self.winfo_width()
 568:         height = self.winfo_height()
 569:         x = (self.winfo_screenwidth() // 2) - (width // 2)
 570:         y = (self.winfo_screenheight() // 2) - (height // 2)
 571:         self.geometry(f"{width}x{height}+{x}+{y}")
 572:     
 573:     def on_closing(self):
 574:         """Handle window closing"""
 575:         self.destroy()
 576: 
 577: 
 578: class FilterMenuDialog(CustomDialog):
 579:     """Dialog for selecting filter values for a column"""
 580:     
 581:     def __init__(self, parent, column_key, column_header, unique_values, current_selection, apply_callback):
 582:         super().__init__(parent, f"Filter: {column_header}", width=350, height=400)
 583:         
 584:         self.column_key = column_key
 585:         self.column_header = column_header
 586:         self.unique_values = unique_values
 587:         self.current_selection = current_selection.copy()
 588:         self.apply_callback = apply_callback
 589:         self.parent_window = parent
 590:         
 591:         # Check if filter exists
 592:         self.has_existing_filter = column_key in parent.active_filters
 593:         
 594:         # Default to all selected if no current selection
 595:         if not self.current_selection and not self.has_existing_filter:
 596:             self.current_selection = set(unique_values)
 597:         
 598:         self.create_filter_interface()
 599:         self.create_action_buttons()
 600:     
 601:     def create_filter_interface(self):
 602:         """Create the filter selection interface"""
 603:         # Clear Filter button
 604:         if self.has_existing_filter:
 605:             clear_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
 606:             clear_frame.pack(fill=tk.X, pady=(0, 10))
 607:             
 608:             clear_filter_btn = tk.Button(clear_frame, text="Clear Filter for This Column", 
 609:                                        bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 610:                                        command=self.clear_column_filter, 
 611:                                        font=Fonts.DIALOG_LABEL,
 612:                                        cursor='hand2', relief=tk.RAISED, bd=1)
 613:             clear_filter_btn.pack(pady=5)
 614:         
 615:         # Search box
 616:         search_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
 617:         search_frame.pack(fill=tk.X, pady=5)
 618:         
 619:         tk.Label(search_frame, text="Search:", bg=Colors.LIGHT_GREEN, 
 620:                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).pack(side=tk.LEFT)
 621:         
 622:         self.search_var = tk.StringVar()
 623:         self.search_var.trace('w', self.filter_list)
 624:         search_entry = tk.Entry(search_frame, textvariable=self.search_var, 
 625:                                font=Fonts.DIALOG_LABEL)
 626:         search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
 627:         
 628:         # Select All / None buttons
 629:         select_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
 630:         select_frame.pack(fill=tk.X, pady=5)
 631:         
 632:         select_all_btn = tk.Button(select_frame, text="Select All", 
 633:                                   bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 634:                                   command=self.select_all, font=Fonts.DIALOG_LABEL)
 635:         select_all_btn.pack(side=tk.LEFT, padx=5)
 636:         
 637:         select_none_btn = tk.Button(select_frame, text="Select None", 
 638:                                    bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 639:                                    command=self.select_none, font=Fonts.DIALOG_LABEL)
 640:         select_none_btn.pack(side=tk.LEFT, padx=5)
 641:         
 642:         # Listbox with checkboxes
 643:         list_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
 644:         list_frame.pack(fill=tk.BOTH, expand=True, pady=5)
 645:         
 646:         self.filter_tree = ttk.Treeview(list_frame, show='tree', height=12)
 647:         self.filter_tree.column('#0', width=300)
 648:         
 649:         filter_scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, 
 650:                                         command=self.filter_tree.yview)
 651:         self.filter_tree.configure(yscrollcommand=filter_scrollbar.set)
 652:         
 653:         self.filter_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
 654:         filter_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
 655:         
 656:         self.populate_filter_list()
 657:         
 658:         # Bind click events
 659:         self.filter_tree.bind('<Button-1>', self.on_click)
 660:         self.filter_tree.bind('<Return>', self.toggle_item)
 661:     
 662:     def clear_column_filter(self):
 663:         """Clear the filter for this specific column"""
 664:         self.apply_callback(self.column_key, [])
 665:         self.destroy()
 666:     
 667:     def on_click(self, event):
 668:         """Handle click on items"""
 669:         item = self.filter_tree.identify('item', event.x, event.y)
 670:         if item:
 671:             self.filter_tree.selection_set(item)
 672:             self.toggle_item()
 673:     
 674:     def populate_filter_list(self, search_text=""):
 675:         """Populate the filter list"""
 676:         for item in self.filter_tree.get_children():
 677:             self.filter_tree.delete(item)
 678:         
 679:         filtered_values = [val for val in self.unique_values 
 680:                           if search_text.lower() in val.lower()] if search_text else self.unique_values
 681:         
 682:         for value in filtered_values:
 683:             checkbox = "☑" if value in self.current_selection else "☐"
 684:             display_text = f"{checkbox} {value}"
 685:             self.filter_tree.insert('', 'end', text=display_text, values=[value])
 686:     
 687:     def filter_list(self, *args):
 688:         """Filter the list based on search"""
 689:         self.populate_filter_list(self.search_var.get())
 690:     
 691:     def toggle_item(self, event=None):
 692:         """Toggle selection of an item"""
 693:         selected_item = self.filter_tree.selection()
 694:         if not selected_item:
 695:             return
 696:         
 697:         item_id = selected_item[0]
 698:         values = self.filter_tree.item(item_id, 'values')
 699:         if values:
 700:             value = values[0]
 701:             
 702:             if value in self.current_selection:
 703:                 self.current_selection.remove(value)
 704:             else:
 705:                 self.current_selection.add(value)
 706:             
 707:             self.populate_filter_list(self.search_var.get())
 708:     
 709:     def select_all(self):
 710:         """Select all visible items"""
 711:         search_text = self.search_var.get()
 712:         filtered_values = [val for val in self.unique_values 
 713:                           if search_text.lower() in val.lower()] if search_text else self.unique_values
 714:         
 715:         for value in filtered_values:
 716:             self.current_selection.add(value)
 717:         
 718:         self.populate_filter_list(search_text)
 719:     
 720:     def select_none(self):
 721:         """Deselect all visible items"""
 722:         search_text = self.search_var.get()
 723:         filtered_values = [val for val in self.unique_values 
 724:                           if search_text.lower() in val.lower()] if search_text else self.unique_values
 725:         
 726:         for value in filtered_values:
 727:             self.current_selection.discard(value)
 728:         
 729:         self.populate_filter_list(search_text)
 730:     
 731:     def create_action_buttons(self):
 732:         """Create OK and Cancel buttons"""
 733:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 734:         button_container.pack(expand=True)
 735:         
 736:         ok_btn = tk.Button(button_container, text="OK", 
 737:                           bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 738:                           command=self.apply_filter, width=Dimensions.DIALOG_BUTTON_WIDTH,
 739:                           font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 740:         ok_btn.pack(side=tk.LEFT, padx=10)
 741:         
 742:         cancel_btn = tk.Button(button_container, text="Cancel", 
 743:                               bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 744:                               command=self.cancel, width=Dimensions.DIALOG_BUTTON_WIDTH,
 745:                               font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 746:         cancel_btn.pack(side=tk.LEFT, padx=10)
 747:         
 748:         ok_btn.focus_set()
 749:     
 750:     def apply_filter(self):
 751:         """Apply the selected filter"""
 752:         self.apply_callback(self.column_key, list(self.current_selection))
 753:         self.destroy()
 754:     
 755:     def cancel(self):
 756:         """Cancel without applying changes"""
 757:         self.destroy()

────────────────────────────────────────────────────────────────────────────────
FILE: links_manager.py
────────────────────────────────────────────────────────────────────────────────
Path: links_manager.py
Size: 10.8 KB
Lines: 306 total, 253 non-empty
Characters: 11,087
Type: Data management for links and categories
────────────────────────────────────────────────────────────────────────────────

   1: # links_manager.py
   2: """
   3: Data management for Quick Links
   4: Handles loading, saving, and CRUD operations for links
   5: """
   6: 
   7: import json
   8: import os
   9: from pathlib import Path
  10: from config import Paths, DEFAULT_CATEGORIES
  11: from utils import FileUtils  # Import FileUtils for path normalization
  12: 
  13: class LinksManager:
  14:     """Manages saved links with categories"""
  15:     
  16:     def __init__(self):
  17:         # Ensure config directory exists
  18:         Paths.ensure_config_dir()
  19:         self.config_file = Paths.LINKS_FILE
  20:         self.links = self.load_links()
  21:     
  22:     def load_links(self):
  23:         """Load links from config file"""
  24:         try:
  25:             if self.config_file.exists():
  26:                 with open(self.config_file, 'r', encoding='utf-8') as f:
  27:                     data = json.load(f)
  28:                     # Validate structure
  29:                     if "categories" in data and "links" in data:
  30:                         # Fix any existing path issues
  31:                         self._fix_path_separators(data)
  32:                         return data
  33:                     else:
  34:                         print("Invalid config structure, creating new config")
  35:                         return self._create_default_config()
  36:             else:
  37:                 return self._create_default_config()
  38:         except (json.JSONDecodeError, FileNotFoundError, KeyError) as e:
  39:                 print(f"Error loading links: {e}. Creating new config.")
  40:                 return self._create_default_config()
  41:         
  42:     def _fix_path_separators(self, data):
  43:         """Fix forward slash path separators in existing links"""
  44:         for link in data.get("links", []):
  45:             if "path" in link:
  46:                 link["path"] = FileUtils.normalize_path(link["path"])
  47:     
  48:     def _create_default_config(self):
  49:         """Create default configuration"""
  50:         return {
  51:             "categories": DEFAULT_CATEGORIES.copy(),
  52:             "links": [],
  53:             "ui_preferences": {
  54:                 "menu_height": 300  # Default menu height
  55:             }
  56:         }
  57:     
  58:     def save_links(self):
  59:         """Save links to config file"""
  60:         try:
  61:             with open(self.config_file, 'w', encoding='utf-8') as f:
  62:                 json.dump(self.links, f, indent=2, ensure_ascii=False)
  63:             return True
  64:         except Exception as e:
  65:             print(f"Error saving links: {e}")
  66:             return False
  67:     
  68:     def add_link(self, name, path, category, icon="📄"):
  69:         """Add a new link"""
  70:         if not name or not path:
  71:             return False
  72:             
  73:         # Normalize the path for Windows
  74:         normalized_path = FileUtils.normalize_path(path)
  75:         
  76:         # Ensure category exists
  77:         if category not in self.links["categories"]:
  78:             self.links["categories"].append(category)
  79:         
  80:         new_link = {
  81:             "name": name.strip(),
  82:             "path": normalized_path,
  83:             "category": category,
  84:             "icon": icon
  85:         }
  86:         
  87:         self.links["links"].append(new_link)
  88:         return self.save_links()
  89:     
  90:     def update_link(self, index, name, path, category, icon="📄"):
  91:         """Update an existing link"""
  92:         if not (0 <= index < len(self.links["links"])):
  93:             return False
  94:         
  95:         if not name or not path:
  96:             return False
  97:         
  98:         # Normalize the path for Windows
  99:         normalized_path = FileUtils.normalize_path(path)
 100:         
 101:         # Ensure category exists
 102:         if category not in self.links["categories"]:
 103:             self.links["categories"].append(category)
 104:         
 105:         self.links["links"][index] = {
 106:             "name": name.strip(),
 107:             "path": normalized_path,
 108:             "category": category,
 109:             "icon": icon
 110:         }
 111:         
 112:         return self.save_links()
 113:     
 114:     def remove_link(self, index):
 115:         """Remove a link by index"""
 116:         if 0 <= index < len(self.links["links"]):
 117:             del self.links["links"][index]
 118:             return self.save_links()
 119:         return False
 120:     
 121:     def get_links_by_category(self, category):
 122:         """Get all links in a category"""
 123:         return [link for link in self.links["links"] if link["category"] == category]
 124:     
 125:     def get_all_links(self):
 126:         """Get all links"""
 127:         return self.links["links"].copy()
 128:     
 129:     def get_categories(self):
 130:         """Get all categories"""
 131:         return self.links["categories"].copy()
 132:     
 133:     def add_category(self, category_name):
 134:         """Add a new category"""
 135:         if category_name and category_name not in self.links["categories"]:
 136:             self.links["categories"].append(category_name)
 137:             return self.save_links()
 138:         return False
 139:     
 140:     def remove_category(self, category_name):
 141:         """Remove a category and all its links"""
 142:         if category_name in self.links["categories"]:
 143:             # Remove all links in this category
 144:             self.links["links"] = [
 145:                 link for link in self.links["links"] 
 146:                 if link["category"] != category_name
 147:             ]
 148:             # Remove the category
 149:             self.links["categories"].remove(category_name)
 150:             return self.save_links()
 151:         return False
 152:     
 153:     def move_link(self, from_index, to_index):
 154:         """Move a link from one position to another"""
 155:         if (0 <= from_index < len(self.links["links"]) and 
 156:             0 <= to_index < len(self.links["links"])):
 157:             
 158:             link = self.links["links"].pop(from_index)
 159:             self.links["links"].insert(to_index, link)
 160:             return self.save_links()
 161:         return False
 162:     
 163:     def search_links(self, query):
 164:         """Search links by name or path"""
 165:         query = query.lower().strip()
 166:         if not query:
 167:             return self.get_all_links()
 168:         
 169:         results = []
 170:         for link in self.links["links"]:
 171:             if (query in link["name"].lower() or 
 172:                 query in link["path"].lower() or
 173:                 query in link["category"].lower()):
 174:                 results.append(link)
 175:         
 176:         return results
 177:     
 178:     def get_stats(self):
 179:         """Get statistics about links"""
 180:         total_links = len(self.links["links"])
 181:         categories_count = {}
 182:         
 183:         for link in self.links["links"]:
 184:             category = link["category"]
 185:             categories_count[category] = categories_count.get(category, 0) + 1
 186:         
 187:         return {
 188:             "total_links": total_links,
 189:             "total_categories": len(self.links["categories"]),
 190:             "links_per_category": categories_count
 191:         }
 192:     
 193:     def export_links(self, file_path):
 194:         """Export links to a JSON file"""
 195:         try:
 196:             with open(file_path, 'w', encoding='utf-8') as f:
 197:                 json.dump(self.links, f, indent=2, ensure_ascii=False)
 198:             return True
 199:         except Exception as e:
 200:             print(f"Error exporting links: {e}")
 201:             return False
 202:     
 203:     def import_links(self, file_path, merge=True):
 204:         """Import links from a JSON file"""
 205:         try:
 206:             with open(file_path, 'r', encoding='utf-8') as f:
 207:                 imported_data = json.load(f)
 208:             
 209:             if not merge:
 210:                 # Replace all data
 211:                 self.links = imported_data
 212:             else:
 213:                 # Merge data
 214:                 for category in imported_data.get("categories", []):
 215:                     if category not in self.links["categories"]:
 216:                         self.links["categories"].append(category)
 217:                 
 218:                 for link in imported_data.get("links", []):
 219:                     # Check for duplicates (same name and path)
 220:                     duplicate = any(
 221:                         existing["name"] == link["name"] and existing["path"] == link["path"]
 222:                         for existing in self.links["links"]
 223:                     )
 224:                     if not duplicate:
 225:                         self.links["links"].append(link)
 226:             
 227:             return self.save_links()
 228:         except Exception as e:
 229:             print(f"Error importing links: {e}")
 230:             return False
 231:     
 232:     def get_menu_height(self):
 233:         """Get stored menu height"""
 234:         return self.links.get("ui_preferences", {}).get("menu_height", 300)
 235:     
 236:     def set_menu_height(self, height):
 237:         """Set menu height and save"""
 238:         if "ui_preferences" not in self.links:
 239:             self.links["ui_preferences"] = {}
 240:         self.links["ui_preferences"]["menu_height"] = height
 241:         return self.save_links()
 242:     
 243:     def move_link_to_category(self, link_index, new_category):
 244:         """Move a link to a different category"""
 245:         if not (0 <= link_index < len(self.links["links"])):
 246:             return False
 247:         
 248:         # Ensure new category exists
 249:         if new_category not in self.links["categories"]:
 250:             self.links["categories"].append(new_category)
 251:         
 252:         # Update the link's category
 253:         self.links["links"][link_index]["category"] = new_category
 254:         return self.save_links()
 255:     
 256:     def reorder_links_in_category(self, category, old_position, new_position):
 257:         """Reorder links within a category"""
 258:         category_links = [i for i, link in enumerate(self.links["links"]) 
 259:                          if link["category"] == category]
 260:         
 261:         if not (0 <= old_position < len(category_links) and 
 262:                 0 <= new_position < len(category_links)):
 263:             return False
 264:         
 265:         # Get the actual indices in the main links array
 266:         old_index = category_links[old_position]
 267:         new_index = category_links[new_position]
 268:         
 269:         # Move the link
 270:         link_to_move = self.links["links"].pop(old_index)
 271:         
 272:         # Adjust new_index if it's affected by the removal
 273:         if old_index < new_index:
 274:             new_index -= 1
 275:         
 276:         # Calculate the correct insertion position
 277:         if new_position == 0:
 278:             # Insert at the beginning of the category
 279:             insert_index = category_links[0] if old_index != category_links[0] else 0
 280:         elif new_position == len(category_links) - 1:
 281:             # Insert at the end of the category
 282:             insert_index = len(self.links["links"])
 283:         else:
 284:             # Insert at the specified position
 285:             insert_index = category_links[new_position]
 286:             if old_index < insert_index:
 287:                 insert_index -= 1
 288:         
 289:         self.links["links"].insert(insert_index, link_to_move)
 290:         return self.save_links()
 291:     
 292:     def get_link_position_in_category(self, link_index):
 293:         """Get the position of a link within its category"""
 294:         if not (0 <= link_index < len(self.links["links"])):
 295:             return -1
 296:         
 297:         link = self.links["links"][link_index]
 298:         category = link["category"]
 299:         
 300:         category_links = [i for i, l in enumerate(self.links["links"]) 
 301:                          if l["category"] == category]
 302:         
 303:         try:
 304:             return category_links.index(link_index)
 305:         except ValueError:
 306:             return -1

────────────────────────────────────────────────────────────────────────────────
FILE: main.py
────────────────────────────────────────────────────────────────────────────────
Path: main.py
Size: 1.1 KB
Lines: 42 total, 36 non-empty
Characters: 1,105
Type: Main application entry point
────────────────────────────────────────────────────────────────────────────────

   1: # main.py
   2: """
   3: Main entry point for SuiteView Taskbar Application
   4: """
   5: import sys
   6: import os
   7: 
   8: # Add the current directory to the Python path to ensure imports work
   9: current_dir = os.path.dirname(os.path.abspath(__file__))
  10: if current_dir not in sys.path:
  11:     sys.path.insert(0, current_dir)
  12: 
  13: # Now import our modules
  14: try:
  15:     from taskbar import SuiteViewTaskbar
  16:     from config import Settings
  17: except ImportError as e:
  18:     print(f"Import error: {e}")
  19:     print(f"Current directory: {current_dir}")
  20:     print(f"Files in directory: {os.listdir(current_dir)}")
  21:     sys.exit(1)
  22: 
  23: def main():
  24:     """Main application entry point"""
  25:     try:
  26:         print(f"Starting {Settings.APP_NAME} v{Settings.VERSION}")
  27:         
  28:         # Create and run the taskbar application
  29:         app = SuiteViewTaskbar()
  30:         app.run()
  31:         
  32:     except KeyboardInterrupt:
  33:         print("Application interrupted by user")
  34:         sys.exit(0)
  35:     except Exception as e:
  36:         print(f"Error starting application: {e}")
  37:         import traceback
  38:         traceback.print_exc()
  39:         sys.exit(1)
  40: 
  41: if __name__ == "__main__":
  42:     main()

────────────────────────────────────────────────────────────────────────────────
FILE: pinned_windows.py
────────────────────────────────────────────────────────────────────────────────
Path: pinned_windows.py
Size: 13.3 KB
Lines: 338 total, 266 non-empty
Characters: 13,293
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # pinned_windows.py (modified)
   2: """
   3: Pinned windows section for SuiteView Taskbar
   4: Manages the pinned window buttons in the taskbar
   5: Modified to blend seamlessly with taskbar
   6: """
   7: 
   8: import tkinter as tk
   9: from config import Colors, Fonts, Settings
  10: from window_manager import ManagedWindow, WindowManager
  11: from ui_components import ConfirmationDialog
  12: import win32gui
  13: import win32con
  14: 
  15: class PinnedWindowButton(tk.Frame):
  16:     """Individual pinned window button with app-specific colors"""
  17:     
  18:     def __init__(self, parent, window: ManagedWindow, window_manager: WindowManager, 
  19:                  on_unpin_callback):
  20:         super().__init__(parent, bg=Colors.DARK_GREEN, bd=0, highlightthickness=0)
  21:         self.window = window
  22:         self.window_manager = window_manager
  23:         self.on_unpin_callback = on_unpin_callback
  24:         
  25:         # Create button
  26:         self.create_button()
  27:         
  28:         # Bind right-click for unpin
  29:         self.button.bind("<Button-3>", self.show_unpin_menu)
  30:     
  31:     def create_button(self):
  32:         """Create the toggle button with app-specific colors"""
  33:         # Get app colors
  34:         bg_color = self.window.colors['bg']
  35:         fg_color = self.window.colors['fg']
  36:         
  37:         # Use shortened display name (without app prefix)
  38:         display_text = self.window.display_name
  39:         
  40:         # Truncate if too long
  41:         max_chars = 12
  42:         if len(display_text) > max_chars:
  43:             display_text = display_text[:max_chars-2] + ".."
  44:         
  45:         self.button = tk.Button(self, text=display_text,
  46:                                bg=bg_color, fg=fg_color,
  47:                                relief=tk.RAISED, bd=2,
  48:                                width=6,  # Slightly wider for better text fit
  49:                                font=('Arial', 8),
  50:                                padx=0,
  51:                                cursor='hand2',
  52:                                wraplength=40,  # Allow text wrapping
  53:                                activebackground=self._lighten_color(bg_color),
  54:                                activeforeground=fg_color,
  55:                                command=self.bring_window_to_front)
  56:         self.button.pack(fill=tk.BOTH, expand=True)
  57:         
  58:         # Update visual state if window is hidden
  59:         if self.window.is_hidden:
  60:             self.button.configure(relief=tk.SUNKEN, bd=1)
  61:     
  62:     def _lighten_color(self, hex_color):
  63:         """Lighten a hex color for hover effect"""
  64:         # Convert hex to RGB
  65:         hex_color = hex_color.lstrip('#')
  66:         r, g, b = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
  67:         
  68:         # Lighten by 20%
  69:         r = min(255, int(r * 1.2))
  70:         g = min(255, int(g * 1.2))
  71:         b = min(255, int(b * 1.2))
  72:         
  73:         return f'#{r:02x}{g:02x}{b:02x}'
  74:     
  75:     def bring_window_to_front(self):
  76:         """Toggle window - hide if fully visible/on top, otherwise bring to front"""
  77:         
  78:         try:
  79:             import win32gui
  80:             
  81:             if self.window.is_hidden:
  82:                 self.window_manager.toggle_window_visibility(self.window)
  83: 
  84:             self.window.bring_to_front()
  85: 
  86:                 
  87:                 
  88:                 # Window is visible - check if it's the foreground window
  89:                 # current_foreground = win32gui.GetForegroundWindow()
  90:                 
  91:                 # # Check if window is minimized
  92:                 # if win32gui.IsIconic(self.window.hwnd):
  93:                 #     print(f"Window {self.window.display_name} is minimized - restoring")
  94:                 #     self.window.bring_to_front()
  95:                 # elif current_foreground == self.window.hwnd:
  96:                 #     # Window is the foreground window - hide it
  97:                 #     print(f"Window {self.window.display_name} is foreground - hiding")
  98:                 #     self.window_manager.toggle_window_visibility(self.window)
  99:                 # else:
 100:                 #     # Window is visible but not foreground - bring it to front
 101:                 #     print(f"Window {self.window.display_name} is not foreground - bringing to front")
 102:                 #     self.window.bring_to_front()
 103:                 
 104:         except Exception as e:
 105:             print(f"Error in bring_window_to_front: {e}")
 106:             import traceback
 107:             traceback.print_exc()
 108:             # Fallback to just bringing to front
 109:             self.window.bring_to_front()
 110:             
 111:         # Don't update appearance - keep button color consistent
 112:     
 113:     def show_unpin_menu(self, event):
 114:         """Show right-click menu for unpinning"""
 115:         # Get taskbar position for proper dialog placement
 116:         taskbar = self.winfo_toplevel()
 117:         taskbar_x = taskbar.winfo_x()
 118:         taskbar_y = taskbar.winfo_y()
 119:         
 120:         # Get button position relative to taskbar
 121:         button_x = self.winfo_rootx()
 122:         
 123:         # Create custom confirmation dialog positioned above taskbar
 124:         dialog = UnpinConfirmationDialog(
 125:             taskbar,
 126:             self.window.app_name,
 127:             button_x,
 128:             taskbar_y
 129:         )
 130:         
 131:         # Wait for dialog result
 132:         taskbar.wait_window(dialog)
 133:         
 134:         if dialog.result:
 135:             self.window_manager.unpin_window(self.window)
 136:             self.on_unpin_callback()
 137:             
 138:         # Prevent event from propagating to parent widgets (taskbar)
 139:         return 'break'
 140:     
 141:     def update_window_title(self, window: ManagedWindow):
 142:         """Update the title of a specific pinned window button"""
 143:         if window.hwnd in self.pinned_buttons:
 144:             button_widget = self.pinned_buttons[window.hwnd]
 145:             
 146:             # Update button text with new display name
 147:             display_text = window.display_name
 148:             
 149:             # Truncate if too long
 150:             max_chars = 12
 151:             if len(display_text) > max_chars:
 152:                 display_text = display_text[:max_chars-2] + ".."
 153:             
 154:             button_widget.button.configure(text=display_text)
 155:             print(f"Updated pinned button text to: {display_text}")
 156: 
 157: class PinnedWindowsSection(tk.Frame):
 158:     """Section in taskbar for pinned windows - now blends with taskbar"""
 159:     
 160:     def __init__(self, parent, window_manager: WindowManager, on_pin_changed_callback=None):
 161:         # Use same background as taskbar, no border
 162:         super().__init__(parent, bg=Colors.DARK_GREEN, relief=tk.FLAT, bd=0)
 163:         self.window_manager = window_manager
 164:         self.pinned_buttons = {}
 165:         self.on_pin_changed_callback = on_pin_changed_callback
 166:         
 167:         # Debug output
 168:         # print(f"\n=== CREATING PINNED WINDOWS SECTION ===")
 169:         # print(f"Parent: {parent}")
 170:         # print(f"Window manager: {window_manager}")
 171: 
 172:         # Don't set a fixed width - let it expand based on content
 173:         self.configure(height=40)  # Match taskbar height
 174:         
 175:         # Remove any visible border
 176:         self.configure(highlightbackground=Colors.DARK_GREEN, highlightthickness=0)
 177:         
 178:         # Create container for buttons with no padding
 179:         self.button_container = tk.Frame(self, bg=Colors.DARK_GREEN)
 180:         self.button_container.pack(fill=tk.BOTH, expand=True)  # No padding
 181:         
 182:         # No empty state label - just leave it blank
 183:         
 184:         # print(f"PinnedWindowsSection created successfully: {self}")
 185:         # print(f"=== END CREATING PINNED WINDOWS SECTION ===\n")
 186:     
 187:     def refresh(self):
 188:         """Refresh the pinned windows display"""
 189:         # print(f"\n=== PINNED SECTION REFRESH ===")
 190:         # print(f"Current button count: {len(self.pinned_buttons)}")
 191:         
 192:         # Clear existing buttons
 193:         for hwnd in list(self.pinned_buttons.keys()):
 194:             print(f"Destroying old button for hwnd: {hwnd}")
 195:             self.pinned_buttons[hwnd].destroy()
 196:             del self.pinned_buttons[hwnd]
 197:         
 198:         # Get pinned windows
 199:         pinned_windows = self.window_manager.get_pinned_windows()
 200:         print(f"Found {len(pinned_windows)} pinned windows")
 201:         
 202:         if pinned_windows:
 203:             # Create buttons for pinned windows
 204:             for i, window in enumerate(pinned_windows):
 205:                 print(f"{i}. Creating button for: {window.display_name} (hwnd: {window.hwnd})")
 206:                 if window.is_valid():
 207:                     button = PinnedWindowButton(
 208:                         self.button_container, 
 209:                         window, 
 210:                         self.window_manager,
 211:                         self.on_pin_changed
 212:                     )
 213:                     button.pack(side=tk.LEFT, fill=tk.BOTH, expand=False)  # No padding, fill height
 214:                     self.pinned_buttons[window.hwnd] = button
 215:                     print(f"   Button created and packed")
 216:                     
 217:                     # Force update to ensure visibility
 218:                     button.update()
 219:                     self.button_container.update()
 220:                 else:
 221:                     print(f"   Window is not valid!")
 222:         
 223:         # Force the section to update
 224:         self.update_idletasks()
 225:         # print(f"Button container visible: {self.button_container.winfo_viewable()}")
 226:         # print(f"Section geometry: {self.winfo_width()}x{self.winfo_height()}")
 227:         # print("=== END REFRESH ===\n")
 228:     
 229:     def on_pin_changed(self):
 230:         """Called when a window is pinned/unpinned from the button"""
 231:         # Refresh the pinned section
 232:         self.refresh()
 233:         
 234:         # Also call the taskbar callback if it exists
 235:         if self.on_pin_changed_callback:
 236:             self.on_pin_changed_callback()
 237: 
 238: 
 239: class UnpinConfirmationDialog(tk.Toplevel):
 240:     """Custom unpin confirmation dialog positioned above taskbar"""
 241:     
 242:     def __init__(self, parent, app_name, button_x, taskbar_y):
 243:         super().__init__(parent)
 244:         self.result = False
 245:         
 246:         # Window setup
 247:         self.overrideredirect(True)
 248:         self.configure(bg=Colors.DARK_GREEN)
 249:         self.attributes('-topmost', True)
 250:         
 251:         # Create main frame with border
 252:         main_frame = tk.Frame(self, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=2)
 253:         main_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
 254:         
 255:         # Create header
 256:         header = tk.Frame(main_frame, bg=Colors.DARK_GREEN, height=25)
 257:         header.pack(fill=tk.X)
 258:         header.pack_propagate(False)
 259:         
 260:         # Title with icon
 261:         title_label = tk.Label(header, text="📌 Unpin Window", 
 262:                              bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 263:                              font=Fonts.DIALOG_TITLE)
 264:         title_label.pack(side=tk.LEFT, padx=10, pady=3)
 265:         
 266:         # Close button
 267:         close_btn = tk.Label(header, text="×", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 268:                            font=('Arial', 12, 'bold'), cursor='hand2')
 269:         close_btn.pack(side=tk.RIGHT, padx=5)
 270:         close_btn.bind("<Button-1>", lambda e: self.cancel())
 271:         
 272:         # Content area
 273:         content = tk.Frame(main_frame, bg=Colors.LIGHT_GREEN)
 274:         content.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
 275:         
 276:         # Pin icon
 277:         icon_label = tk.Label(content, text="📌", bg=Colors.LIGHT_GREEN,
 278:                             font=('Arial', 24))
 279:         icon_label.pack(pady=5)
 280:         
 281:         # Message
 282:         msg = f"Unpin '{app_name}' from taskbar?"
 283:         msg_label = tk.Label(content, text=msg, bg=Colors.LIGHT_GREEN,
 284:                            fg=Colors.BLACK, font=Fonts.DIALOG_LABEL)
 285:         msg_label.pack(pady=5)
 286:         
 287:         # Buttons
 288:         button_frame = tk.Frame(content, bg=Colors.LIGHT_GREEN)
 289:         button_frame.pack(pady=10)
 290:         
 291:         yes_btn = tk.Button(button_frame, text="Yes", 
 292:                           bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 293:                           command=self.yes, width=8,
 294:                           font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 295:         yes_btn.pack(side=tk.LEFT, padx=5)
 296:         
 297:         no_btn = tk.Button(button_frame, text="No", 
 298:                          bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 299:                          command=self.cancel, width=8,
 300:                          font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 301:         no_btn.pack(side=tk.LEFT, padx=5)
 302:         
 303:         # Set dialog size
 304:         dialog_width = 350
 305:         dialog_height = 200
 306:         
 307:         # Position dialog above taskbar, centered on button
 308:         x = button_x - dialog_width // 2
 309:         y = taskbar_y - dialog_height - 5  # 5px gap above taskbar
 310:         
 311:         # Ensure dialog stays on screen
 312:         screen_width = self.winfo_screenwidth()
 313:         if x < 0:
 314:             x = 0
 315:         elif x + dialog_width > screen_width:
 316:             x = screen_width - dialog_width
 317:         
 318:         self.geometry(f"{dialog_width}x{dialog_height}+{x}+{y}")
 319:         
 320:         # Focus on No button (safer default)
 321:         no_btn.focus_set()
 322:         
 323:         # Bind keys
 324:         self.bind('<Return>', lambda e: self.yes())
 325:         self.bind('<Escape>', lambda e: self.cancel())
 326:         
 327:         # Make modal
 328:         self.grab_set()
 329:     
 330:     def yes(self):
 331:         """Yes button clicked"""
 332:         self.result = True
 333:         self.destroy()
 334:     
 335:     def cancel(self):
 336:         """No button clicked or dialog cancelled"""
 337:         self.result = False
 338:         self.destroy()

────────────────────────────────────────────────────────────────────────────────
FILE: quick_links.py
────────────────────────────────────────────────────────────────────────────────
Path: quick_links.py
Size: 36.3 KB
Lines: 867 total, 691 non-empty
Characters: 36,277
Type: Quick links menu and management
────────────────────────────────────────────────────────────────────────────────

   1: # quick_links.py
   2: """
   3: Quick Links feature for SuiteView Taskbar
   4: Contains the links menu, dialogs, and management interface
   5: """
   6: 
   7: import tkinter as tk
   8: from tkinter import ttk, filedialog
   9: from config import Colors, Fonts, Dimensions
  10: from utils import UIUtils, FileUtils
  11: from ui_components import CustomDialog, ConfirmationDialog, FormField, CategoryHeader, WarningDialog, ErrorDialog
  12: from links_manager import LinksManager
  13: 
  14: class QuickLinksMenu(tk.Toplevel):
  15:     """Enhanced right-click context menu for managing links with column layout"""
  16:     
  17:     def __init__(self, parent, taskbar_instance, x, y):
  18:         super().__init__(parent)
  19:         self.parent = parent
  20:         self.taskbar_instance = taskbar_instance
  21:         self.links_manager = taskbar_instance.links_manager
  22:         
  23:         # Window setup
  24:         self.overrideredirect(True)
  25:         self.configure(bg=Colors.DARK_GREEN)
  26:         self.attributes('-topmost', True)
  27:         self.attributes('-alpha', 0.98)
  28:         
  29:         # Initialize resize variables
  30:         self.is_resizing = False
  31:         self.resize_start_y = 0
  32:         self.original_height = 0
  33:         self.bottom_y = 0  # Track bottom position for locked resizing
  34:         
  35:         # Initialize drag and drop variables
  36:         self.is_dragging_link = False
  37:         self.drag_start_time = 0
  38:         self.drag_threshold = 5  # pixels to move before considering it a drag
  39:         self.drag_time_threshold = 200  # milliseconds to wait before drag
  40:         self.dragged_link_data = None
  41:         self.dragged_link_index = None
  42:         self.drag_visual = None
  43:         self.drop_indicators = []
  44:         
  45:         # Position the menu
  46:         self.geometry(f"+{x}+{y}")
  47:         
  48:         # Main container with dark green border
  49:         self.main_frame = tk.Frame(self, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=2)
  50:         self.main_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
  51:         
  52:         # Header frame with buttons
  53:         self.create_header()
  54:         
  55:         # Content area with light green background
  56:         self.content_frame = tk.Frame(self.main_frame, bg=Colors.LIGHT_GREEN, relief=tk.SUNKEN, bd=1)
  57:         self.content_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
  58:         
  59:         # Create column layout for all categories
  60:         self.create_column_layout()
  61:         
  62:         # Bind events
  63:         self.bind("<FocusOut>", lambda e: self.destroy())
  64:         self.focus_set()
  65:         
  66:         # Set minimum size based on content and stored preferences
  67:         self.update_idletasks()
  68:         self.menu_width = max(Dimensions.MENU_MIN_WIDTH, self.winfo_reqwidth())
  69:         
  70:         # Use stored menu height or default
  71:         stored_height = self.links_manager.get_menu_height()
  72:         calculated_height = max(Dimensions.MENU_MIN_HEIGHT, self.winfo_reqheight())
  73:         self.menu_height = max(stored_height, calculated_height)
  74:         
  75:         self.geometry(f"{self.menu_width}x{self.menu_height}")
  76:         
  77:         # Store bottom position for locked resizing
  78:         self.update_idletasks()
  79:         self.bottom_y = self.winfo_y() + self.winfo_height()
  80:         
  81:         # Setup resize functionality
  82:         self.setup_resize_functionality()
  83:         
  84:     
  85:     def create_header(self):
  86:         """Create header with title and buttons"""
  87:         self.header_frame = tk.Frame(self.main_frame, bg=Colors.DARK_GREEN, height=25)
  88:         self.header_frame.pack(fill=tk.X, padx=1, pady=1)
  89:         self.header_frame.pack_propagate(False)
  90:         
  91:         # Create a resize area at the top of the header
  92:         resize_area = tk.Frame(self.header_frame, bg=Colors.MEDIUM_GREEN, height=3, cursor='sb_v_double_arrow')
  93:         resize_area.pack(fill=tk.X, side=tk.TOP)
  94:         
  95:         # Main header content
  96:         header_content = tk.Frame(self.header_frame, bg=Colors.DARK_GREEN)
  97:         header_content.pack(fill=tk.BOTH, expand=True)
  98:         
  99:         # Resize handle (left side) - more prominent
 100:         resize_handle = tk.Label(header_content, text="═══", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 101:                                font=('Arial', 6), cursor='sb_v_double_arrow', width=4)
 102:         resize_handle.pack(side=tk.LEFT, padx=2, pady=3)
 103:         
 104:         # Title with resize capability
 105:         title_label = tk.Label(header_content, text="Quick Links ↕", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 106:                              font=Fonts.MENU_HEADER, cursor='sb_v_double_arrow')
 107:         title_label.pack(side=tk.LEFT, padx=5, pady=3)
 108:         
 109:         # Bind resize events to multiple elements for better usability
 110:         for widget in [resize_area, resize_handle, title_label, self.header_frame]:
 111:             widget.bind("<Button-1>", self.start_resize)
 112:             widget.bind("<B1-Motion>", self.do_resize)
 113:             widget.bind("<ButtonRelease-1>", self.end_resize)
 114:             widget.bind("<Enter>", lambda e: self.configure(cursor='sb_v_double_arrow'))
 115:             widget.bind("<Leave>", lambda e: self.configure(cursor=''))
 116:         
 117:         # Buttons with green theme
 118:         button_frame = tk.Frame(header_content, bg=Colors.DARK_GREEN)
 119:         button_frame.pack(side=tk.RIGHT, padx=5)
 120:         
 121:         # Add button
 122:         add_btn = tk.Button(button_frame, text="Add", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 123:                            relief=tk.RAISED, bd=1, cursor='hand2', 
 124:                            font=Fonts.MENU_ITEM, width=4, height=1,
 125:                            command=self.add_new_link)
 126:         add_btn.pack(side=tk.LEFT, padx=1)
 127:         
 128:         # # View button (placeholder for future features)
 129:         # view_btn = tk.Button(button_frame, text="Vie", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 130:         #                     relief=tk.RAISED, bd=1, cursor='hand2',
 131:         #                     font=Fonts.MENU_ITEM, width=4, height=1)
 132:         # view_btn.pack(side=tk.LEFT, padx=1)
 133:         
 134:         # Close button
 135:         close_btn = tk.Button(button_frame, text="X", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 136:                              relief=tk.RAISED, bd=1, cursor='hand2',
 137:                              font=Fonts.MENU_ITEM, width=3, height=1,
 138:                              command=self.destroy)
 139:         close_btn.pack(side=tk.LEFT, padx=1)
 140:     
 141:     def create_column_layout(self):
 142:         """Create column layout showing all categories"""
 143:         # Container for columns
 144:         columns_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
 145:         columns_frame.pack(fill=tk.BOTH, expand=True, padx=3, pady=3)
 146:         
 147:         categories = self.links_manager.get_categories()
 148:         num_categories = len(categories)
 149:         
 150:         # Create columns for each category
 151:         for i, category in enumerate(categories):
 152:             column_frame = tk.Frame(columns_frame, bg=Colors.LIGHT_GREEN, relief=tk.FLAT)
 153:             column_frame.grid(row=0, column=i, sticky='nsew', padx=2, pady=1)
 154:             
 155:             # Configure grid weights for equal distribution
 156:             columns_frame.grid_columnconfigure(i, weight=1)
 157:         
 158:         columns_frame.grid_rowconfigure(0, weight=1)
 159:         
 160:         # Populate each column
 161:         for i, category in enumerate(categories):
 162:             self.create_category_column(columns_frame, category, i)
 163:     
 164:     def create_category_column(self, parent, category, column_index):
 165:         """Create a column for a specific category"""
 166:         # Get the column frame
 167:         column_frame = parent.grid_slaves(row=0, column=column_index)[0]
 168:         
 169:         # Category header
 170:         header = CategoryHeader(column_frame, category)
 171:         header.pack(fill=tk.X, pady=(0, 2))
 172:         
 173:         # Links container with light green background
 174:         links_container = tk.Frame(column_frame, bg=Colors.LIGHT_GREEN)
 175:         links_container.pack(fill=tk.BOTH, expand=True)
 176:         
 177:         # Store category for drop operations
 178:         links_container.category = category
 179:         links_container.bind("<Enter>", lambda e: self.on_category_drop_zone_enter(e, category))
 180:         links_container.bind("<Leave>", lambda e: self.on_category_drop_zone_leave(e, category))
 181:         
 182:         # Get links for this category
 183:         links = self.links_manager.get_links_by_category(category)
 184:         
 185:         if links:
 186:             for link in links:
 187:                 # Find the actual index in the full links list
 188:                 actual_index = self.links_manager.get_all_links().index(link)
 189:                 self.create_compact_link_item(links_container, link, actual_index)
 190:         else:
 191:             # Empty state - also acts as a drop zone
 192:             empty_label = tk.Label(links_container, text="", bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 193:                                  font=(Fonts.MENU_ITEM[0], Fonts.MENU_ITEM[1], 'italic'))
 194:             empty_label.pack(pady=5)
 195:             empty_label.category = category
 196:             empty_label.bind("<Enter>", lambda e: self.on_empty_category_enter(e, category))
 197:             empty_label.bind("<Leave>", lambda e: self.on_empty_category_leave(e, category))
 198:     
 199:     def create_compact_link_item(self, parent, link, index):
 200:         """Create a compact link item with drag-and-drop support"""
 201:         # Create a frame to hold the link (easier for drag operations)
 202:         link_frame = tk.Frame(parent, bg=Colors.LIGHT_GREEN, relief=tk.FLAT)
 203:         link_frame.pack(fill=tk.X, padx=2, pady=1)
 204:         
 205:         # Create the link label
 206:         link_label = tk.Label(link_frame, text=f"{link['name']}", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 207:                              font=Fonts.MENU_ITEM, anchor='w', height=1,
 208:                              cursor='hand2', relief=tk.FLAT, padx=5, pady=2)
 209:         link_label.pack(fill=tk.X)
 210:         
 211:         # Store link data for drag operations
 212:         link_frame.link_data = link
 213:         link_frame.link_index = index
 214:         link_frame.category = link['category']
 215:         link_label.link_data = link
 216:         link_label.link_index = index
 217:         link_label.category = link['category']
 218:         
 219:         # Apply hover effects
 220:         UIUtils.apply_hover_effect(link_label, Colors.LIGHT_GREEN, Colors.HOVER_GREEN, 
 221:                                   Colors.BLACK, Colors.WHITE)
 222:         
 223:         # Bind drag and drop events
 224:         for widget in [link_frame, link_label]:
 225:             widget.bind("<Button-1>", lambda e, l=link, i=index: self.on_link_press(e, l, i))
 226:             widget.bind("<B1-Motion>", lambda e, l=link, i=index: self.on_link_drag(e, l, i))
 227:             widget.bind("<ButtonRelease-1>", lambda e, l=link, i=index: self.on_link_release(e, l, i))
 228:             widget.bind("<Button-3>", lambda e, l=link, i=index: self.show_link_context_menu(e, l, i))
 229:         
 230:         # Mark as drop zone
 231:         link_frame.bind("<Enter>", lambda e: self.on_drop_zone_enter(e, link, index))
 232:         link_frame.bind("<Leave>", lambda e: self.on_drop_zone_leave(e, link, index))
 233:     
 234:     def show_link_context_menu(self, event, link, index):
 235:         """Show context menu for individual link"""
 236:         context_menu = tk.Menu(self, tearoff=0, bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 237:                               activebackground=Colors.HOVER_GREEN, activeforeground=Colors.WHITE)
 238:         
 239:         context_menu.add_command(label=f"Open {link['name']}", 
 240:                                 command=lambda: FileUtils.open_path(link['path'], self.parent))
 241:         context_menu.add_separator()
 242:         context_menu.add_command(label="Edit", 
 243:                                 command=lambda: self.edit_link(link, index))
 244:         context_menu.add_command(label="Delete", 
 245:                                 command=lambda: self.delete_link(link, index))
 246:         
 247:         try:
 248:             context_menu.tk_popup(event.x_root, event.y_root)
 249:         finally:
 250:             context_menu.grab_release()
 251:     
 252:     def edit_link(self, link, index):
 253:         """Edit an existing link"""
 254:         self.destroy()
 255:         AddEditLinkDialog.show_edit_dialog(self.parent, self.links_manager, self.taskbar_instance, link, index)
 256:     
 257:     def delete_link(self, link, index):
 258:         """Delete a link with confirmation"""
 259:         result = ConfirmationDialog.ask(
 260:             self.parent, 
 261:             "Delete Link", 
 262:             f"Are you sure you want to delete:\n'{link['name']}'?"
 263:         )
 264:         
 265:         if result:
 266:             self.links_manager.remove_link(index)
 267:             self.destroy()
 268:             # Refresh menu
 269:             self.taskbar_instance.show_links_menu(None)
 270:     
 271:     def add_new_link(self):
 272:         """Show dialog to add a new link"""
 273:         self.destroy()
 274:         AddEditLinkDialog.show_add_dialog(self.parent, self.links_manager, self.taskbar_instance)
 275:     
 276:     def setup_resize_functionality(self):
 277:         """Setup resize functionality with minimum size constraints"""
 278:         self.min_height = 150  # Minimum height
 279:         self.max_height = 600  # Maximum height for usability
 280:         
 281:         # Allow window to be resizable
 282:         self.resizable(False, True)  # Only allow vertical resizing
 283:     
 284:     def start_resize(self, event):
 285:         """Start resizing operation"""
 286:         self.is_resizing = True
 287:         self.resize_start_y = event.y_root
 288:         self.original_height = self.winfo_height()
 289:         self.original_x = self.winfo_x()
 290:         
 291:         # Update bottom position
 292:         self.bottom_y = self.winfo_y() + self.winfo_height()
 293:         
 294:         # Change cursor to indicate resizing
 295:         self.configure(cursor='sb_v_double_arrow')
 296:         
 297:         # Visual feedback
 298:         self.header_frame.configure(bg=Colors.HOVER_GREEN)
 299:         
 300:         print(f"Starting resize: height={self.original_height}, bottom_y={self.bottom_y}")
 301:     
 302:     def do_resize(self, event):
 303:         """Handle resize drag motion"""
 304:         if not self.is_resizing:
 305:             return
 306:         
 307:         # Calculate the change in Y position
 308:         delta_y = event.y_root - self.resize_start_y
 309:         
 310:         # Calculate new height (drag up = smaller delta = taller window)
 311:         new_height = self.original_height - delta_y
 312:         
 313:         # Apply constraints
 314:         new_height = max(self.min_height, min(self.max_height, new_height))
 315:         
 316:         # Calculate new Y position to keep bottom locked
 317:         new_y = self.bottom_y - new_height
 318:         
 319:         # Apply the new geometry
 320:         try:
 321:             self.geometry(f"{self.menu_width}x{int(new_height)}+{self.original_x}+{int(new_y)}")
 322:         except Exception as e:
 323:             print(f"Resize error: {e}")
 324:     
 325:     def end_resize(self, event):
 326:         """End resizing operation"""
 327:         self.is_resizing = False
 328:         self.configure(cursor='')
 329:         
 330:         # Remove visual feedback
 331:         self.header_frame.configure(bg=Colors.DARK_GREEN)
 332:         
 333:         # Update the stored height
 334:         self.menu_height = self.winfo_height()
 335:         
 336:         # Save the new height persistently
 337:         self.links_manager.set_menu_height(self.menu_height)
 338:         
 339:         print(f"Resize ended: new height={self.menu_height} (saved)")
 340:     
 341:     # Drag and Drop Event Handlers
 342:     def on_link_press(self, event, link, index):
 343:         """Handle mouse press on link - start potential drag or prepare for click"""
 344:         import time
 345:         self.drag_start_time = time.time() * 1000  # Convert to milliseconds
 346:         self.drag_start_x = event.x_root
 347:         self.drag_start_y = event.y_root
 348:         self.dragged_link_data = link
 349:         self.dragged_link_index = index
 350:         self.potential_drag = True
 351:         
 352:         # Schedule a delayed check for click vs drag
 353:         self.after(self.drag_time_threshold, lambda: self.check_for_click_or_drag(event, link, index))
 354:     
 355:     def on_link_drag(self, event, link, index):
 356:         """Handle mouse drag on link"""
 357:         if not hasattr(self, 'potential_drag') or not self.potential_drag:
 358:             return
 359:         
 360:         # Calculate distance moved
 361:         distance = ((event.x_root - self.drag_start_x) ** 2 + (event.y_root - self.drag_start_y) ** 2) ** 0.5
 362:         
 363:         if distance > self.drag_threshold:
 364:             self.start_link_drag(event, link, index)
 365:     
 366:     def on_link_release(self, event, link, index):
 367:         """Handle mouse release on link"""
 368:         if self.is_dragging_link:
 369:             self.end_link_drag(event, link, index)
 370:         elif hasattr(self, 'potential_drag') and self.potential_drag:
 371:             # This was a click, not a drag
 372:             self.handle_link_click(link)
 373:         
 374:         # Reset drag state
 375:         self.potential_drag = False
 376:         self.is_dragging_link = False
 377:     
 378:     def check_for_click_or_drag(self, event, link, index):
 379:         """Determine if this was a click or start of drag after delay"""
 380:         if hasattr(self, 'potential_drag') and self.potential_drag and not self.is_dragging_link:
 381:             # Still within time threshold and no drag started, treat as click
 382:             pass  # Let the release handler manage the click
 383:     
 384:     def handle_link_click(self, link):
 385:         """Handle regular link click to open file"""
 386:         FileUtils.open_path(link['path'], self.parent)
 387:         self.destroy()
 388:     
 389:     def start_link_drag(self, event, link, index):
 390:         """Start dragging a link"""
 391:         if self.is_dragging_link:
 392:             return
 393:         
 394:         self.is_dragging_link = True
 395:         self.potential_drag = False
 396:         
 397:         # Create drag visual
 398:         self.create_drag_visual(event, link)
 399:         
 400:         # Show drop indicators
 401:         self.show_drop_indicators()
 402:         
 403:         print(f"Started dragging: {link['name']}")
 404:     
 405:     def create_drag_visual(self, event, link):
 406:         """Create visual feedback for dragging"""
 407:         if self.drag_visual:
 408:             self.drag_visual.destroy()
 409:         
 410:         self.drag_visual = tk.Toplevel(self)
 411:         self.drag_visual.overrideredirect(True)
 412:         self.drag_visual.attributes('-topmost', True)
 413:         self.drag_visual.attributes('-alpha', 0.8)
 414:         
 415:         # Make drag visual ignore mouse events (so they pass through to drop zones)
 416:         try:
 417:             # This makes the window transparent to mouse events
 418:             self.drag_visual.attributes('-transparentcolor', 'black')  
 419:         except:
 420:             pass  # Not all systems support this
 421:         
 422:         # Create drag visual content
 423:         drag_frame = tk.Frame(self.drag_visual, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=2)
 424:         drag_frame.pack(padx=2, pady=2)
 425:         
 426:         tk.Label(drag_frame, text=f"🚀 {link['name']}", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 427:                 font=Fonts.MENU_ITEM, padx=10, pady=5).pack()
 428:         
 429:         # Position at cursor
 430:         self.drag_visual.geometry(f"+{event.x_root + 10}+{event.y_root + 10}")
 431:         
 432:         # Bind motion to follow cursor
 433:         self.bind("<Motion>", self.update_drag_visual)
 434:     
 435:     def update_drag_visual(self, event):
 436:         """Update drag visual position"""
 437:         if self.drag_visual and self.is_dragging_link:
 438:             self.drag_visual.geometry(f"+{event.x_root + 10}+{event.y_root + 10}")
 439:     
 440:     def show_drop_indicators(self):
 441:         """Show visual indicators for valid drop zones"""
 442:         # This would highlight valid drop areas
 443:         # For now, we'll rely on hover effects in the drop zone handlers
 444:         pass
 445:     
 446:     def end_link_drag(self, event, link, index):
 447:         """End link drag operation"""
 448:         print(f"Ending drag for: {link['name']}")
 449:         
 450:         # Try to find drop target at current mouse position
 451:         drop_target = self.find_drop_target_at_position(event.x_root, event.y_root)
 452:         
 453:         if drop_target:
 454:             print(f"Found drop target: {drop_target}")
 455:             self.current_drop_target = drop_target
 456:             self.perform_drop_operation()
 457:         else:
 458:             print("No valid drop target found")
 459:         
 460:         self.is_dragging_link = False
 461:         
 462:         # Clean up drag visual
 463:         if self.drag_visual:
 464:             self.drag_visual.destroy()
 465:             self.drag_visual = None
 466:         
 467:         # Unbind motion events
 468:         self.unbind("<Motion>")
 469:         
 470:         # Hide drop indicators
 471:         self.hide_drop_indicators()
 472:         
 473:         print(f"Ended dragging: {link['name']}")
 474:     
 475:     def hide_drop_indicators(self):
 476:         """Hide drop zone indicators"""
 477:         # Clean up any drop indicators
 478:         for indicator in self.drop_indicators:
 479:             try:
 480:                 indicator.destroy()
 481:             except:
 482:                 pass
 483:         self.drop_indicators.clear()
 484:     
 485:     # Drop Zone Event Handlers
 486:     def on_drop_zone_enter(self, event, link, index):
 487:         """Handle mouse entering a link drop zone"""
 488:         if self.is_dragging_link and self.dragged_link_index != index:
 489:             event.widget.configure(bg=Colors.HOVER_GREEN)
 490:             self.current_drop_target = {'type': 'reorder', 'link': link, 'index': index}
 491:     
 492:     def on_drop_zone_leave(self, event, link, index):
 493:         """Handle mouse leaving a link drop zone"""
 494:         if self.is_dragging_link:
 495:             event.widget.configure(bg=Colors.LIGHT_GREEN)
 496:             if hasattr(self, 'current_drop_target'):
 497:                 delattr(self, 'current_drop_target')
 498:     
 499:     def on_category_drop_zone_enter(self, event, category):
 500:         """Handle mouse entering a category drop zone"""
 501:         if self.is_dragging_link and self.dragged_link_data['category'] != category:
 502:             event.widget.configure(bg=Colors.MEDIUM_GREEN)
 503:             self.current_drop_target = {'type': 'move', 'category': category}
 504:     
 505:     def on_category_drop_zone_leave(self, event, category):
 506:         """Handle mouse leaving a category drop zone"""
 507:         if self.is_dragging_link:
 508:             event.widget.configure(bg=Colors.LIGHT_GREEN)
 509:             if hasattr(self, 'current_drop_target'):
 510:                 delattr(self, 'current_drop_target')
 511:     
 512:     def on_empty_category_enter(self, event, category):
 513:         """Handle mouse entering an empty category"""
 514:         if self.is_dragging_link and self.dragged_link_data['category'] != category:
 515:             event.widget.configure(bg=Colors.MEDIUM_GREEN)
 516:             self.current_drop_target = {'type': 'move', 'category': category}
 517:     
 518:     def on_empty_category_leave(self, event, category):
 519:         """Handle mouse leaving an empty category"""
 520:         if self.is_dragging_link:
 521:             event.widget.configure(bg=Colors.LIGHT_GREEN)
 522:             if hasattr(self, 'current_drop_target'):
 523:                 delattr(self, 'current_drop_target')
 524:     
 525:     def perform_drop_operation(self):
 526:         """Perform the actual drop operation based on current target"""
 527:         print(f"Performing drop operation...")
 528:         
 529:         if not hasattr(self, 'current_drop_target'):
 530:             print("No current_drop_target found")
 531:             return False
 532:             
 533:         if not self.dragged_link_data or self.dragged_link_index is None:
 534:             print("No dragged link data found")
 535:             return False
 536:         
 537:         target = self.current_drop_target
 538:         success = False
 539:         
 540:         print(f"Drop target: {target}")
 541:         print(f"Dragged link: {self.dragged_link_data['name']} (index: {self.dragged_link_index})")
 542:         
 543:         if target['type'] == 'move':
 544:             # Move to different category
 545:             print(f"Attempting to move to category: {target['category']}")
 546:             success = self.links_manager.move_link_to_category(self.dragged_link_index, target['category'])
 547:             if success:
 548:                 print(f"✅ Moved '{self.dragged_link_data['name']}' to category '{target['category']}'")
 549:             else:
 550:                 print(f"❌ Failed to move '{self.dragged_link_data['name']}' to category '{target['category']}'")
 551:         
 552:         elif target['type'] == 'reorder':
 553:             # Reorder within same category
 554:             dragged_category = self.dragged_link_data['category']
 555:             dragged_pos = self.links_manager.get_link_position_in_category(self.dragged_link_index)
 556:             target_pos = self.links_manager.get_link_position_in_category(target['index'])
 557:             
 558:             print(f"Attempting to reorder in category: {dragged_category}")
 559:             print(f"From position {dragged_pos} to position {target_pos}")
 560:             
 561:             if dragged_pos != -1 and target_pos != -1:
 562:                 success = self.links_manager.reorder_links_in_category(dragged_category, dragged_pos, target_pos)
 563:                 if success:
 564:                     print(f"✅ Reordered '{self.dragged_link_data['name']}' in category '{dragged_category}'")
 565:                 else:
 566:                     print(f"❌ Failed to reorder '{self.dragged_link_data['name']}' in category '{dragged_category}'")
 567:             else:
 568:                 print(f"❌ Invalid positions: dragged_pos={dragged_pos}, target_pos={target_pos}")
 569:         
 570:         if success:
 571:             # Refresh the menu to show changes
 572:             print("Refreshing menu...")
 573:             self.refresh_menu()
 574:         else:
 575:             print("Drop operation failed")
 576:         
 577:         return success
 578:     
 579:     def refresh_menu(self):
 580:         """Refresh the menu display after drag and drop operations"""
 581:         # Store current position
 582:         current_x = self.winfo_x()
 583:         current_y = self.winfo_y()
 584:         current_height = self.winfo_height()
 585:         
 586:         # Recreate the column layout
 587:         for widget in self.content_frame.winfo_children():
 588:             widget.destroy()
 589:         
 590:         self.create_column_layout()
 591:         
 592:         # Restore position and size
 593:         self.geometry(f"{self.menu_width}x{current_height}+{current_x}+{current_y}")
 594:         
 595:         print("Menu refreshed after drag and drop")
 596:     
 597:     def find_drop_target_at_position(self, x, y):
 598:         """Find what widget/drop target is at the given screen coordinates"""
 599:         try:
 600:             # Get widget at position relative to this window
 601:             widget_at_pos = self.winfo_containing(x, y)
 602:             
 603:             if not widget_at_pos:
 604:                 return None
 605:                 
 606:             print(f"Widget at position: {widget_at_pos}")
 607:             
 608:             # Check if it's a link (for reordering)
 609:             if hasattr(widget_at_pos, 'link_data') and hasattr(widget_at_pos, 'link_index'):
 610:                 link_data = widget_at_pos.link_data
 611:                 link_index = widget_at_pos.link_index
 612:                 
 613:                 # Don't allow dropping on self
 614:                 if link_index == self.dragged_link_index:
 615:                     return None
 616:                     
 617:                 return {
 618:                     'type': 'reorder', 
 619:                     'link': link_data, 
 620:                     'index': link_index
 621:                 }
 622:             
 623:             # Check if it's a category area (for moving to different category)
 624:             if hasattr(widget_at_pos, 'category'):
 625:                 category = widget_at_pos.category
 626:                 
 627:                 # Don't allow dropping in same category (unless it's for reordering)
 628:                 if category != self.dragged_link_data['category']:
 629:                     return {
 630:                         'type': 'move', 
 631:                         'category': category
 632:                     }
 633:             
 634:             # Check parent widgets for category info
 635:             parent = widget_at_pos
 636:             while parent and parent != self:
 637:                 if hasattr(parent, 'category'):
 638:                     category = parent.category
 639:                     if category != self.dragged_link_data['category']:
 640:                         return {
 641:                             'type': 'move', 
 642:                             'category': category
 643:                         }
 644:                 parent = parent.master
 645:                 
 646:             return None
 647:             
 648:         except Exception as e:
 649:             print(f"Error finding drop target: {e}")
 650:             return None
 651: 
 652: class AddEditLinkDialog(CustomDialog):
 653:     """Dialog for adding or editing links"""
 654:     
 655:     def __init__(self, parent, links_manager, taskbar_instance, edit_mode=False, link_data=None, link_index=None):
 656:         title = "Edit Link" if edit_mode else "Add New Link"
 657:         super().__init__(parent, title, width=450, height=280)
 658:         
 659:         self.links_manager = links_manager
 660:         self.taskbar_instance = taskbar_instance
 661:         self.edit_mode = edit_mode
 662:         self.link_data = link_data
 663:         self.link_index = link_index
 664:         
 665:         self.create_form()
 666:         self.add_buttons()
 667:         
 668:         # Prefill data if editing
 669:         if edit_mode and link_data:
 670:             self.name_field.set(link_data['name'])
 671:             self.path_field.set(link_data['path'])
 672:             self.category_field.set(link_data['category'])
 673:     
 674:     def create_form(self):
 675:         """Create the form fields"""
 676:         # Name field
 677:         self.name_field = FormField(self.dialog_content, "Name:", width=35)
 678:         self.name_field.pack(fill=tk.X, pady=5)
 679:         
 680:         # Path field with browse button
 681:         path_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
 682:         path_frame.pack(fill=tk.X, pady=5)
 683:         
 684:         self.path_field = FormField(path_frame, "Path/URL:", width=25)
 685:         self.path_field.pack(side=tk.LEFT, fill=tk.X, expand=True)
 686:         
 687:         browse_btn = tk.Button(path_frame, text="Browse...", command=self.browse_path,
 688:                               bg=Colors.MEDIUM_GREEN, font=Fonts.DIALOG_LABEL)
 689:         browse_btn.pack(side=tk.RIGHT, padx=(5, 0))
 690:         
 691:         # Category field
 692:         self.category_field = FormField(
 693:             self.dialog_content, "Category:", 
 694:             field_type='combobox',
 695:             values=self.links_manager.get_categories(),
 696:         )
 697:         self.category_field.pack(fill=tk.X, pady=5)
 698:         
 699:         # Set default category to "Quick Links"
 700:         categories = self.links_manager.get_categories()
 701:         if "Quick Links" in categories:
 702:             self.category_field.set("Quick Links")
 703:         elif categories:
 704:             self.category_field.set(categories[0])
 705:     
 706:     def browse_path(self):
 707:         """Browse for file or folder"""
 708:         import os
 709:         
 710:         self.grab_release()
 711:         choice = BrowseChoiceDialog.ask(self)
 712:         
 713:         if choice == "file":
 714:             path = filedialog.askopenfilename(parent=self)
 715:         elif choice == "folder":
 716:             path = filedialog.askdirectory(parent=self)
 717:         else:
 718:             # Restore grab and focus when canceling
 719:             self.grab_set()
 720:             self.focus_force()
 721:             return
 722:         
 723:         if path:
 724:             self.path_field.set(path)
 725:             
 726:             # Auto-populate name field if it's empty
 727:             if not self.name_field.get().strip():
 728:                 if choice == "file":
 729:                     # Extract filename without extension
 730:                     filename = os.path.basename(path)
 731:                     name_without_ext = os.path.splitext(filename)[0]
 732:                     self.name_field.set(name_without_ext)
 733:                 elif choice == "folder":
 734:                     # Extract folder name
 735:                     folder_name = os.path.basename(path.rstrip(os.sep))
 736:                     self.name_field.set(folder_name)
 737:         
 738:         # Always restore grab and focus after browse operation
 739:         self.grab_set()
 740:         self.focus_force()
 741:     
 742:     def add_buttons(self):
 743:         """Add Save and Cancel buttons"""
 744:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 745:         button_container.pack(expand=True)
 746:         
 747:         save_btn = tk.Button(button_container, text="Save", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 748:                             command=self.save_link, width=Dimensions.DIALOG_BUTTON_WIDTH,
 749:                             font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 750:         save_btn.pack(side=tk.LEFT, padx=10)
 751:         
 752:         cancel_btn = tk.Button(button_container, text="Cancel", bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 753:                               command=self.cancel, width=Dimensions.DIALOG_BUTTON_WIDTH,
 754:                               font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 755:         cancel_btn.pack(side=tk.LEFT, padx=10)
 756:     
 757:     def save_link(self):
 758:         """Save the link"""
 759:         name = self.name_field.get().strip()
 760:         path = self.path_field.get().strip()
 761:         category = self.category_field.get()
 762:         
 763:         if not name or not path:
 764:             WarningDialog.show(self, "Invalid Input", "Please enter both name and path.")
 765:             return
 766:         
 767:         if self.edit_mode:
 768:             # Update existing link
 769:             icon = self.link_data.get('icon', '📄') if self.link_data else '📄'
 770:             success = self.links_manager.update_link(self.link_index, name, path, category, icon)
 771:         else:
 772:             # Add new link
 773:             success = self.links_manager.add_link(name, path, category)
 774:         
 775:         if success:
 776:             self.destroy()
 777:             # Refresh menu
 778:             self.taskbar_instance.show_links_menu(None)
 779:         else:
 780:             ErrorDialog.show(self, "Error", "Failed to save link.")
 781:     
 782:     @classmethod
 783:     def show_add_dialog(cls, parent, links_manager, taskbar_instance):
 784:         """Show dialog to add a new link"""
 785:         dialog = cls(parent, links_manager, taskbar_instance)
 786:         dialog.lift()
 787:         dialog.focus_force()
 788:         return dialog
 789:     
 790:     @classmethod
 791:     def show_edit_dialog(cls, parent, links_manager, taskbar_instance, link_data, link_index):
 792:         """Show dialog to edit an existing link"""
 793:         dialog = cls(parent, links_manager, taskbar_instance, True, link_data, link_index)
 794:         dialog.lift()
 795:         dialog.focus_force()
 796:         return dialog
 797: 
 798: class BrowseChoiceDialog(CustomDialog):
 799:     """Custom dialog for choosing between file or folder browsing"""
 800:     
 801:     def __init__(self, parent):
 802:         super().__init__(parent, "Browse Options", width=300, height=180)
 803:         
 804:         # Icon and message
 805:         icon_label = tk.Label(self.dialog_content, text="📁", bg=Colors.LIGHT_GREEN,
 806:                              fg=Colors.BLACK, font=('Arial', 24))
 807:         icon_label.pack(pady=10)
 808:         
 809:         message_label = tk.Label(self.dialog_content, text="What would you like to browse for?", 
 810:                                bg=Colors.LIGHT_GREEN, fg=Colors.BLACK, font=Fonts.DIALOG_LABEL)
 811:         message_label.pack(pady=5)
 812:         
 813:         # Add buttons
 814:         self.add_choice_buttons()
 815:         
 816:         # Bind keys
 817:         self.bind('<Escape>', lambda e: self.cancel())
 818:     
 819:     def add_choice_buttons(self):
 820:         """Add File, Folder, and Cancel buttons"""
 821:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 822:         button_container.pack(expand=True)
 823:         
 824:         # File button
 825:         file_btn = tk.Button(button_container, text="File", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 826:                            command=self.choose_file, width=8,
 827:                            font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 828:         file_btn.pack(side=tk.LEFT, padx=5)
 829:         
 830:         # Folder button
 831:         folder_btn = tk.Button(button_container, text="Folder", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 832:                              command=self.choose_folder, width=8,
 833:                              font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 834:         folder_btn.pack(side=tk.LEFT, padx=5)
 835:         
 836:         # Cancel button
 837:         cancel_btn = tk.Button(button_container, text="Cancel", bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 838:                              command=self.cancel, width=8,
 839:                              font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 840:         cancel_btn.pack(side=tk.LEFT, padx=5)
 841:         
 842:         # Focus on File button as default
 843:         file_btn.focus_set()
 844:     
 845:     def choose_file(self):
 846:         """File button clicked"""
 847:         self.result = "file"
 848:         self.destroy()
 849:     
 850:     def choose_folder(self):
 851:         """Folder button clicked"""
 852:         self.result = "folder"
 853:         self.destroy()
 854:     
 855:     @classmethod
 856:     def ask(cls, parent):
 857:         """Show browse choice dialog and return result"""
 858:         dialog = cls(parent)
 859:         dialog.lift()
 860:         dialog.focus_force()
 861:         try:
 862:             parent.wait_window(dialog)
 863:             return dialog.result
 864:         finally:
 865:             # Ensure parent regains focus after dialog closes
 866:             if parent and parent.winfo_exists():
 867:                 parent.focus_force()

────────────────────────────────────────────────────────────────────────────────
FILE: restore_deskop.py
────────────────────────────────────────────────────────────────────────────────
Path: restore_deskop.py
Size: 1.5 KB
Lines: 41 total, 33 non-empty
Characters: 1,488
Type: Desktop restoration utilities
────────────────────────────────────────────────────────────────────────────────

   1: import ctypes
   2: from ctypes import wintypes
   3: import time
   4: 
   5: def fix_desktop_space():
   6:     """Force restore desktop working area"""
   7:     user32 = ctypes.windll.user32
   8:     
   9:     # Method 1: Get actual screen size and restore
  10:     screen_width = user32.GetSystemMetrics(0)
  11:     screen_height = user32.GetSystemMetrics(1)
  12:     
  13:     print(f"Screen size: {screen_width}x{screen_height}")
  14:     
  15:     # Method 2: Force full screen work area
  16:     full_area = wintypes.RECT(0, 0, screen_width, screen_height)
  17:     result = user32.SystemParametersInfoW(0x002F, 0, ctypes.byref(full_area), 0)
  18:     print(f"Full restore attempt: {'Success' if result else 'Failed'}")
  19:     
  20:     # Method 3: Broadcast change to all windows
  21:     HWND_BROADCAST = 0xFFFF
  22:     WM_SETTINGCHANGE = 0x001A
  23:     user32.SendMessageW(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0)
  24:     
  25:     # Method 4: Try with SPIF_SENDCHANGE flag
  26:     SPIF_SENDCHANGE = 0x0002
  27:     SPIF_UPDATEINIFILE = 0x0001
  28:     result2 = user32.SystemParametersInfoW(0x002F, 0, ctypes.byref(full_area), SPIF_SENDCHANGE | SPIF_UPDATEINIFILE)
  29:     print(f"Restore with flags: {'Success' if result2 else 'Failed'}")
  30:     
  31:     # Method 5: Explorer restart (most aggressive)
  32:     print("\nRestarting Explorer to force refresh...")
  33:     import os
  34:     os.system("taskkill /f /im explorer.exe")
  35:     time.sleep(1)
  36:     os.system("start explorer.exe")
  37: 
  38: if __name__ == "__main__":
  39:     fix_desktop_space()
  40:     print("\nDesktop space should be restored!")
  41:     print("If not, try logging out and back in.")

────────────────────────────────────────────────────────────────────────────────
FILE: snip_feature.py
────────────────────────────────────────────────────────────────────────────────
Path: snip_feature.py
Size: 16.1 KB
Lines: 410 total, 331 non-empty
Characters: 16,062
Type: .PY file
────────────────────────────────────────────────────────────────────────────────

   1: # snip_feature.py
   2: """
   3: Screen capture and document integration feature for SuiteView Taskbar
   4: Handles taking screenshots and inserting them into Word documents or Outlook emails
   5: """
   6: 
   7: import os
   8: import tempfile
   9: import time
  10: from datetime import datetime
  11: from PIL import ImageGrab
  12: import win32com.client
  13: import pythoncom
  14: from config import Colors, Fonts
  15: from ui_components import ErrorDialog, WarningDialog
  16: import tkinter as tk
  17: 
  18: class SnippingManager:
  19:     """Manages screen capture and document integration"""
  20:     
  21:     def __init__(self, parent_window=None):
  22:         self.parent_window = parent_window
  23:         self.current_word_app = None
  24:         self.current_word_doc = None
  25:         self.current_outlook_app = None
  26:         self.current_outlook_item = None
  27:         self.temp_image_counter = 0
  28:         
  29:         # Create temp directory for screenshots
  30:         self.temp_dir = os.path.join(tempfile.gettempdir(), "SuiteView_Screenshots")
  31:         self.ensure_temp_directory()
  32:     
  33:     def ensure_temp_directory(self):
  34:         """Ensure temporary directory exists for storing screenshots"""
  35:         try:
  36:             if not os.path.exists(self.temp_dir):
  37:                 os.makedirs(self.temp_dir)
  38:         except Exception as e:
  39:             print(f"Warning: Could not create temp directory: {e}")
  40:             self.temp_dir = tempfile.gettempdir()
  41:     
  42:     def capture_primary_screen(self):
  43:         """Capture screenshot of primary monitor and save to temp file"""
  44:         try:
  45:             # Capture the primary screen
  46:             screenshot = ImageGrab.grab()
  47:             
  48:             # Generate unique filename
  49:             timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
  50:             self.temp_image_counter += 1
  51:             filename = f"screenshot_{timestamp}_{self.temp_image_counter}.png"
  52:             filepath = os.path.join(self.temp_dir, filename)
  53:             
  54:             # Save screenshot
  55:             screenshot.save(filepath, "PNG")
  56:             print(f"Screenshot saved: {filepath}")
  57:             return filepath
  58:             
  59:         except Exception as e:
  60:             self._show_error("Screenshot Error", f"Failed to capture screenshot: {str(e)}")
  61:             return None
  62:     
  63:     def snip_to_target(self, target_app="Word"):
  64:         """Main method to handle snipping to specified application"""
  65:         try:
  66:             # Capture screenshot first
  67:             image_path = self.capture_primary_screen()
  68:             if not image_path:
  69:                 return False
  70:             
  71:             # Route to appropriate handler
  72:             if target_app.lower() == "word":
  73:                 return self.snip_to_word(image_path)
  74:             elif target_app.lower() == "outlook":
  75:                 return self.snip_to_outlook(image_path)
  76:             else:
  77:                 self._show_error("Invalid Target", f"Unknown target application: {target_app}")
  78:                 return False
  79:                 
  80:         except Exception as e:
  81:             self._show_error("Snip Error", f"Failed to complete snip operation: {str(e)}")
  82:             return False
  83:     
  84:     def snip_to_word(self, image_path):
  85:         """Insert screenshot into Word document"""
  86:         try:
  87:             # Check if we have an active Word document
  88:             if not self._is_word_document_active():
  89:                 # Create new Word document
  90:                 if not self._create_new_word_document():
  91:                     return False
  92:             
  93:             # Insert image into document
  94:             if self._insert_image_to_word(image_path):
  95:                 print("Successfully added screenshot to Word document")
  96:                 return True
  97:             else:
  98:                 return False
  99:                 
 100:         except Exception as e:
 101:             self._show_error("Word Error", f"Failed to add screenshot to Word: {str(e)}")
 102:             return False
 103:     
 104:     def snip_to_outlook(self, image_path):
 105:         """Insert screenshot into Outlook email"""
 106:         try:
 107:             # Check if we have an active Outlook email
 108:             if not self._is_outlook_email_active():
 109:                 # Create new Outlook email
 110:                 if not self._create_new_outlook_email():
 111:                     return False
 112:             
 113:             # Insert image into email
 114:             if self._insert_image_to_outlook(image_path):
 115:                 print("Successfully added screenshot to Outlook email")
 116:                 return True
 117:             else:
 118:                 return False
 119:                 
 120:         except Exception as e:
 121:             self._show_error("Outlook Error", f"Failed to add screenshot to Outlook: {str(e)}")
 122:             return False
 123:     
 124:     def _is_word_document_active(self):
 125:         """Check if the current Word document is still active"""
 126:         try:
 127:             if not self.current_word_app or not self.current_word_doc:
 128:                 return False
 129:             
 130:             # Try to access the document - this will fail if it's closed
 131:             _ = self.current_word_doc.Name
 132:             
 133:             # Check if the document is still in the application's documents collection
 134:             for doc in self.current_word_app.Documents:
 135:                 if doc.Name == self.current_word_doc.Name:
 136:                     return True
 137:             
 138:             return False
 139:             
 140:         except Exception:
 141:             # If any error occurs, assume document is no longer active
 142:             self.current_word_doc = None
 143:             return False
 144:     
 145:     def _is_outlook_email_active(self):
 146:         """Check if the current Outlook email is still active"""
 147:         try:
 148:             if not self.current_outlook_app or not self.current_outlook_item:
 149:                 return False
 150:             
 151:             # Try to access the email item - this will fail if it's closed/sent
 152:             _ = self.current_outlook_item.Subject
 153:             return True
 154:             
 155:         except Exception:
 156:             # If any error occurs, assume email is no longer active
 157:             self.current_outlook_item = None
 158:             return False
 159:     
 160:     def _create_new_word_document(self):
 161:         """Create a new Word document"""
 162:         try:
 163:             # Initialize COM
 164:             pythoncom.CoInitialize()
 165:             
 166:             # Connect to or create Word application
 167:             try:
 168:                 self.current_word_app = win32com.client.GetActiveObject("Word.Application")
 169:             except:
 170:                 self.current_word_app = win32com.client.Dispatch("Word.Application")
 171:             
 172:             # Make Word visible
 173:             self.current_word_app.Visible = True
 174:             
 175:             # Create new document
 176:             self.current_word_doc = self.current_word_app.Documents.Add()
 177:             
 178:             # Add a title
 179:             title_range = self.current_word_doc.Range(0, 0)
 180:             title_range.Text = f"Screenshots - {datetime.now().strftime('%Y-%m-%d %I:%M %p')}\n\n"
 181:             title_range.Font.Bold = True
 182:             title_range.Font.Size = 14
 183:             
 184:             # Move cursor to end for image insertion
 185:             # Use numeric constant instead of named constant to avoid import issues
 186:             self.current_word_doc.Range().Collapse(0)  # 0 = wdCollapseEnd
 187:             
 188:             print("Created new Word document")
 189:             return True
 190:             
 191:         except Exception as e:
 192:             self._show_error("Word Creation Error", f"Failed to create Word document: {str(e)}")
 193:             self.current_word_app = None
 194:             self.current_word_doc = None
 195:             return False
 196:     
 197:     def _create_new_outlook_email(self):
 198:         """Create a new Outlook email"""
 199:         try:
 200:             # Initialize COM
 201:             pythoncom.CoInitialize()
 202:             
 203:             # Connect to Outlook
 204:             try:
 205:                 self.current_outlook_app = win32com.client.GetActiveObject("Outlook.Application")
 206:             except:
 207:                 self.current_outlook_app = win32com.client.Dispatch("Outlook.Application")
 208:             
 209:             # Create new mail item
 210:             self.current_outlook_item = self.current_outlook_app.CreateItem(0)  # 0 = olMailItem
 211:             
 212:             # Set email properties
 213:             self.current_outlook_item.Subject = f"Screenshots - {datetime.now().strftime('%Y-%m-%d %I:%M %p')}"
 214:             self.current_outlook_item.Body = "Screenshots captured:\n\n"
 215:             
 216:             # Display the email
 217:             self.current_outlook_item.Display()
 218:             
 219:             print("Created new Outlook email")
 220:             return True
 221:             
 222:         except Exception as e:
 223:             self._show_error("Outlook Creation Error", f"Failed to create Outlook email: {str(e)}")
 224:             self.current_outlook_app = None
 225:             self.current_outlook_item = None
 226:             return False
 227:     
 228:     def _insert_image_to_word(self, image_path):
 229:         """Insert image into the current Word document"""
 230:         try:
 231:             if not self.current_word_doc:
 232:                 return False
 233:             
 234:             # Always position at the end of the document to preserve the title
 235:             doc_end = self.current_word_doc.Range()
 236:             doc_end.Collapse(0)  # 0 = wdCollapseEnd
 237:             doc_end.Select()
 238:             
 239:             # Get the selection at the end of the document
 240:             selection = self.current_word_app.Selection
 241:             
 242:             # Add timestamp before image
 243:             timestamp_text = f"Screenshot taken: {datetime.now().strftime('%I:%M:%S %p')}\n"
 244:             selection.TypeText(timestamp_text)
 245:             
 246:             # Insert the image
 247:             inline_shape = selection.InlineShapes.AddPicture(
 248:                 FileName=image_path,
 249:                 LinkToFile=False,
 250:                 SaveWithDocument=True
 251:             )
 252:             
 253:             # Scale image to fit page width (optional)
 254:             page_width = self.current_word_doc.PageSetup.PageWidth - \
 255:                         self.current_word_doc.PageSetup.LeftMargin - \
 256:                         self.current_word_doc.PageSetup.RightMargin
 257:             
 258:             if inline_shape.Width > page_width:
 259:                 scale_factor = page_width / inline_shape.Width
 260:                 inline_shape.Width = page_width
 261:                 inline_shape.Height = inline_shape.Height * scale_factor
 262:             
 263:             # Add some space after the image
 264:             selection.TypeText("\n\n")
 265:             
 266:             # Clean up temp file
 267:             self._cleanup_temp_file(image_path)
 268:             
 269:             return True
 270:             
 271:         except Exception as e:
 272:             print(f"Error inserting image to Word: {e}")
 273:             return False
 274:     
 275:     def _insert_image_to_outlook(self, image_path):
 276:         """Insert image into the current Outlook email"""
 277:         try:
 278:             if not self.current_outlook_item:
 279:                 return False
 280:             
 281:             # Get the current body and add timestamp
 282:             current_body = self.current_outlook_item.Body if self.current_outlook_item.Body else ""
 283:             timestamp_text = f"Screenshot taken: {datetime.now().strftime('%I:%M:%S %p')}\n"
 284:             
 285:             # Add the image as an attachment and embed it
 286:             attachment = self.current_outlook_item.Attachments.Add(image_path)
 287:             
 288:             # For HTML emails, we could embed the image inline, but for simplicity
 289:             # we'll just attach it and add a note in the body
 290:             self.current_outlook_item.Body = current_body + timestamp_text + "[Screenshot attached]\n\n"
 291:             
 292:             # Clean up temp file
 293:             self._cleanup_temp_file(image_path)
 294:             
 295:             return True
 296:             
 297:         except Exception as e:
 298:             print(f"Error inserting image to Outlook: {e}")
 299:             return False
 300:     
 301:     def _cleanup_temp_file(self, filepath):
 302:         """Clean up temporary image file"""
 303:         try:
 304:             # Wait a moment to ensure file is not locked
 305:             time.sleep(0.1)
 306:             if os.path.exists(filepath):
 307:                 os.remove(filepath)
 308:         except Exception as e:
 309:             print(f"Warning: Could not delete temp file {filepath}: {e}")
 310:     
 311:     def _show_error(self, title, message):
 312:         """Show error dialog to user"""
 313:         print(f"Error - {title}: {message}")
 314:         if self.parent_window:
 315:             try:
 316:                 ErrorDialog.show(self.parent_window, title, message)
 317:             except:
 318:                 pass  # Fallback to console output only
 319:     
 320:     def cleanup_temp_directory(self):
 321:         """Clean up old temporary files"""
 322:         try:
 323:             if os.path.exists(self.temp_dir):
 324:                 for filename in os.listdir(self.temp_dir):
 325:                     if filename.startswith("screenshot_"):
 326:                         filepath = os.path.join(self.temp_dir, filename)
 327:                         # Delete files older than 1 hour
 328:                         if time.time() - os.path.getctime(filepath) > 3600:
 329:                             os.remove(filepath)
 330:         except Exception as e:
 331:             print(f"Warning: Could not clean temp directory: {e}")
 332:     
 333:     def force_new_document(self, target_app="Word"):
 334:         """Force creation of a new document (useful for manual reset)"""
 335:         if target_app.lower() == "word":
 336:             self.current_word_doc = None
 337:             self.current_word_app = None
 338:         elif target_app.lower() == "outlook":
 339:             self.current_outlook_item = None
 340:             self.current_outlook_app = None
 341: 
 342: class SnipUI:
 343:     """UI components for the Snip feature"""
 344:     
 345:     @staticmethod
 346:     def create_snip_button(parent, snipping_manager, target_var):
 347:         """Create the Snip button"""
 348:         def on_snip_click():
 349:             target = target_var.get()
 350:             success = snipping_manager.snip_to_target(target)
 351:             if success:
 352:                 print(f"Screenshot successfully added to {target}")
 353:         
 354:         snip_btn = tk.Button(parent, text="Snip", 
 355:                            bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 356:                            relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, 
 357:                            cursor='hand2', activebackground=Colors.HOVER_GREEN, 
 358:                            bd=0, padx=15, command=on_snip_click)
 359:         return snip_btn
 360:     
 361:     @staticmethod
 362:     def create_target_combobox(parent, default_value="Word"):
 363:         """Create the target application combobox"""
 364:         from tkinter import ttk
 365:         
 366:         target_var = tk.StringVar(value=default_value)
 367:         combo = ttk.Combobox(parent, textvariable=target_var, 
 368:                            values=["Word", "Outlook"],
 369:                            state='readonly', width=8)
 370:         
 371:         # Style the combobox to match the app theme
 372:         style = ttk.Style()
 373:         style.theme_use('default')
 374:         style.configure('Snip.TCombobox', 
 375:                        fieldbackground=Colors.MEDIUM_GREEN, 
 376:                        background=Colors.MEDIUM_GREEN)
 377:         combo.configure(style='Snip.TCombobox')
 378:         
 379:         return combo, target_var
 380: 
 381: # Integration helper functions for taskbar.py
 382: def add_snip_feature_to_taskbar(taskbar_instance):
 383:     """Add Snip feature to the existing taskbar"""
 384:     
 385:     # Create snipping manager
 386:     snipping_manager = SnippingManager(taskbar_instance.root)
 387:     
 388:     # Create frame for snip controls
 389:     snip_frame = tk.Frame(taskbar_instance.main_frame, bg=Colors.DARK_GREEN)
 390:     snip_frame.pack(side=tk.LEFT, padx=10)
 391:     
 392:     # Create target selection combobox
 393:     combo, target_var = SnipUI.create_target_combobox(snip_frame)
 394:     combo.pack(side=tk.LEFT, padx=(0, 5))
 395:     
 396:     # Create snip button
 397:     snip_btn = SnipUI.create_snip_button(snip_frame, snipping_manager, target_var)
 398:     snip_btn.pack(side=tk.LEFT)
 399:     
 400:     # Store reference for cleanup
 401:     taskbar_instance.snipping_manager = snipping_manager
 402:     
 403:     # Schedule periodic cleanup of temp files
 404:     def cleanup_temp_files():
 405:         snipping_manager.cleanup_temp_directory()
 406:         taskbar_instance.root.after(300000, cleanup_temp_files)  # Every 5 minutes
 407:     
 408:     taskbar_instance.root.after(300000, cleanup_temp_files)
 409:     
 410:     return snipping_manager

────────────────────────────────────────────────────────────────────────────────
FILE: taskbar.py
────────────────────────────────────────────────────────────────────────────────
Path: taskbar.py
Size: 22.4 KB
Lines: 542 total, 433 non-empty
Characters: 22,430
Type: Core taskbar functionality and UI
────────────────────────────────────────────────────────────────────────────────

   1: # taskbar.py (UPDATED)
   2: """
   3: Core taskbar window and layout for SuiteView Taskbar Application
   4: """
   5: 
   6: import tkinter as tk
   7: from tkinter import ttk
   8: import sys
   9: from ctypes import wintypes
  10: 
  11: from config import Colors, Fonts, Dimensions, Settings
  12: from utils import WindowsUtils, UIUtils
  13: from links_manager import LinksManager
  14: from quick_links import QuickLinksMenu
  15: from snip_feature import add_snip_feature_to_taskbar
  16: from folder_inventory import add_folder_inventory_to_taskbar  # UPDATED IMPORT
  17: 
  18: from window_manager import WindowManager
  19: from windows_menu import WindowsMenu
  20: from pinned_windows import PinnedWindowsSection
  21: from email_manager import EmailManager
  22: from email_options_menu import EmailOptionsMenu
  23: 
  24: 
  25: class SuiteViewTaskbar:
  26:     """Main taskbar application window"""
  27:     
  28:     def __init__(self):
  29:         self.root = tk.Tk()
  30:         self.links_manager = LinksManager()
  31:         self.window_manager = WindowManager()
  32: 
  33:         # Initialize these BEFORE creating UI
  34:         self.links_menu = None
  35:         self.windows_menu = None
  36:         self.pinned_section = None  # Initialize to None
  37:         self.windows_menu_geometry = None
  38:         self.email_options_menu = None  # Initialize email options menu tracker
  39:         self.email_menu_closing = False  # Flag to prevent immediate reopen
  40:         
  41:         # Store original work area for restoration
  42:         self.original_work_area = WindowsUtils.get_work_area()
  43:         
  44:         # Get screen dimensions
  45:         self.screen_width, self.screen_height = WindowsUtils.get_screen_dimensions()
  46:         
  47:         # Get Windows taskbar height for better positioning
  48:         self.windows_taskbar_height = WindowsUtils.get_windows_taskbar_height()
  49:         
  50:         # Position the custom taskbar above Windows taskbar
  51:         self.y_position = self.screen_height - self.windows_taskbar_height - Dimensions.TASKBAR_HEIGHT
  52:         
  53:         # Setup the window
  54:         self.setup_window()
  55:         
  56:         # Create taskbar content
  57:         self.create_taskbar_content()
  58:         
  59:         # Setup event bindings
  60:         self.bind_events()
  61:         
  62:         # Apply Windows API modifications
  63:         self.setup_windows_integration()
  64:         
  65:     def setup_window(self):
  66:         """Configure the main window properties"""
  67:         # Remove window decorations
  68:         self.root.overrideredirect(True)
  69:         
  70:         # Set window attributes
  71:         self.root.attributes('-topmost', True)
  72:         self.root.attributes('-alpha', Settings.TASKBAR_OPACITY)
  73:         
  74:         # Configure window geometry
  75:         self.root.geometry(f"{self.screen_width}x{Dimensions.TASKBAR_HEIGHT}+0+{self.y_position}")
  76:         
  77:         # Set background color to dark green
  78:         self.root.configure(bg=Colors.DARK_GREEN)
  79:     
  80:     def create_taskbar_content(self):
  81:         """Create the taskbar UI elements"""
  82:         # Create main frame
  83:         self.main_frame = tk.Frame(self.root, bg=Colors.DARK_GREEN, highlightthickness=0)
  84:         self.main_frame.pack(fill=tk.BOTH, expand=True)
  85:         
  86:         # SuiteView Logo/Title
  87:         self.create_logo_section()
  88:         
  89:         # Separator
  90:         separator = UIUtils.create_separator(self.main_frame, Colors.DARK_GREEN, width=2)
  91:         separator.pack(side=tk.LEFT, fill=tk.Y, padx=10)
  92:         
  93:         # Main buttons
  94:         self.create_main_buttons()
  95:         
  96:         # Right side elements
  97:         self.create_right_side_elements()
  98:     
  99:     def create_logo_section(self):
 100:         """Create the SuiteView logo/title section"""
 101:         logo_frame = tk.Frame(self.main_frame, bg=Colors.DARK_GREEN)
 102:         logo_frame.pack(side=tk.LEFT, padx=10)
 103:         
 104:         # Logo text with styling
 105:         logo_label = tk.Label(logo_frame, text=Settings.APP_NAME, bg=Colors.DARK_GREEN, 
 106:                              fg=Colors.WHITE, font=Fonts.TASKBAR_TITLE)
 107:         logo_label.pack()
 108:         logo_label.bind("<Button-3>", self.show_links_menu)
 109:     
 110:     def create_main_buttons(self):
 111:         """Create the main taskbar buttons"""
 112:         # Existing buttons
 113:         buttons_data = [
 114:             ("Get Policy", None),
 115:             ("Cyber", None),
 116:             ("TAI", None)
 117:         ]
 118:         
 119:         for text, command in buttons_data:
 120:             btn = tk.Button(self.main_frame, text=text, bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 121:                         relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, cursor='hand2',
 122:                         activebackground=Colors.HOVER_GREEN, bd=0, padx=15)
 123:             btn.pack(side=tk.LEFT, padx=5)
 124:             btn.bind("<Button-3>", self.show_links_menu)
 125:             if command:
 126:                 btn.configure(command=command)
 127:         
 128:         # Add separator before new features
 129:         separator = UIUtils.create_separator(self.main_frame, Colors.DARK_GREEN, width=2)
 130:         separator.pack(side=tk.LEFT, fill=tk.Y, padx=10)
 131:         
 132:         # Add Inventory feature
 133:         inventory_btn = add_folder_inventory_to_taskbar(self)
 134:         inventory_btn.pack(side=tk.LEFT, padx=5)
 135:         inventory_btn.bind("<Button-3>", self.show_links_menu)
 136:         
 137:         # Add separator before Snip feature
 138:         separator2 = UIUtils.create_separator(self.main_frame, Colors.DARK_GREEN, width=2)
 139:         separator2.pack(side=tk.LEFT, fill=tk.Y, padx=10)
 140:         
 141:         # Add Snip feature
 142:         self.snipping_manager = add_snip_feature_to_taskbar(self)
 143:         
 144:         # Add separator before pinned windows section
 145:         separator3 = UIUtils.create_separator(self.main_frame, Colors.DARK_GREEN, width=2)
 146:         separator3.pack(side=tk.LEFT, fill=tk.Y, padx=10)
 147:         
 148:         # Create and store pinned windows section
 149:         print(f"Creating pinned section...")
 150:         self.pinned_section = PinnedWindowsSection(self.main_frame, self.window_manager, self.on_windows_pinned)
 151:         self.pinned_section.pack(side=tk.LEFT, fill=tk.Y)  # Remove padx, let it grow as needed
 152:         
 153:         # Debug to confirm it's created and assigned
 154:         #print(f"Pinned section created and assigned: {self.pinned_section}")
 155:         #print(f"self.pinned_section is not None: {self.pinned_section is not None}")
 156:     
 157:     def create_right_side_elements(self):
 158:         """Create the right side elements of the taskbar"""
 159:         
 160:         # X close button
 161:         close_btn = tk.Label(self.main_frame, text="X", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 162:                             font=(Fonts.TASKBAR_BUTTON[0], Fonts.TASKBAR_BUTTON[1], 'bold'), 
 163:                             cursor='hand2')
 164:         close_btn.pack(side=tk.RIGHT, padx=5)
 165:         close_btn.bind("<Button-1>", self.close_app)
 166:     
 167:         #Windows button
 168:         windows_btn = tk.Button(self.main_frame, text="Windows", 
 169:                             bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 170:                             relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, 
 171:                             cursor='hand2', activebackground=Colors.HOVER_GREEN, 
 172:                             bd=0, padx=15, command=self.toggle_windows_menu)
 173:         windows_btn.pack(side=tk.RIGHT, padx=5)
 174: 
 175:         
 176:         # Add Emails button
 177:         emails_btn = tk.Button(self.main_frame, text="Emails", 
 178:                         bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 179:                         relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, 
 180:                         cursor='hand2', activebackground=Colors.HOVER_GREEN, 
 181:                         bd=0, padx=15, command=self.show_email_options_menu)
 182:         emails_btn.pack(side=tk.LEFT, padx=5)
 183: 
 184: 
 185:     def bind_events(self):
 186:         """Bind event handlers"""
 187:         # Main window events
 188:         self.root.bind("<Button-3>", self.show_links_menu)
 189:         self.main_frame.bind("<Button-3>", self.show_links_menu)
 190:         
 191:         # Emergency exit keys
 192:         self.root.bind("<Escape>", self.close_app)
 193:         self.root.bind("<Control-q>", self.close_app)
 194:         self.root.bind("<Control-Q>", self.close_app)
 195:         self.root.bind("<Alt-F4>", self.close_app)
 196:     
 197:     def setup_windows_integration(self):
 198:         """Setup Windows API integration"""
 199:         # Keep window on top using Windows API
 200:         self.set_always_on_top()
 201:         
 202:         # Adjust desktop working area
 203:         self.adjust_work_area()
 204:         
 205:     def show_links_menu(self, event):
 206:         """Show the right-click links menu positioned above the taskbar"""
 207:         if self.links_menu:
 208:             self.links_menu.destroy()
 209:         
 210:         # Create the menu at a temporary position first
 211:         temp_x, temp_y = 0, 0
 212:         self.links_menu = QuickLinksMenu(self.root, self, temp_x, temp_y)
 213:         
 214:         # Get cursor position or use center position
 215:         if event:
 216:             x = self.root.winfo_pointerx() - 200  # Offset to center menu on cursor
 217:         else:
 218:             x = self.screen_width // 2 - 200  # Center horizontally
 219:         
 220:         # Calculate proper position above YOUR custom taskbar
 221:         final_y = self.y_position - self.links_menu.menu_height - 5  # 5px gap above YOUR taskbar
 222:         final_x = x
 223:         
 224:         # Reposition the menu to the correct location
 225:         self.links_menu.geometry(f"+{final_x}+{final_y}")
 226:         
 227:         # Debug output
 228:         print(f"Estimated height: {self.links_menu.menu_height}")
 229:         print(f"Positioned menu at: {final_x}, {final_y}")
 230:         print(f"Menu bottom should be at: {final_y + self.links_menu.menu_height}")
 231:        
 232:     def show_windows_menu(self, event=None):
 233:         """Show the windows management menu - toggle if already open"""
 234:         if self.windows_menu and self.windows_menu.winfo_exists():
 235:             # If menu exists and is open, close it
 236:             self.windows_menu.close_window()
 237:             self.windows_menu = None
 238:         else:
 239:             # Otherwise, create and show it
 240:             # Get screen dimensions
 241:             screen_width = self.root.winfo_screenwidth()
 242:             
 243:             # Position the menu above the taskbar, centered on screen
 244:             x = (screen_width - 700) // 2  # Center a 700px wide menu
 245:             y = self.y_position - 600  # Default height assumption
 246:             
 247:     def set_always_on_top(self):
 248:         """Force window to stay on top using Windows API"""
 249:         WindowsUtils.set_window_topmost(self.root.winfo_id())
 250:     
 251:     def adjust_work_area(self):
 252:         """Adjust desktop work area to make room for taskbar"""
 253:         if self.original_work_area:
 254:             work_area = wintypes.RECT()
 255:             work_area.left = self.original_work_area.left
 256:             work_area.top = self.original_work_area.top
 257:             work_area.right = self.original_work_area.right
 258:             work_area.bottom = self.y_position
 259:             
 260:             success = WindowsUtils.set_work_area(work_area)
 261:             if not success:
 262:                 print("Could not adjust work area. May require admin privileges.")
 263:     
 264:     def close_app(self, event=None):
 265:         """Close the application"""
 266:         try:
 267:             self.window_manager.unhide_all_windows()
 268:             self.restore_work_area()
 269:         except:
 270:             pass  # Don't fail if restore doesn't work
 271:         
 272:         # Clean up snipping manager if it exists
 273:         if hasattr(self, 'snipping_manager'):
 274:             try:
 275:                 self.snipping_manager.cleanup_temp_directory()
 276:             except:
 277:                 pass
 278:         
 279:         # Force kill any open dialogs
 280:         for child in self.root.winfo_children():
 281:             if isinstance(child, tk.Toplevel):
 282:                 child.destroy()
 283:         
 284:         self.root.quit()
 285:         self.root.destroy()
 286:         sys.exit(0)
 287:     
 288:     def restore_work_area(self):
 289:         """Restore original work area"""
 290:         if self.original_work_area:
 291:             WindowsUtils.restore_work_area(self.original_work_area)
 292:     
 293:     def run(self):
 294:         """Start the application"""
 295:         """Start the application"""
 296:         # Verify setup before starting
 297:         #self.verify_setup()
 298:         
 299:         # Start the periodic topmost maintenance
 300:         self.root.after(Settings.AUTO_REFRESH_INTERVAL, self.maintain_topmost)
 301:         
 302:         # Start window state monitoring
 303:         self.root.after(1000, self.start_window_monitoring)  # Start after 1 second
 304: 
 305:         # Start the main event loop
 306:         self.root.mainloop()
 307:     
 308:     def maintain_topmost(self):
 309:         """Periodically ensure window stays on top"""
 310:         self.set_always_on_top()
 311: 
 312:         # # Update pinned window button states
 313:         # if self.pinned_section:
 314:         #     self.pinned_section.update_window_states()
 315: 
 316:         self.root.after(Settings.AUTO_REFRESH_INTERVAL, self.maintain_topmost)
 317: 
 318:     def toggle_windows_menu(self):
 319:         """Toggle the windows management menu"""
 320:         if self.windows_menu and hasattr(self.windows_menu, 'winfo_exists'):
 321:             try:
 322:                 if self.windows_menu.winfo_exists():
 323:                     # Store current geometry BEFORE closing
 324:                     self.windows_menu_geometry = self.windows_menu.get_current_geometry()
 325:                     print(f"Storing geometry: {self.windows_menu_geometry}")  # Debug
 326:                     self.windows_menu.close_window()
 327:                     self.windows_menu = None
 328:                     return
 329:             except:
 330:                 self.windows_menu = None
 331:         
 332:         # Create new windows menu
 333:         print(f"Class: {type(self).__name__}")  # Debug
 334:         self.windows_menu = WindowsMenu(self, self.window_manager, 
 335:                                     self.on_windows_pinned,
 336:                                     self.windows_menu_geometry)
 337:     
 338:     def on_windows_pinned(self):
 339:         """Callback when windows are pinned/unpinned"""
 340:         #print(f"\n=== ON_WINDOWS_PINNED CALLED ===")
 341:         #print(f"Pinned section: {self.pinned_section}")
 342:         
 343:         if self.pinned_section:
 344:             print(f"Refreshing pinned section...")
 345:             self.pinned_section.refresh()
 346:         else:
 347:             print(f"ERROR: pinned_section is None!")
 348:         
 349:         # Always refresh the Windows Manager if it's open to update the list
 350:         if self.windows_menu and hasattr(self.windows_menu, 'winfo_exists'):
 351:             try:
 352:                 if self.windows_menu.winfo_exists():
 353:                     print(f"Refreshing Windows Manager...")
 354:                     self.windows_menu.refresh_window_list()
 355:                 else:
 356:                     print(f"Windows Manager exists but window is destroyed")
 357:             except Exception as e:
 358:                 print(f"Error refreshing Windows Manager: {e}")
 359:                 self.windows_menu = None
 360:         else:
 361:             print(f"Windows Manager is not open")
 362:             
 363:         #print(f"=== END ON_WINDOWS_PINNED ===\n")
 364: 
 365: 
 366:     def start_window_monitoring(self):
 367:         """Start monitoring for closed windows"""
 368:         self.check_window_states()
 369:         
 370:     def check_window_states(self):
 371:         """Periodically check if pinned windows still exist"""
 372:         try:
 373:             if hasattr(self, 'pinned_section') and self.pinned_section:
 374:                 # Get current pinned windows
 375:                 pinned_windows = self.window_manager.get_pinned_windows()
 376:                 windows_to_unpin = []
 377:                 
 378:                 for window in pinned_windows:
 379:                     # Check if window still exists
 380:                     if not window.is_valid():
 381:                         print(f"Window {window.display_name} no longer exists, unpinning...")
 382:                         windows_to_unpin.append(window)
 383:                 
 384:                 # Unpin any closed windows
 385:                 if windows_to_unpin:
 386:                     for window in windows_to_unpin:
 387:                         self.window_manager.unpin_window(window)
 388:                     
 389:                     # Refresh the pinned section
 390:                     self.pinned_section.refresh()
 391:                     
 392:                     # Also refresh Windows Manager if it's open
 393:                     if hasattr(self, 'windows_menu') and self.windows_menu:
 394:                         try:
 395:                             if self.windows_menu.winfo_exists():
 396:                                 self.windows_menu.refresh_window_list()
 397:                         except:
 398:                             pass
 399:         
 400:         except Exception as e:
 401:             print(f"Error checking window states: {e}")
 402:         
 403:         # Schedule next check (every 2 seconds)
 404:         self.root.after(2000, self.check_window_states)
 405: 
 406:     def verify_setup(self):
 407:         """Verify all components are properly initialized"""
 408:         print(f"\n=== VERIFYING TASKBAR SETUP ===")
 409:         print(f"Window manager: {self.window_manager}")
 410:         print(f"Pinned section: {self.pinned_section}")
 411:         print(f"Pinned section type: {type(self.pinned_section)}")
 412:         if self.pinned_section:
 413:             print(f"Pinned section parent: {self.pinned_section.master}")
 414:             print(f"Pinned section visible: {self.pinned_section.winfo_exists()}")
 415:         print(f"=== END VERIFICATION ===\n")
 416:     
 417:     def check_window_states(self):
 418:         """Periodically check for closed windows, new windows, and title changes"""
 419:         try:
 420:             # Get current window list
 421:             current_windows = self.window_manager.get_relevant_windows()
 422:             current_hwnds = {w.hwnd for w in current_windows}
 423:             
 424:             # Check for closed pinned windows
 425:             if hasattr(self, 'pinned_section') and self.pinned_section:
 426:                 pinned_windows = self.window_manager.get_pinned_windows()
 427:                 windows_to_unpin = []
 428:                 
 429:                 for window in pinned_windows:
 430:                     if not window.is_valid():
 431:                         print(f"Window {window.display_name} no longer exists, unpinning...")
 432:                         windows_to_unpin.append(window)
 433:                 
 434:                 if windows_to_unpin:
 435:                     for window in windows_to_unpin:
 436:                         self.window_manager.unpin_window(window)
 437:                     self.pinned_section.refresh()
 438:             
 439:             # Initialize tracking dictionaries if they don't exist
 440:             if not hasattr(self, '_previous_hwnds'):
 441:                 self._previous_hwnds = current_hwnds
 442:                 self._window_titles = {}
 443:             
 444:             # Check for new windows
 445:             new_hwnds = current_hwnds - self._previous_hwnds
 446:             if new_hwnds:
 447:                 print(f"Detected {len(new_hwnds)} new window(s)")
 448:                 self._refresh_windows_menu()
 449:             
 450:             # Check for title changes in existing windows
 451:             title_changed = False
 452:             for window in current_windows:
 453:                 hwnd = window.hwnd
 454:                 current_title = window.title
 455:                 
 456:                 # Store or compare title
 457:                 if hwnd in self._window_titles:
 458:                     if self._window_titles[hwnd] != current_title:
 459:                         #print(f"Title changed for {window.app_name}: '{self._window_titles[hwnd]}' -> '{current_title}'")
 460:                         title_changed = True
 461:                         self._window_titles[hwnd] = current_title
 462:                         
 463:                         # Update the window's display name
 464:                         window.display_name = window._create_display_name()
 465:                         
 466:                         # Update pinned button if this window is pinned
 467:                         if window.is_pinned and hasattr(self, 'pinned_section') and self.pinned_section:
 468:                             self.pinned_section.update_window_title(window)
 469:                 else:
 470:                     self._window_titles[hwnd] = current_title
 471:             
 472:             # Clean up titles for closed windows
 473:             closed_hwnds = set(self._window_titles.keys()) - current_hwnds
 474:             for hwnd in closed_hwnds:
 475:                 del self._window_titles[hwnd]
 476:             
 477:             # Refresh Windows menu if titles changed
 478:             if title_changed:
 479:                 self._refresh_windows_menu()
 480:             
 481:             # Update previous list for next check
 482:             self._previous_hwnds = current_hwnds
 483:         
 484:         except Exception as e:
 485:             print(f"Error checking window states: {e}")
 486:         
 487:         # Schedule next check (every 1 second for responsive updates)
 488:         self.root.after(1000, self.check_window_states)
 489: 
 490:     def _refresh_windows_menu(self):
 491:         """Helper method to refresh Windows menu if it's open"""
 492:         if hasattr(self, 'windows_menu') and self.windows_menu:
 493:             try:
 494:                 if self.windows_menu.winfo_exists():
 495:                     print("Refreshing Windows Manager...")
 496:                     self.windows_menu.refresh_window_list()
 497:             except:
 498:                 pass
 499: 
 500:     def show_email_options_menu(self):
 501:         """Show the email options popup menu - toggle if already open"""
 502:         from email_options_menu import EmailOptionsMenu
 503:         
 504:         # Check if email options menu is already open
 505:         if hasattr(self, 'email_options_menu') and self.email_options_menu is not None:
 506:             try:
 507:                 if self.email_options_menu.winfo_exists():
 508:                     # Menu is open, close it
 509:                     self.email_options_menu.destroy()
 510:                     self.email_options_menu = None
 511:                     return
 512:             except:
 513:                 self.email_options_menu = None
 514:         
 515:         # Get button position
 516:         emails_btn = None
 517:         for widget in self.main_frame.winfo_children():
 518:             if isinstance(widget, tk.Button) and widget.cget('text') == 'Emails':
 519:                 emails_btn = widget
 520:                 break
 521:         
 522:         if emails_btn:
 523:             # Create menu at temporary position to get its height
 524:             temp_menu = EmailOptionsMenu(self.root, 0, 0, self)
 525:             temp_menu.update_idletasks()
 526:             menu_height = temp_menu.winfo_reqheight()
 527:             temp_menu.destroy()
 528:             
 529:             # Position menu so its bottom edge touches the top of the taskbar
 530:             x = emails_btn.winfo_rootx()
 531:             taskbar_top = self.root.winfo_rooty()
 532:             y = taskbar_top - menu_height  # No gap, right at the edge
 533:             
 534:             # Create and show the options menu at calculated position
 535:             self.email_options_menu = EmailOptionsMenu(self.root, x, y, self)
 536:             
 537:             # Set up cleanup when menu is destroyed
 538:             def cleanup():
 539:                 self.email_options_menu = None
 540:             
 541:             self.email_options_menu.bind("<Destroy>", lambda e: cleanup())
 542: 

────────────────────────────────────────────────────────────────────────────────
FILE: ui_components.py
────────────────────────────────────────────────────────────────────────────────
Path: ui_components.py
Size: 28.7 KB
Lines: 745 total, 615 non-empty
Characters: 29,342
Type: Reusable UI components and dialogs
────────────────────────────────────────────────────────────────────────────────

   1: # ui_components.py
   2: """
   3: Shared UI components for SuiteView Taskbar Application
   4: Contains reusable dialogs, custom widgets, and styling functions
   5: """
   6: 
   7: import tkinter as tk
   8: from tkinter import ttk
   9: from config import Colors, Fonts, Dimensions
  10: from utils import UIUtils
  11: 
  12: class CustomDialog(tk.Toplevel):
  13:     """Base class for custom dialogs with consistent styling"""
  14:     
  15:     def __init__(self, parent, title, width=400, height=300, resizable=False, x=None, y=None):
  16:         super().__init__(parent)
  17:         self.parent = parent
  18:         self.result = None
  19:         
  20:         # Initialize drag variables
  21:         self.is_dragging = False
  22:         self.drag_start_x = 0
  23:         self.drag_start_y = 0
  24:         
  25:         # Initialize topmost maintenance
  26:         self.maintain_topmost_active = True
  27:         
  28:         # Window setup
  29:         self.configure(bg=Colors.DARK_GREEN)
  30:         self.resizable(resizable, resizable)
  31:         self.overrideredirect(True)  # Remove default title bar
  32:         
  33:         # Make dialog modal and always on top
  34:         self.transient(parent)
  35:         self.attributes('-topmost', True)
  36:         self.lift()
  37:         
  38:         if x is not None and y is not None:
  39:             # Use custom position
  40:             self.geometry(f"{width}x{height}+{x}+{y}")
  41:         else:
  42:             # Center on screen (existing behavior)
  43:             UIUtils.center_window(self, width, height)
  44:         
  45:         # Main content frame
  46:         self.content_frame = tk.Frame(self, bg=Colors.LIGHT_GREEN, relief=tk.RAISED, bd=2)
  47:         self.content_frame.pack(fill=tk.BOTH, expand=True, padx=3, pady=3)
  48:         
  49:         # Create custom title bar
  50:         self.create_title_bar(title)
  51:         
  52:         # Container for dialog content
  53:         self.dialog_content = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
  54:         self.dialog_content.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
  55:         
  56:         # Button frame at bottom
  57:         self.button_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN, height=50)
  58:         self.button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=10)
  59:         self.button_frame.pack_propagate(False)
  60:         
  61:         # Make modal and ensure it stays on top
  62:         self.grab_set()
  63:         self.focus_force()
  64:         
  65:         # Schedule periodic topmost updates to ensure dialog stays visible
  66:         self.after(100, self._maintain_topmost)
  67:         
  68:         # Pause parent's topmost maintenance if it exists
  69:         if hasattr(parent, 'pause_topmost_maintenance'):
  70:             parent.pause_topmost_maintenance()
  71:         
  72:         # Resume parent's topmost when this dialog is destroyed
  73:         self.protocol("WM_DELETE_WINDOW", self._on_closing)
  74:     
  75:     def create_title_bar(self, title):
  76:         """Create custom title bar with drag functionality"""
  77:         self.title_frame = tk.Frame(self.content_frame, bg=Colors.DARK_GREEN, height=25)
  78:         self.title_frame.pack(fill=tk.X)
  79:         self.title_frame.pack_propagate(False)
  80:         
  81:         # Drag handle (left side)
  82:         drag_handle = tk.Label(self.title_frame, text="⋮⋮⋮", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
  83:                              font=('Arial', 8), cursor='fleur')
  84:         drag_handle.pack(side=tk.LEFT, padx=3, pady=3)
  85:         
  86:         # Title label
  87:         title_label = tk.Label(self.title_frame, text=f"📋 {title}", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
  88:                               font=Fonts.DIALOG_TITLE, cursor='fleur')
  89:         title_label.pack(side=tk.LEFT, padx=5, pady=3)
  90:         
  91:         # Close button
  92:         close_btn = tk.Label(self.title_frame, text="×", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
  93:                            font=('Arial', 12, 'bold'), cursor='hand2')
  94:         close_btn.pack(side=tk.RIGHT, padx=5)
  95:         close_btn.bind("<Button-1>", lambda e: self.cancel())
  96:         
  97:         # Bind drag events to title bar elements
  98:         for widget in [self.title_frame, drag_handle, title_label]:
  99:             widget.bind("<Button-1>", self.start_drag)
 100:             widget.bind("<B1-Motion>", self.do_drag)
 101:             widget.bind("<ButtonRelease-1>", self.end_drag)
 102:             widget.bind("<Enter>", lambda e: self.configure(cursor='fleur'))
 103:             widget.bind("<Leave>", lambda e: self.configure(cursor=''))
 104:         
 105:         return self.title_frame
 106:     
 107:     def add_button(self, text, command, style='primary'):
 108:         """Add a button to the button frame"""
 109:         if style == 'primary':
 110:             bg_color = Colors.DARK_GREEN
 111:         elif style == 'secondary':
 112:             bg_color = Colors.MEDIUM_GREEN
 113:         else:
 114:             bg_color = Colors.INACTIVE_GRAY
 115:         
 116:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 117:         button_container.pack(expand=True)
 118:         
 119:         btn = tk.Button(button_container, text=text, bg=bg_color, fg=Colors.WHITE,
 120:                        command=command, width=Dimensions.DIALOG_BUTTON_WIDTH, 
 121:                        font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 122:         btn.pack(side=tk.LEFT, padx=5)
 123:         
 124:         return btn
 125:     
 126:     def cancel(self):
 127:         """Cancel the dialog"""
 128:         self.result = None
 129:         self.destroy()
 130:     
 131:     def ok(self):
 132:         """OK button handler - override in subclasses"""
 133:         self.result = True
 134:         self.destroy()
 135:     
 136:     def start_drag(self, event):
 137:         """Start dragging the dialog"""
 138:         self.is_dragging = True
 139:         self.drag_start_x = event.x_root
 140:         self.drag_start_y = event.y_root
 141:         
 142:         # Visual feedback
 143:         self.title_frame.configure(bg=Colors.HOVER_GREEN)
 144:         self.configure(cursor='fleur')
 145:     
 146:     def do_drag(self, event):
 147:         """Handle drag motion"""
 148:         if not self.is_dragging:
 149:             return
 150:         
 151:         # Calculate the distance moved
 152:         delta_x = event.x_root - self.drag_start_x
 153:         delta_y = event.y_root - self.drag_start_y
 154:         
 155:         # Get current position
 156:         current_x = self.winfo_x()
 157:         current_y = self.winfo_y()
 158:         
 159:         # Calculate new position
 160:         new_x = current_x + delta_x
 161:         new_y = current_y + delta_y
 162:         
 163:         # Keep dialog on screen (basic bounds checking)
 164:         screen_width = self.winfo_screenwidth()
 165:         screen_height = self.winfo_screenheight()
 166:         dialog_width = self.winfo_width()
 167:         dialog_height = self.winfo_height()
 168:         
 169:         # Ensure dialog stays on screen
 170:         new_x = max(0, min(new_x, screen_width - dialog_width))
 171:         new_y = max(0, min(new_y, screen_height - dialog_height))
 172:         
 173:         # Move the dialog
 174:         self.geometry(f"+{new_x}+{new_y}")
 175:         
 176:         # Update start position for next move
 177:         self.drag_start_x = event.x_root
 178:         self.drag_start_y = event.y_root
 179:     
 180:     def end_drag(self, event):
 181:         """End dragging operation"""
 182:         self.is_dragging = False
 183:         self.configure(cursor='')
 184:         
 185:         # Remove visual feedback
 186:         self.title_frame.configure(bg=Colors.DARK_GREEN)
 187:     
 188:     def pause_topmost_maintenance(self):
 189:         """Pause the topmost maintenance for this dialog"""
 190:         self.maintain_topmost_active = False
 191:     
 192:     def resume_topmost_maintenance(self):
 193:         """Resume the topmost maintenance for this dialog"""
 194:         self.maintain_topmost_active = True
 195:     
 196:     def _maintain_topmost(self):
 197:         """Periodically ensure dialog stays on top"""
 198:         try:
 199:             if self.winfo_exists() and self.maintain_topmost_active:
 200:                 # Only maintain topmost if no combobox is active to avoid stealing focus
 201:                 focused_widget = self.focus_get()
 202:                 if not (focused_widget and isinstance(focused_widget, ttk.Combobox)):
 203:                     # Check if any combobox in the dialog has focus or is showing dropdown
 204:                     combobox_active = self._has_active_combobox()
 205:                     if not combobox_active:
 206:                         self.lift()
 207:                         self.attributes('-topmost', True)
 208:                 self.after(500, self._maintain_topmost)  # Check every 500ms
 209:             elif self.winfo_exists():
 210:                 # Still schedule next check even if paused
 211:                 self.after(500, self._maintain_topmost)
 212:         except:
 213:             pass  # Dialog has been destroyed
 214:     
 215:     def _has_active_combobox(self):
 216:         """Check if any combobox in the dialog is currently active (dropdown showing)"""
 217:         try:
 218:             # Recursively check all widgets to find active comboboxes
 219:             return self._check_widget_for_active_combobox(self)
 220:         except:
 221:             return False
 222:     
 223:     def _check_widget_for_active_combobox(self, widget):
 224:         """Recursively check widget and its children for active comboboxes"""
 225:         try:
 226:             # Check if current widget is an active combobox
 227:             if isinstance(widget, ttk.Combobox):
 228:                 # Check if combobox has focus or its dropdown is showing
 229:                 if widget.focus_get() == widget:
 230:                     return True
 231:                 # Additional check: see if the combobox state indicates dropdown is open
 232:                 try:
 233:                     if 'pressed' in str(widget.state()) or 'active' in str(widget.state()):
 234:                         return True
 235:                 except:
 236:                     pass
 237:             
 238:             # Check all child widgets
 239:             for child in widget.winfo_children():
 240:                 if self._check_widget_for_active_combobox(child):
 241:                     return True
 242:             
 243:             return False
 244:         except:
 245:             return False
 246:     
 247:     def _on_closing(self):
 248:         """Handle dialog closing"""
 249:         # Resume parent's topmost maintenance
 250:         if hasattr(self.parent, 'resume_topmost_maintenance'):
 251:             self.parent.resume_topmost_maintenance()
 252:         self.destroy()
 253:     
 254:     def destroy(self):
 255:         """Override destroy to clean up properly"""
 256:         # Resume parent's topmost maintenance
 257:         if hasattr(self.parent, 'resume_topmost_maintenance'):
 258:             self.parent.resume_topmost_maintenance()
 259:         super().destroy()
 260: 
 261: class ConfirmationDialog(CustomDialog):
 262:     """Confirmation dialog with Yes/No buttons"""
 263:     
 264:     def __init__(self, parent, title, message, icon="⚠️"):
 265:         super().__init__(parent, title, width=350, height=200)
 266:         
 267:         # Icon and message
 268:         icon_label = tk.Label(self.dialog_content, text=icon, bg=Colors.LIGHT_GREEN,
 269:                              fg=Colors.BLACK, font=Fonts.WARNING_ICON)
 270:         icon_label.pack(pady=10)
 271:         
 272:         message_label = tk.Label(self.dialog_content, text=message, bg=Colors.LIGHT_GREEN,
 273:                                fg=Colors.BLACK, font=Fonts.DIALOG_LABEL, wraplength=300)
 274:         message_label.pack(pady=5)
 275:         
 276:         # Buttons
 277:         self.add_buttons()
 278:         
 279:         # Bind keys
 280:         self.bind('<Return>', lambda e: self.yes())
 281:         self.bind('<Escape>', lambda e: self.no())
 282:     
 283:     def add_buttons(self):
 284:         """Add Yes/No buttons"""
 285:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 286:         button_container.pack(expand=True)
 287:         
 288:         yes_btn = tk.Button(button_container, text="Yes", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 289:                            command=self.yes, width=Dimensions.DIALOG_BUTTON_WIDTH,
 290:                            font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 291:         yes_btn.pack(side=tk.LEFT, padx=10)
 292:         
 293:         no_btn = tk.Button(button_container, text="No", bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 294:                           command=self.no, width=Dimensions.DIALOG_BUTTON_WIDTH,
 295:                           font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 296:         no_btn.pack(side=tk.LEFT, padx=10)
 297:         
 298:         # Focus on No button (safer default)
 299:         no_btn.focus_set()
 300:     
 301:     def yes(self):
 302:         """Yes button clicked"""
 303:         self.result = True
 304:         self.destroy()
 305:     
 306:     def no(self):
 307:         """No button clicked"""
 308:         self.result = False
 309:         self.destroy()
 310:     
 311:     @classmethod
 312:     def ask(cls, parent, title, message, icon="⚠️"):
 313:         """Show confirmation dialog and return result"""
 314:         dialog = cls(parent, title, message, icon)
 315:         dialog.lift()
 316:         dialog.focus_force()
 317:         parent.wait_window(dialog)
 318:         return dialog.result
 319: 
 320: class WarningDialog(CustomDialog):
 321:     """Warning dialog with OK button"""
 322:     
 323:     def __init__(self, parent, title, message, icon="⚠️"):
 324:         super().__init__(parent, title, width=380, height=220)
 325:         
 326:         # Icon and message
 327:         icon_label = tk.Label(self.dialog_content, text=icon, bg=Colors.LIGHT_GREEN,
 328:                              fg=Colors.BLACK, font=('Arial', 24))
 329:         icon_label.pack(pady=10)
 330:         
 331:         message_label = tk.Label(self.dialog_content, text=message, bg=Colors.LIGHT_GREEN,
 332:                                fg=Colors.BLACK, font=Fonts.DIALOG_LABEL, wraplength=320)
 333:         message_label.pack(pady=5)
 334:         
 335:         # Buttons
 336:         self.add_buttons()
 337:         
 338:         # Bind keys
 339:         self.bind('<Return>', lambda e: self.ok())
 340:         self.bind('<Escape>', lambda e: self.ok())
 341:     
 342:     def add_buttons(self):
 343:         """Add OK button"""
 344:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 345:         button_container.pack(expand=True)
 346:         
 347:         ok_btn = tk.Button(button_container, text="OK", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 348:                           command=self.ok, width=Dimensions.DIALOG_BUTTON_WIDTH,
 349:                           font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 350:         ok_btn.pack(padx=10)
 351:         ok_btn.focus_set()
 352:     
 353:     @classmethod
 354:     def show(cls, parent, title, message, icon="⚠️"):
 355:         """Show warning dialog"""
 356:         dialog = cls(parent, title, message, icon)
 357:         dialog.lift()
 358:         dialog.focus_force()
 359:         dialog.attributes('-topmost', True)
 360:         parent.wait_window(dialog)
 361:         return dialog.result
 362: 
 363: class ErrorDialog(CustomDialog):
 364:     """Error dialog with OK button"""
 365:     
 366:     def __init__(self, parent, title, message, icon="❌"):
 367:         super().__init__(parent, title, width=400, height=240)
 368:         
 369:         # Icon and message
 370:         icon_label = tk.Label(self.dialog_content, text=icon, bg=Colors.LIGHT_GREEN,
 371:                              fg=Colors.BLACK, font=('Arial', 24))
 372:         icon_label.pack(pady=10)
 373:         
 374:         message_label = tk.Label(self.dialog_content, text=message, bg=Colors.LIGHT_GREEN,
 375:                                fg=Colors.BLACK, font=Fonts.DIALOG_LABEL, wraplength=340)
 376:         message_label.pack(pady=5)
 377:         
 378:         # Buttons
 379:         self.add_buttons()
 380:         
 381:         # Bind keys
 382:         self.bind('<Return>', lambda e: self.ok())
 383:         self.bind('<Escape>', lambda e: self.ok())
 384:     
 385:     def add_buttons(self):
 386:         """Add OK button"""
 387:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 388:         button_container.pack(expand=True)
 389:         
 390:         ok_btn = tk.Button(button_container, text="OK", bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 391:                           command=self.ok, width=Dimensions.DIALOG_BUTTON_WIDTH,
 392:                           font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 393:         ok_btn.pack(padx=10)
 394:         ok_btn.focus_set()
 395:     
 396:     @classmethod
 397:     def show(cls, parent, title, message, icon="❌"):
 398:         """Show error dialog"""
 399:         dialog = cls(parent, title, message, icon)
 400:         dialog.lift()
 401:         dialog.focus_force()
 402:         dialog.attributes('-topmost', True)
 403:         parent.wait_window(dialog)
 404:         return dialog.result
 405: 
 406: # Updated FormField class (add this to ui_components.py)
 407: 
 408: class FormField:
 409:     """Helper class for creating form fields with clipboard support"""
 410:     
 411:     def __init__(self, parent, label_text, field_type='entry', layout='side-by-side', **kwargs):
 412:         self.frame = tk.Frame(parent, bg=Colors.LIGHT_GREEN)
 413:         self.layout = layout
 414:         
 415:         if layout == 'stacked':
 416:             # Label on top, widget below
 417:             self.label = tk.Label(self.frame, text=label_text, bg=Colors.LIGHT_GREEN, 
 418:                                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL)
 419:             self.label.pack(anchor='w', pady=(0, 2))
 420:             
 421:             if field_type == 'entry':
 422:                 self.widget = tk.Entry(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 423:                 self._bind_clipboard_operations()
 424:             elif field_type == 'combobox':
 425:                 self.widget = ttk.Combobox(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 426:                 self._bind_combobox_clipboard_operations()
 427:             elif field_type == 'text':
 428:                 self.widget = tk.Text(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 429:                 self._bind_text_clipboard_operations()
 430:             
 431:             self.widget.pack(fill=tk.X, expand=True)
 432:             
 433:         else:
 434:             # Original side-by-side layout
 435:             self.label = tk.Label(self.frame, text=label_text, bg=Colors.LIGHT_GREEN, 
 436:                                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL)
 437:             self.label.grid(row=0, column=0, padx=5, pady=5, sticky='w')
 438:         
 439:             if field_type == 'entry':
 440:                 self.widget = tk.Entry(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 441:                 self._bind_clipboard_operations()
 442:             elif field_type == 'combobox':
 443:                 self.widget = ttk.Combobox(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 444:                 self._bind_combobox_clipboard_operations()
 445:             elif field_type == 'text':
 446:                 self.widget = tk.Text(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 447:                 self._bind_text_clipboard_operations()
 448:             
 449:             self.widget.grid(row=0, column=1, padx=5, pady=5, sticky='ew')
 450:             self.frame.grid_columnconfigure(1, weight=1)
 451:     
 452:     def _bind_clipboard_operations(self):
 453:         """Bind standard clipboard operations to Entry widget"""
 454:         # Standard Windows/cross-platform shortcuts
 455:         self.widget.bind('<Control-c>', self._copy)
 456:         self.widget.bind('<Control-x>', self._cut)
 457:         self.widget.bind('<Control-v>', self._paste)
 458:         self.widget.bind('<Control-a>', self._select_all)
 459:         
 460:         # Right-click context menu
 461:         self.widget.bind('<Button-3>', self._show_context_menu)
 462:     
 463:     def _bind_combobox_clipboard_operations(self):
 464:         """Bind clipboard operations to Combobox widget"""
 465:         # Comboboxes need special handling since they have different methods
 466:         self.widget.bind('<Control-c>', self._copy_combobox)
 467:         self.widget.bind('<Control-x>', self._cut_combobox)
 468:         self.widget.bind('<Control-v>', self._paste_combobox)
 469:         self.widget.bind('<Control-a>', self._select_all_combobox)
 470:         
 471:         # Right-click context menu
 472:         self.widget.bind('<Button-3>', self._show_combobox_context_menu)
 473:     
 474:     def _bind_text_clipboard_operations(self):
 475:         """Enhance Text widget clipboard operations"""
 476:         # Text widgets already have built-in clipboard support, but we can add context menu
 477:         self.widget.bind('<Button-3>', self._show_text_context_menu)
 478:     
 479:     def _copy(self, event=None):
 480:         """Copy selected text to clipboard"""
 481:         try:
 482:             if self.widget.selection_present():
 483:                 self.widget.clipboard_clear()
 484:                 self.widget.clipboard_append(self.widget.selection_get())
 485:         except tk.TclError:
 486:             pass  # No selection
 487:         return 'break'
 488:     
 489:     def _cut(self, event=None):
 490:         """Cut selected text to clipboard"""
 491:         try:
 492:             if self.widget.selection_present():
 493:                 self.widget.clipboard_clear()
 494:                 self.widget.clipboard_append(self.widget.selection_get())
 495:                 self.widget.delete(tk.SEL_FIRST, tk.SEL_LAST)
 496:         except tk.TclError:
 497:             pass  # No selection
 498:         return 'break'
 499:     
 500:     def _paste(self, event=None):
 501:         """Paste from clipboard"""
 502:         try:
 503:             clipboard_text = self.widget.clipboard_get()
 504:             if self.widget.selection_present():
 505:                 self.widget.delete(tk.SEL_FIRST, tk.SEL_LAST)
 506:             self.widget.insert(tk.INSERT, clipboard_text)
 507:         except tk.TclError:
 508:             pass  # No clipboard content
 509:         return 'break'
 510:     
 511:     def _select_all(self, event=None):
 512:         """Select all text"""
 513:         self.widget.select_range(0, tk.END)
 514:         self.widget.icursor(tk.END)
 515:         return 'break'
 516:     
 517:     def _copy_combobox(self, event=None):
 518:         """Copy from combobox"""
 519:         try:
 520:             if self.widget.selection_present():
 521:                 self.widget.clipboard_clear()
 522:                 self.widget.clipboard_append(self.widget.selection_get())
 523:         except (tk.TclError, AttributeError):
 524:             # Fallback: copy entire value if no selection
 525:             try:
 526:                 self.widget.clipboard_clear()
 527:                 self.widget.clipboard_append(self.widget.get())
 528:             except:
 529:                 pass
 530:         return 'break'
 531:     
 532:     def _cut_combobox(self, event=None):
 533:         """Cut from combobox"""
 534:         try:
 535:             if self.widget.selection_present():
 536:                 self.widget.clipboard_clear()
 537:                 self.widget.clipboard_append(self.widget.selection_get())
 538:                 # For combobox, we can delete selected text
 539:                 start = self.widget.index(tk.SEL_FIRST)
 540:                 end = self.widget.index(tk.SEL_LAST)
 541:                 current_value = self.widget.get()
 542:                 new_value = current_value[:start] + current_value[end:]
 543:                 self.widget.set(new_value)
 544:         except (tk.TclError, AttributeError):
 545:             pass
 546:         return 'break'
 547:     
 548:     def _paste_combobox(self, event=None):
 549:         """Paste to combobox"""
 550:         try:
 551:             clipboard_text = self.widget.clipboard_get()
 552:             if self.widget.selection_present():
 553:                 # Replace selection
 554:                 start = self.widget.index(tk.SEL_FIRST)
 555:                 end = self.widget.index(tk.SEL_LAST)
 556:                 current_value = self.widget.get()
 557:                 new_value = current_value[:start] + clipboard_text + current_value[end:]
 558:                 self.widget.set(new_value)
 559:             else:
 560:                 # Insert at cursor position
 561:                 cursor_pos = self.widget.index(tk.INSERT)
 562:                 current_value = self.widget.get()
 563:                 new_value = current_value[:cursor_pos] + clipboard_text + current_value[cursor_pos:]
 564:                 self.widget.set(new_value)
 565:         except tk.TclError:
 566:             pass
 567:         return 'break'
 568:     
 569:     def _select_all_combobox(self, event=None):
 570:         """Select all text in combobox"""
 571:         try:
 572:             self.widget.selection_range(0, tk.END)
 573:             self.widget.icursor(tk.END)
 574:         except (tk.TclError, AttributeError):
 575:             pass
 576:         return 'break'
 577:     
 578:     def _show_context_menu(self, event):
 579:         """Show right-click context menu for Entry"""
 580:         context_menu = tk.Menu(self.widget, tearoff=0)
 581:         
 582:         # Check if there's a selection
 583:         has_selection = False
 584:         try:
 585:             has_selection = self.widget.selection_present()
 586:         except:
 587:             pass
 588:         
 589:         # Check if clipboard has content
 590:         has_clipboard = False
 591:         try:
 592:             self.widget.clipboard_get()
 593:             has_clipboard = True
 594:         except:
 595:             pass
 596:         
 597:         context_menu.add_command(label="Cut", command=self._cut, 
 598:                                state=tk.NORMAL if has_selection else tk.DISABLED)
 599:         context_menu.add_command(label="Copy", command=self._copy,
 600:                                state=tk.NORMAL if has_selection else tk.DISABLED)
 601:         context_menu.add_command(label="Paste", command=self._paste,
 602:                                state=tk.NORMAL if has_clipboard else tk.DISABLED)
 603:         context_menu.add_separator()
 604:         context_menu.add_command(label="Select All", command=self._select_all)
 605:         
 606:         try:
 607:             context_menu.tk_popup(event.x_root, event.y_root)
 608:         finally:
 609:             context_menu.grab_release()
 610:     
 611:     def _show_combobox_context_menu(self, event):
 612:         """Show right-click context menu for Combobox"""
 613:         context_menu = tk.Menu(self.widget, tearoff=0)
 614:         
 615:         # Check if there's a selection
 616:         has_selection = False
 617:         try:
 618:             has_selection = self.widget.selection_present()
 619:         except:
 620:             pass
 621:         
 622:         # Check if clipboard has content
 623:         has_clipboard = False
 624:         try:
 625:             self.widget.clipboard_get()
 626:             has_clipboard = True
 627:         except:
 628:             pass
 629:         
 630:         context_menu.add_command(label="Cut", command=self._cut_combobox,
 631:                                state=tk.NORMAL if has_selection else tk.DISABLED)
 632:         context_menu.add_command(label="Copy", command=self._copy_combobox,
 633:                                state=tk.NORMAL if (has_selection or self.widget.get()) else tk.DISABLED)
 634:         context_menu.add_command(label="Paste", command=self._paste_combobox,
 635:                                state=tk.NORMAL if has_clipboard else tk.DISABLED)
 636:         context_menu.add_separator()
 637:         context_menu.add_command(label="Select All", command=self._select_all_combobox,
 638:                                state=tk.NORMAL if self.widget.get() else tk.DISABLED)
 639:         
 640:         try:
 641:             context_menu.tk_popup(event.x_root, event.y_root)
 642:         finally:
 643:             context_menu.grab_release()
 644:     
 645:     def _show_text_context_menu(self, event):
 646:         """Show right-click context menu for Text widget"""
 647:         # Text widgets have built-in context menus in some systems,
 648:         # but we can provide a custom one for consistency
 649:         context_menu = tk.Menu(self.widget, tearoff=0)
 650:         
 651:         # Check if there's a selection
 652:         has_selection = False
 653:         try:
 654:             has_selection = bool(self.widget.tag_ranges(tk.SEL))
 655:         except:
 656:             pass
 657:         
 658:         # Check if clipboard has content
 659:         has_clipboard = False
 660:         try:
 661:             self.widget.clipboard_get()
 662:             has_clipboard = True
 663:         except:
 664:             pass
 665:         
 666:         context_menu.add_command(label="Cut", command=lambda: self.widget.event_generate("<<Cut>>"),
 667:                                state=tk.NORMAL if has_selection else tk.DISABLED)
 668:         context_menu.add_command(label="Copy", command=lambda: self.widget.event_generate("<<Copy>>"),
 669:                                state=tk.NORMAL if has_selection else tk.DISABLED)
 670:         context_menu.add_command(label="Paste", command=lambda: self.widget.event_generate("<<Paste>>"),
 671:                                state=tk.NORMAL if has_clipboard else tk.DISABLED)
 672:         context_menu.add_separator()
 673:         context_menu.add_command(label="Select All", command=lambda: self.widget.tag_add(tk.SEL, "1.0", tk.END))
 674:         
 675:         try:
 676:             context_menu.tk_popup(event.x_root, event.y_root)
 677:         finally:
 678:             context_menu.grab_release()
 679:     
 680:     def pack(self, **kwargs):
 681:         self.frame.pack(**kwargs)
 682:         return self
 683:     
 684:     def grid(self, **kwargs):
 685:         self.frame.grid(**kwargs)
 686:         return self
 687:     
 688:     def get(self):
 689:         if hasattr(self.widget, 'get'):
 690:             return self.widget.get()
 691:         return ""
 692:     
 693:     def set(self, value):
 694:         if hasattr(self.widget, 'delete') and hasattr(self.widget, 'insert'):
 695:             self.widget.delete(0, tk.END)
 696:             self.widget.insert(0, value)
 697:         elif hasattr(self.widget, 'set'):
 698:             self.widget.set(value)
 699: 
 700: class StyledButton(tk.Button):
 701:     """Custom styled button"""
 702:     
 703:     def __init__(self, parent, text, style='primary', **kwargs):
 704:         # Set default styling based on style type
 705:         if style == 'primary':
 706:             bg_color = Colors.DARK_GREEN
 707:             fg_color = Colors.WHITE
 708:         elif style == 'secondary':
 709:             bg_color = Colors.MEDIUM_GREEN
 710:             fg_color = Colors.BLACK
 711:         elif style == 'success':
 712:             bg_color = Colors.LIGHT_GREEN
 713:             fg_color = Colors.BLACK
 714:         else:  # 'danger' or other
 715:             bg_color = Colors.INACTIVE_GRAY
 716:             fg_color = Colors.WHITE
 717:         
 718:         defaults = {
 719:             'bg': bg_color,
 720:             'fg': fg_color,
 721:             'font': Fonts.DIALOG_BUTTON,
 722:             'relief': tk.RAISED,
 723:             'bd': 1,
 724:             'cursor': 'hand2',
 725:             'activebackground': Colors.HOVER_GREEN,
 726:             'activeforeground': Colors.WHITE
 727:         }
 728:         
 729:         # Override defaults with provided kwargs
 730:         defaults.update(kwargs)
 731:         
 732:         super().__init__(parent, text=text, **defaults)
 733: 
 734: class CategoryHeader(tk.Frame):
 735:     """Styled category header for lists"""
 736:     
 737:     def __init__(self, parent, title, **kwargs):
 738:         super().__init__(parent, bg=Colors.MEDIUM_GREEN, relief=tk.RAISED, bd=1, **kwargs)
 739:         
 740:         self.title_label = tk.Label(self, text=title, bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 741:                                    font=Fonts.MENU_HEADER, height=1)
 742:         self.title_label.pack(pady=1)
 743:     
 744:     def set_title(self, title):
 745:         self.title_label.config(text=title)

────────────────────────────────────────────────────────────────────────────────
FILE: utils.py
────────────────────────────────────────────────────────────────────────────────
Path: utils.py
Size: 7.0 KB
Lines: 211 total, 182 non-empty
Characters: 6,974
Type: Utility functions and helper classes
────────────────────────────────────────────────────────────────────────────────

   1: # utils.py
   2: """
   3: Utility functions for SuiteView Taskbar Application
   4: Contains Windows API calls, file operations, and common helper functions
   5: """
   6: 
   7: import ctypes
   8: from ctypes import wintypes
   9: import os
  10: import webbrowser
  11: from pathlib import Path
  12: from config import WindowsAPI
  13: 
  14: class WindowsUtils:
  15:     """Windows-specific utility functions"""
  16:     
  17:     @staticmethod
  18:     def get_windows_taskbar_height():
  19:         """Get the height of Windows taskbar"""
  20:         try:
  21:             work_area = wintypes.RECT()
  22:             ctypes.windll.user32.SystemParametersInfoW(
  23:                 WindowsAPI.SPI_GETWORKAREA, 0, ctypes.byref(work_area), 0
  24:             )
  25:             screen_height = ctypes.windll.user32.GetSystemMetrics(1)  # SM_CYSCREEN
  26:             taskbar_height = screen_height - work_area.bottom
  27:             return taskbar_height if taskbar_height > 0 else 40
  28:         except:
  29:             return 40
  30:     
  31:     @staticmethod
  32:     def get_screen_dimensions():
  33:         """Get screen width and height"""
  34:         try:
  35:             width = ctypes.windll.user32.GetSystemMetrics(0)   # SM_CXSCREEN
  36:             height = ctypes.windll.user32.GetSystemMetrics(1)  # SM_CYSCREEN
  37:             return width, height
  38:         except:
  39:             # Fallback values
  40:             return 1920, 1080
  41:     
  42:     @staticmethod
  43:     def set_window_topmost(window_id):
  44:         """Force window to stay on top using Windows API"""
  45:         try:
  46:             hwnd = ctypes.windll.user32.GetParent(window_id)
  47:             ctypes.windll.user32.SetWindowPos(
  48:                 hwnd, WindowsAPI.HWND_TOPMOST, 0, 0, 0, 0, 
  49:                 WindowsAPI.SWP_NOMOVE | WindowsAPI.SWP_NOSIZE
  50:             )
  51:         except:
  52:             pass
  53:     
  54:     @staticmethod
  55:     def get_work_area():
  56:         """Get current desktop work area"""
  57:         work_area = wintypes.RECT()
  58:         try:
  59:             ctypes.windll.user32.SystemParametersInfoW(
  60:                 WindowsAPI.SPI_GETWORKAREA, 0, ctypes.byref(work_area), 0
  61:             )
  62:             return work_area
  63:         except:
  64:             return None
  65:     
  66:     @staticmethod
  67:     def set_work_area(rect):
  68:         """Set desktop work area"""
  69:         try:
  70:             ctypes.windll.user32.SystemParametersInfoW(
  71:                 WindowsAPI.SPI_SETWORKAREA, 0, ctypes.byref(rect), 0
  72:             )
  73:             return True
  74:         except:
  75:             return False
  76:     
  77:     @staticmethod
  78:     def restore_work_area(original_rect):
  79:         """Restore original work area with proper flags"""
  80:         try:
  81:             ctypes.windll.user32.SystemParametersInfoW(
  82:                 WindowsAPI.SPI_SETWORKAREA, 0, ctypes.byref(original_rect), 
  83:                 WindowsAPI.SPIF_SENDCHANGE
  84:             )
  85:             return True
  86:         except:
  87:             return False
  88: 
  89: class FileUtils:
  90:     """File and path utility functions"""
  91:     
  92:     @staticmethod
  93:     def normalize_path(path):
  94:         """
  95:         Convert any path to Windows format with backslashes
  96:         Handles forward slashes, mixed slashes, and Path objects
  97:         """
  98:         if not path:
  99:             return ""
 100:         
 101:         # Convert Path object to string first
 102:         if isinstance(path, Path):
 103:             path = str(path)
 104:         
 105:         # Convert string paths
 106:         path_str = str(path).strip()
 107:         
 108:         # Skip URLs
 109:         if path_str.startswith(('http://', 'https://', 'www.')):
 110:             return path_str
 111:         
 112:         # Convert forward slashes to backslashes and normalize
 113:         normalized = os.path.normpath(path_str.replace('/', '\\'))
 114:         
 115:         return normalized
 116:     
 117:     @staticmethod
 118:     def open_path(path, parent=None):
 119:         """Open a file, folder, or URL"""
 120:         try:
 121:             # Normalize the path first
 122:             normalized_path = FileUtils.normalize_path(path)
 123:             
 124:             if normalized_path.startswith(('http://', 'https://', 'www.')):
 125:                 webbrowser.open(normalized_path)
 126:                 return True
 127:             elif os.path.exists(normalized_path):
 128:                 os.startfile(normalized_path)
 129:                 return True
 130:             else:
 131:                 FileUtils._show_error(parent, "Error", f"Path not found: {normalized_path}")
 132:                 return False
 133:         except Exception as e:
 134:             FileUtils._show_error(parent, "Error", f"Could not open: {str(e)}")
 135:             return False
 136:     
 137:     @staticmethod
 138:     def _show_error(parent, title, message):
 139:         """Show error dialog - uses custom dialog if parent provided, fallback to messagebox"""
 140:         if parent:
 141:             try:
 142:                 # Import here to avoid circular imports
 143:                 from ui_components import ErrorDialog
 144:                 ErrorDialog.show(parent, title, message)
 145:             except ImportError:
 146:                 # Fallback to standard messagebox if ui_components not available
 147:                 from tkinter import messagebox
 148:                 messagebox.showerror(title, message)
 149:         else:
 150:             # No parent provided, use console output
 151:             print(f"{title}: {message}")
 152:     
 153:     @staticmethod
 154:     def validate_path(path):
 155:         """Validate if a path exists or is a valid URL"""
 156:         if not path or not path.strip():
 157:             return False
 158:         
 159:         path = path.strip()
 160:         
 161:         # Check if it's a URL
 162:         if path.startswith(('http://', 'https://', 'www.')):
 163:             return True
 164:         
 165:         # Check if file/folder exists
 166:         return os.path.exists(path)
 167: 
 168: class UIUtils:
 169:     """UI-related utility functions"""
 170:     
 171:     @staticmethod
 172:     def center_window(window, width, height):
 173:         """Center a window on screen"""
 174:         screen_width = window.winfo_screenwidth()
 175:         screen_height = window.winfo_screenheight()
 176:         x = (screen_width - width) // 2
 177:         y = (screen_height - height) // 2
 178:         window.geometry(f"{width}x{height}+{x}+{y}")
 179:     
 180:     @staticmethod
 181:     def apply_hover_effect(widget, normal_bg, hover_bg, normal_fg='black', hover_fg='white'):
 182:         """Apply hover effect to a widget"""
 183:         def on_enter(e):
 184:             widget.configure(bg=hover_bg, fg=hover_fg)
 185:             # Apply to children if they exist
 186:             for child in widget.winfo_children():
 187:                 try:
 188:                     child.configure(bg=hover_bg, fg=hover_fg)
 189:                 except:
 190:                     pass
 191:         
 192:         def on_leave(e):
 193:             widget.configure(bg=normal_bg, fg=normal_fg)
 194:             # Apply to children if they exist
 195:             for child in widget.winfo_children():
 196:                 try:
 197:                     child.configure(bg=normal_bg, fg=normal_fg)
 198:                 except:
 199:                     pass
 200:         
 201:         widget.bind("<Enter>", on_enter)
 202:         widget.bind("<Leave>", on_leave)
 203:         
 204:         return on_enter, on_leave
 205:     
 206:     @staticmethod
 207:     def create_separator(parent, bg_color, width=2):
 208:         """Create a vertical separator"""
 209:         import tkinter as tk
 210:         separator = tk.Frame(parent, bg=bg_color, width=width)
 211:         return separator

────────────────────────────────────────────────────────────────────────────────
FILE: window_manager.py
────────────────────────────────────────────────────────────────────────────────
Path: window_manager.py
Size: 13.6 KB
Lines: 336 total, 276 non-empty
Characters: 13,540
Type: Window management and visibility controls
────────────────────────────────────────────────────────────────────────────────

   1: # window_manager.py (fixed)
   2: """
   3: Windows detection and management functionality for SuiteView Taskbar
   4: Handles window enumeration, filtering, hiding/showing, and pinning
   5: Fixed to properly restore minimized windows
   6: """
   7: 
   8: import win32gui
   9: import win32api
  10: import win32con
  11: import win32process
  12: import psutil
  13: import re
  14: from config import AppColors
  15: 
  16: class ManagedWindow:
  17:     """Represents a managed window with its state and color coding"""
  18:     
  19:     def __init__(self, hwnd: int, title: str, process_name: str):
  20:         self.hwnd = hwnd
  21:         self.title = title
  22:         self.process_name = process_name
  23:         self.app_name = self._extract_app_name()
  24:         self.display_name = self._create_display_name()
  25:         self.is_hidden = False
  26:         self.is_pinned = False
  27:         self.original_ex_style = win32gui.GetWindowLong(hwnd, win32con.GWL_EXSTYLE)
  28:         
  29:         # Add color support
  30:         from config import AppColors
  31:         self.colors = self._get_window_colors()
  32:     
  33:     def _extract_app_name(self) -> str:
  34:         """Extract application name from process name"""
  35:         # Remove .exe extension
  36:         app = self.process_name.replace('.exe', '')
  37:         
  38:         # Capitalize common apps
  39:         common_apps = {
  40:             'chrome': 'Chrome',
  41:             'firefox': 'Firefox',
  42:             'winword': 'Word',
  43:             'excel': 'Excel',
  44:             'powerpnt': 'PowerPoint',
  45:             'outlook': 'Outlook',
  46:             'notepad': 'Notepad',
  47:             'notepad++': 'Notepad++',
  48:             'code': 'VS Code',
  49:             'devenv': 'Visual Studio',
  50:             'acrobat': 'Acrobat',
  51:             'acrord32': 'Acrobat Reader',
  52:             'explorer': 'File Explorer',
  53:             'cursor': 'Cursor'
  54:         }
  55:         
  56:         return common_apps.get(app.lower(), app.title())
  57:     
  58:     def _create_display_name(self) -> str:
  59:         """Create display name WITHOUT app prefix and with cleaned tab counts"""
  60:         # Remove app name from title if it's at the beginning
  61:         if self.title.startswith(self.app_name + " - "):
  62:             display_name = self.title[len(self.app_name) + 3:]  # Remove "AppName - "
  63:         elif self.title.startswith(self.app_name):
  64:             # Some apps don't use " - " separator
  65:             display_name = self.title[len(self.app_name):].lstrip(" -")
  66:         else:
  67:             display_name = self.title
  68:         
  69:         # For some apps, the title format might be different
  70:         # Remove common patterns
  71:         patterns_to_remove = [
  72:             f" - {self.app_name}",  # "Document - Word"
  73:             f" – {self.app_name}",  # Em dash variant
  74:             f" — {self.app_name}",  # Em dash variant
  75:         ]
  76:         
  77:         for pattern in patterns_to_remove:
  78:             if display_name.endswith(pattern):
  79:                 display_name = display_name[:-len(pattern)]
  80:                 break
  81:         
  82:         # Clean up browser tab counts
  83:         # Replace "and X more tabs" with "(+X)"
  84:         import re
  85:         
  86:         # Pattern to match "and X more tab" or "and X more tabs"
  87:         tab_pattern = r' and (\d+) more tabs?'
  88:         match = re.search(tab_pattern, display_name)
  89:         if match:
  90:             tab_count = match.group(1)
  91:             display_name = re.sub(tab_pattern, f' (+{tab_count})', display_name)
  92:         
  93:         # Also handle other browser patterns like "- X tabs" or "(X tabs)"
  94:         # Chrome sometimes uses different formats
  95:         other_patterns = [
  96:             (r' - (\d+) tabs?$', r' (+\1)'),  # " - 3 tabs" -> " (+3)"
  97:             (r' \((\d+) tabs?\)$', r' (+\1)'),  # " (3 tabs)" -> " (+3)"
  98:         ]
  99:         
 100:         for pattern, replacement in other_patterns:
 101:             display_name = re.sub(pattern, replacement, display_name)
 102:         
 103:         return display_name if display_name else self.title
 104:     
 105:     def _get_window_colors(self):
 106:         """Get appropriate colors for this window"""
 107:         from config import AppColors
 108:         
 109:         # First check if it's a file type that should override the app colors
 110:         file_colors = AppColors.get_colors_for_file_type(self.title)
 111:         if file_colors:
 112:             return file_colors
 113:         
 114:         # Otherwise use app colors
 115:         return AppColors.get_app_colors(self.process_name)
 116:     
 117:     def hide(self) -> bool:
 118:         """Hide the window (remove from Alt+Tab and taskbar)"""
 119:         try:
 120:             # Get current extended style
 121:             ex_style = win32gui.GetWindowLong(self.hwnd, win32con.GWL_EXSTYLE)
 122:             
 123:             # Add WS_EX_TOOLWINDOW to hide from Alt+Tab and taskbar
 124:             new_ex_style = ex_style | win32con.WS_EX_TOOLWINDOW
 125:             
 126:             # Remove WS_EX_APPWINDOW to ensure it's hidden from taskbar
 127:             new_ex_style = new_ex_style & ~win32con.WS_EX_APPWINDOW
 128:             
 129:             # Apply new style
 130:             win32gui.SetWindowLong(self.hwnd, win32con.GWL_EXSTYLE, new_ex_style)
 131:             
 132:             # Hide the window
 133:             win32gui.ShowWindow(self.hwnd, win32con.SW_HIDE)
 134:             
 135:             self.is_hidden = True
 136:             return True
 137:         except Exception as e:
 138:             print(f"Error hiding window {self.display_name}: {e}")
 139:             return False
 140:     
 141:     def show(self) -> bool:
 142:         """Show the window (restore to Alt+Tab and taskbar)"""
 143:         try:
 144:             # Restore original extended style
 145:             win32gui.SetWindowLong(self.hwnd, win32con.GWL_EXSTYLE, self.original_ex_style)
 146:             
 147:             # Show the window
 148:             win32gui.ShowWindow(self.hwnd, win32con.SW_SHOW)
 149:             
 150:             self.is_hidden = False
 151:             return True
 152:         except Exception as e:
 153:             print(f"Error showing window {self.display_name}: {e}")
 154:             return False
 155:     
 156:     def bring_to_front(self) -> bool:
 157:         """Bring window to front and give it focus, restoring from minimized if needed"""
 158:         try:
 159:             if self.is_hidden:
 160:                 self.show()
 161:             
 162:             # Check if window is minimized (iconic)
 163:             if win32gui.IsIconic(self.hwnd):
 164:                 print(f"Window {self.display_name} is minimized, restoring...")
 165:                 # Restore the window from minimized state
 166:                 win32gui.ShowWindow(self.hwnd, win32con.SW_RESTORE)
 167:             elif not win32gui.IsWindowVisible(self.hwnd):
 168:                 # Window is hidden but not minimized
 169:                 win32gui.ShowWindow(self.hwnd, win32con.SW_SHOW)
 170:             
 171:             # Bring window to foreground
 172:             # Sometimes SetForegroundWindow fails, so we try a few methods
 173:             try:
 174:                 win32gui.SetForegroundWindow(self.hwnd)
 175:             except:
 176:                 # Alternative method: simulate alt key to allow focus change
 177:                 win32api.keybd_event(win32con.VK_MENU, 0, 0, 0)
 178:                 win32gui.SetForegroundWindow(self.hwnd)
 179:                 win32api.keybd_event(win32con.VK_MENU, 0, win32con.KEYEVENTF_KEYUP, 0)
 180:             
 181:             # Ensure window is active
 182:             win32gui.SetActiveWindow(self.hwnd)
 183:             
 184:             return True
 185:         except Exception as e:
 186:             print(f"Error bringing window to front {self.display_name}: {e}")
 187:             return False
 188:     
 189:     def is_valid(self) -> bool:
 190:         """Check if window still exists"""
 191:         return win32gui.IsWindow(self.hwnd)
 192: 
 193: class WindowManager:
 194:     """Manages window detection, filtering, and state"""
 195:     
 196:     def __init__(self):
 197:         self.managed_windows: dict[int, ManagedWindow] = {}
 198:         self.excluded_processes = {
 199:             'searchui.exe', 'shellexperiencehost.exe',
 200:             'applicationframehost.exe', 'systemsettings.exe', 'textinputhost.exe',
 201:             'lockapp.exe', 'searchapp.exe', 'startmenuexperiencehost.exe',
 202:             'runtimebroker.exe', 'svchost.exe', 'system', 'registry',
 203:             'smss.exe', 'csrss.exe', 'wininit.exe', 'services.exe',
 204:             'lsass.exe', 'winlogon.exe', 'dwm.exe', 'taskhostw.exe',
 205:             'searchindexer.exe', 'backgroundtaskhost.exe'
 206:         }
 207:     
 208:     def get_relevant_windows(self) -> list[ManagedWindow]:
 209:         """Get all relevant open windows on current desktop"""
 210:         windows = []
 211:         
 212:         def enum_callback(hwnd, _):
 213:             if self._is_relevant_window(hwnd):
 214:                 try:
 215:                     title = win32gui.GetWindowText(hwnd)
 216:                     if title:  # Skip windows with no title
 217:                         _, pid = win32process.GetWindowThreadProcessId(hwnd)
 218:                         process = psutil.Process(pid)
 219:                         process_name = process.name()
 220:                         
 221:                         # Check if we already manage this window
 222:                         if hwnd in self.managed_windows:
 223:                             window = self.managed_windows[hwnd]
 224:                             # Update title in case it changed
 225:                             window.title = title
 226:                             window.display_name = window._create_display_name()
 227:                         else:
 228:                             window = ManagedWindow(hwnd, title, process_name)
 229:                             self.managed_windows[hwnd] = window
 230:                         
 231:                         windows.append(window)
 232:                 except Exception as e:
 233:                     print(f"Error processing window {hwnd}: {e}")
 234:             return True
 235:         
 236:         win32gui.EnumWindows(enum_callback, None)
 237:         
 238:         # Clean up managed windows that no longer exist
 239:         self._cleanup_invalid_windows()
 240:         
 241:         return sorted(windows, key=lambda w: w.display_name.lower())
 242:     
 243:     def _is_relevant_window(self, hwnd: int) -> bool:
 244:         """Check if window is relevant (user-facing, not system)"""
 245:         try:
 246:             # Window must be visible or minimized (but not completely hidden)
 247:             if not win32gui.IsWindowVisible(hwnd) and not win32gui.IsIconic(hwnd):
 248:                 return False
 249:             
 250:             # Get window info
 251:             _, pid = win32process.GetWindowThreadProcessId(hwnd)
 252:             process = psutil.Process(pid)
 253:             process_name = process.name().lower()
 254:             
 255:             # Special handling for explorer.exe - we want File Explorer windows but not the desktop/taskbar
 256:             if process_name == 'explorer.exe':
 257:                 # Get window class name to distinguish File Explorer from desktop/taskbar
 258:                 class_name = win32gui.GetClassName(hwnd)
 259:                 # File Explorer windows have these class names
 260:                 if class_name not in ['CabinetWClass', 'ExploreWClass']:
 261:                     return False
 262:             elif process_name in self.excluded_processes:
 263:                 # Exclude other system processes
 264:                 return False
 265:             
 266:             # Get window style
 267:             style = win32gui.GetWindowLong(hwnd, win32con.GWL_STYLE)
 268:             ex_style = win32gui.GetWindowLong(hwnd, win32con.GWL_EXSTYLE)
 269:             
 270:             # Must be a normal window (not a tool window, unless we made it one)
 271:             if hwnd not in self.managed_windows:
 272:                 if ex_style & win32con.WS_EX_TOOLWINDOW:
 273:                     return False
 274:             
 275:             # Should have a title bar or be a notable window
 276:             if not (style & win32con.WS_CAPTION):
 277:                 # Some apps like Chrome have windows without WS_CAPTION
 278:                 # Check if it's a main window by other criteria
 279:                 if not (ex_style & win32con.WS_EX_APPWINDOW):
 280:                     return False
 281:             
 282:             # Check if it's a main window (not a dialog or popup)
 283:             owner = win32gui.GetWindow(hwnd, win32con.GW_OWNER)
 284:             if owner:
 285:                 return False
 286:             
 287:             return True
 288:             
 289:         except Exception:
 290:             return False
 291:     
 292:     def _cleanup_invalid_windows(self):
 293:         """Remove windows that no longer exist from managed windows"""
 294:         invalid_hwnds = []
 295:         for hwnd, window in self.managed_windows.items():
 296:             if not window.is_valid():
 297:                 invalid_hwnds.append(hwnd)
 298:         
 299:         for hwnd in invalid_hwnds:
 300:             del self.managed_windows[hwnd]
 301:     
 302:     def toggle_window_visibility(self, window: ManagedWindow) -> bool:
 303:         """Toggle window visibility"""
 304:         if window.is_hidden:
 305:             return window.show()
 306:         else:
 307:             return window.hide()
 308:     
 309:     def pin_window(self, window: ManagedWindow):
 310:         """Mark window as pinned"""
 311:         window.is_pinned = True
 312:     
 313:     def unpin_window(self, window: ManagedWindow):
 314:         """Unpin window and ensure it's visible"""
 315:         window.is_pinned = False
 316:         if window.is_hidden:
 317:             window.show()
 318:     
 319:     def unhide_all_windows(self):
 320:         """Unhide all hidden windows (for app cleanup)"""
 321:         for window in self.managed_windows.values():
 322:             if window.is_hidden:
 323:                 window.show()
 324:     
 325:     def get_pinned_windows(self) -> list[ManagedWindow]:
 326:         """Get all currently pinned windows"""
 327:         return [w for w in self.managed_windows.values() if w.is_pinned]
 328:     
 329:     # Close a managed window and remove it from the managed_windows dictionary
 330:     def close_managed_window(self, window: ManagedWindow):
 331:         """Close the window"""
 332:         del self.managed_windows[window.hwnd] 
 333:         win32gui.PostMessage(window.hwnd, win32con.WM_CLOSE, 0, 0)
 334:         
 335:         #Use PostMessage to actually close the window.  The line below will just minimize it
 336:         # win32gui.CloseWindow(window.hwnd)

────────────────────────────────────────────────────────────────────────────────
FILE: windows_menu.py
────────────────────────────────────────────────────────────────────────────────
Path: windows_menu.py
Size: 22.5 KB
Lines: 554 total, 440 non-empty
Characters: 22,505
Type: Windows menu UI and interaction handling
────────────────────────────────────────────────────────────────────────────────

   1: # windows_menu.py (modified)
   2: """
   3: Windows menu UI for SuiteView Taskbar
   4: Shows list of open windows with hide/pin functionality
   5: Now excludes pinned windows from the list
   6: """
   7: 
   8: import tkinter as tk
   9: from config import Colors, Fonts, Dimensions
  10: from window_manager import WindowManager, ManagedWindow
  11: from utils import WindowsUtils
  12: from typing import Callable, Optional
  13: 
  14: class WindowsMenu(tk.Toplevel):
  15:     """Windows management menu"""
  16:     
  17:     def __init__(self, taskbar, window_manager: WindowManager, on_pin_callback: Callable, 
  18:                  stored_geometry: Optional[str] = None):
  19:         super().__init__(taskbar.root)
  20:         self.parent = taskbar
  21: 
  22: 
  23:         self.window_manager = window_manager
  24:         self.on_pin_callback = on_pin_callback
  25:         self.stored_geometry = stored_geometry
  26:                 
  27:         # Window setup
  28:         self.title("")  # No title for custom window
  29:         self.configure(bg=Colors.DARK_GREEN)
  30:         self.attributes('-topmost', True)
  31:         self.attributes('-alpha', 0.98)
  32:         
  33:         # Important: Make window resizable
  34:         self.resizable(True, True)
  35:         
  36:         # Remove default window decorations for custom look
  37:         self.overrideredirect(True)
  38:         
  39:         # Track window items for updates
  40:         self.window_items = {}
  41:         
  42:         # Resize variables
  43:         self.is_resizing = False
  44:         self.resize_edge = None
  45:         self.resize_start_x = 0
  46:         self.resize_start_y = 0
  47:         self.original_geometry = None
  48:         
  49:         # Main container with visible border
  50:         self.main_frame = tk.Frame(self, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=3)
  51:         self.main_frame.pack(fill=tk.BOTH, expand=True)
  52:         
  53:         # Create header
  54:         self.create_header()
  55:         
  56:         # Create scrollable content area
  57:         self.create_content_area()
  58:         
  59:         # Create resize handles
  60:         self.create_resize_handles()
  61:         
  62:         # Populate with windows
  63:         self.refresh_window_list()
  64:         
  65:         # Apply stored geometry or default size and position
  66:         if stored_geometry:
  67:             self.geometry(stored_geometry)
  68:         else:
  69:             # Set default size and position
  70:             default_width = 400  # Slightly narrower
  71:             
  72:             # Calculate height based on number of windows with smaller item height
  73:             window_count = len([w for w in self.window_manager.get_relevant_windows() if not w.is_pinned])
  74:             base_height = 80   # Minimum height for header and padding
  75:             item_height = 32   # Smaller height per window item
  76:             max_height = 700   # Increased max height to show more items
  77:             default_height = min(base_height + (window_count * item_height), max_height)
  78: 
  79:             screen_width = self.winfo_screenwidth()
  80:             screen_height = self.winfo_screenheight() 
  81: 
  82:             print(f"Windows taskbar height: {WindowsUtils.get_windows_taskbar_height()}")
  83: 
  84:             x = screen_width - default_width - 5
  85:             y = screen_height - default_height -  WindowsUtils.get_windows_taskbar_height()
  86:             
  87:             self.geometry(f"{default_width}x{default_height}+{x}+{y}")
  88:         
  89:         # Bind window close event
  90:         self.protocol("WM_DELETE_WINDOW", self.close_window)
  91:         
  92:         # Ensure window is visible
  93:         self.deiconify()
  94:         self.lift()
  95:     
  96:     def create_header(self):
  97:         """Create menu header"""
  98:         header_frame = tk.Frame(self.main_frame, bg=Colors.DARK_GREEN, height=30)
  99:         header_frame.pack(fill=tk.X, padx=1, pady=1)
 100:         header_frame.pack_propagate(False)
 101:         
 102:         # Make header draggable
 103:         header_frame.bind("<Button-1>", self.start_drag)
 104:         header_frame.bind("<B1-Motion>", self.do_drag)
 105:         
 106:         # Title
 107:         title = tk.Label(header_frame, text="🪟 Windows Manager", 
 108:                         bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 109:                         font=Fonts.MENU_HEADER, cursor='fleur')
 110:         title.pack(side=tk.LEFT, padx=10, pady=5)
 111:         title.bind("<Button-1>", self.start_drag)
 112:         title.bind("<B1-Motion>", self.do_drag)
 113:         
 114:         # Refresh button
 115:         refresh_btn = tk.Button(header_frame, text="↻ Refresh", 
 116:                                bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 117:                                relief=tk.RAISED, bd=1, cursor='hand2',
 118:                                font=Fonts.MENU_ITEM, command=self.refresh_window_list)
 119:         refresh_btn.pack(side=tk.RIGHT, padx=10, pady=5)
 120:         
 121:         # Close button
 122:         close_btn = tk.Button(header_frame, text="X", 
 123:                              bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 124:                              relief=tk.RAISED, bd=1, cursor='hand2',
 125:                              font=Fonts.MENU_ITEM, width=3,
 126:                              command=self.close_window)
 127:         close_btn.pack(side=tk.RIGHT, padx=5, pady=5)
 128:     
 129:     def create_resize_handles(self):
 130:         """Create resize handles for top, left, and right edges"""
 131:         # Top resize handle
 132:         top_handle = tk.Frame(self, cursor='size_ns', height=5)
 133:         top_handle.place(relx=0.0, rely=0.0, relwidth=1.0, anchor='nw')
 134:         top_handle.configure(bg=Colors.DARK_GREEN)
 135:         
 136:         # Bind resize events for top
 137:         top_handle.bind("<Button-1>", lambda e: self.start_resize(e, 't'))
 138:         top_handle.bind("<B1-Motion>", self.do_resize)
 139:         top_handle.bind("<ButtonRelease-1>", self.end_resize)
 140:         
 141:         # Left resize handle
 142:         left_handle = tk.Frame(self, cursor='size_we', width=5)
 143:         left_handle.place(relx=0.0, rely=0.0, relheight=1.0, anchor='nw')
 144:         left_handle.configure(bg=Colors.DARK_GREEN)
 145:         
 146:         # Bind resize events for left
 147:         left_handle.bind("<Button-1>", lambda e: self.start_resize(e, 'l'))
 148:         left_handle.bind("<B1-Motion>", self.do_resize)
 149:         left_handle.bind("<ButtonRelease-1>", self.end_resize)
 150:         
 151:         # Right resize handle
 152:         right_handle = tk.Frame(self, cursor='size_we', width=5)
 153:         right_handle.place(relx=1.0, rely=0.0, relheight=1.0, anchor='ne')
 154:         right_handle.configure(bg=Colors.DARK_GREEN)
 155:         
 156:         # Bind resize events for right
 157:         right_handle.bind("<Button-1>", lambda e: self.start_resize(e, 'r'))
 158:         right_handle.bind("<B1-Motion>", self.do_resize)
 159:         right_handle.bind("<ButtonRelease-1>", self.end_resize)
 160:         
 161:         # Visual feedback on hover
 162:         top_handle.bind("<Enter>", lambda e: self.configure(cursor='size_ns'))
 163:         top_handle.bind("<Leave>", lambda e: self.configure(cursor=''))
 164:         left_handle.bind("<Enter>", lambda e: self.configure(cursor='size_we'))
 165:         left_handle.bind("<Leave>", lambda e: self.configure(cursor=''))
 166:         right_handle.bind("<Enter>", lambda e: self.configure(cursor='size_we'))
 167:         right_handle.bind("<Leave>", lambda e: self.configure(cursor=''))
 168: 
 169:     def start_drag(self, event):
 170:         """Start dragging the window"""
 171:         self.drag_start_x = event.x_root
 172:         self.drag_start_y = event.y_root
 173:         self.original_x = self.winfo_x()
 174:         self.original_y = self.winfo_y()
 175: 
 176:     def do_drag(self, event):
 177:         """Handle window dragging"""
 178:         dx = event.x_root - self.drag_start_x
 179:         dy = event.y_root - self.drag_start_y
 180:         
 181:         new_x = self.original_x + dx
 182:         new_y = self.original_y + dy
 183:         
 184:         # Keep window on screen
 185:         screen_width = self.winfo_screenwidth()
 186:         screen_height = self.winfo_screenheight()
 187:         window_width = self.winfo_width()
 188:         window_height = self.winfo_height()
 189:         
 190:         new_x = max(0, min(new_x, screen_width - window_width))
 191:         new_y = max(0, min(new_y, screen_height - window_height))
 192:         
 193:         self.geometry(f"+{int(new_x)}+{int(new_y)}")
 194:         
 195:         # Update stored geometry in parent
 196:         if hasattr(self.parent, 'windows_menu_geometry'):
 197:             self.parent.windows_menu_geometry = self.get_current_geometry()
 198:     
 199:     def start_resize(self, event, edge):
 200:         """Start resizing operation"""
 201:         self.is_resizing = True
 202:         self.resize_edge = edge
 203:         self.resize_start_x = event.x_root
 204:         self.resize_start_y = event.y_root
 205:         
 206:         # Store original geometry
 207:         self.original_geometry = {
 208:             'x': self.winfo_x(),
 209:             'y': self.winfo_y(),
 210:             'width': self.winfo_width(),
 211:             'height': self.winfo_height()
 212:         }
 213:         
 214:         # Visual feedback
 215:         self.main_frame.configure(relief=tk.SUNKEN)
 216: 
 217:     def do_resize(self, event):
 218:         """Handle resize drag for all edges"""
 219:         if not self.is_resizing or not self.resize_edge:
 220:             return
 221:         
 222:         dx = event.x_root - self.resize_start_x
 223:         dy = event.y_root - self.resize_start_y
 224:         
 225:         x = self.original_geometry['x']
 226:         y = self.original_geometry['y']
 227:         width = self.original_geometry['width']
 228:         height = self.original_geometry['height']
 229:         
 230:         min_width = 400
 231:         min_height = 300
 232:         
 233:         # Handle different edges
 234:         if self.resize_edge == 't':  # Top edge
 235:             new_height = max(min_height, height - dy)
 236:             if new_height != height:
 237:                 y = y + (height - new_height)
 238:                 height = new_height
 239:                 
 240:         elif self.resize_edge == 'l':  # Left edge
 241:             new_width = max(min_width, width - dx)
 242:             if new_width != width:
 243:                 x = x + (width - new_width)
 244:                 width = new_width
 245:                 
 246:         elif self.resize_edge == 'r':  # Right edge
 247:             new_width = max(min_width, width + dx)
 248:             width = new_width
 249:         
 250:         # Apply new geometry
 251:         self.geometry(f"{int(width)}x{int(height)}+{int(x)}+{int(y)}")
 252: 
 253:     def end_resize(self, event):
 254:         """End resizing operation"""
 255:         self.is_resizing = False
 256:         self.resize_edge = None
 257:         
 258:         # Remove visual feedback
 259:         self.main_frame.configure(relief=tk.RAISED)
 260:         
 261:         # Update stored geometry in parent
 262:         if hasattr(self.parent, 'windows_menu_geometry'):
 263:             self.parent.windows_menu_geometry = self.get_current_geometry()
 264:             #print(f"Stored geometry after resize: {self.parent.windows_menu_geometry}")  # Debug
 265:     
 266:     def create_content_area(self):
 267:         """Create scrollable content area with adjusted sizing"""
 268:         # Create canvas and scrollbar for scrolling
 269:         self.canvas = tk.Canvas(self.main_frame, bg=Colors.LIGHT_GREEN, 
 270:                             highlightthickness=0)
 271:         scrollbar = tk.Scrollbar(self.main_frame, orient="vertical", 
 272:                                 command=self.canvas.yview, width=12)
 273:         self.scrollable_frame = tk.Frame(self.canvas, bg=Colors.LIGHT_GREEN)
 274:         
 275:         self.scrollable_frame.bind(
 276:             "<Configure>",
 277:             lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
 278:         )
 279:         
 280:         # Make sure the canvas window fills the width
 281:         canvas_window = self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
 282:         
 283:         # Bind canvas resize to update frame width
 284:         def configure_frame_width(event):
 285:             canvas_width = event.width
 286:             self.canvas.itemconfig(canvas_window, width=canvas_width)
 287:         
 288:         self.canvas.bind('<Configure>', configure_frame_width)
 289:         
 290:         self.canvas.configure(yscrollcommand=scrollbar.set)
 291:         
 292:         self.canvas.pack(side="left", fill="both", expand=True, padx=1, pady=1)
 293:         scrollbar.pack(side="right", fill="y")
 294:         
 295:         # Bind mouse wheel
 296:         self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
 297:     
 298:     def _on_mousewheel(self, event):
 299:         """Handle mouse wheel scrolling"""
 300:         if self.canvas.winfo_exists():
 301:             self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
 302:     
 303:     def refresh_window_list(self):
 304:         """Refresh the list of windows"""
 305:         # Clear existing items
 306:         for widget in self.scrollable_frame.winfo_children():
 307:             widget.destroy()
 308:         self.window_items.clear()
 309:         
 310:         # Get current windows and filter out pinned ones
 311:         all_windows = self.window_manager.get_relevant_windows()
 312:         windows = [w for w in all_windows if not w.is_pinned]  # Exclude pinned windows
 313:         
 314:         if not windows:
 315:             label = tk.Label(self.scrollable_frame, text="No unpinned windows found", 
 316:                            bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 317:                            font=Fonts.MENU_ITEM)
 318:             label.pack(pady=20)
 319:             return
 320:         
 321:         # Create item for each window
 322:         for window in windows:
 323:             self.create_window_item(window)
 324:     
 325:     def create_window_item(self, window: ManagedWindow):
 326:         """Create a single window item with app-named pin button"""
 327:         # Item container - this will stretch full width
 328:         item_frame = tk.Frame(self.scrollable_frame, bg=Colors.LIGHT_GREEN, 
 329:                             relief=tk.RAISED, bd=1)
 330:         item_frame.pack(fill=tk.X, padx=3, pady=1, anchor='e')  # Anchor to east (right)
 331:         
 332:         # Pin button with app name
 333:         try:
 334:             # Check if colors exist, use defaults if not
 335:             if hasattr(window, 'colors'):
 336:                 bg_color = window.colors['bg']
 337:                 fg_color = window.colors['fg']
 338:             else:
 339:                 bg_color = Colors.MEDIUM_GREEN
 340:                 fg_color = Colors.BLACK
 341:             
 342:             # Use app name for button text
 343:             button_text = window.app_name
 344: 
 345:             #Remove .exe from button_text (regardless of case)
 346:             button_text = button_text.replace('.exe', '').replace('.EXE', '').replace('.Exe', '')
 347: 
 348:             
 349:             # Special cases for common abbreviations
 350:             app_name_display = {
 351:                 'File Explorer': 'Explorer',
 352:                 'Visual Studio': 'VS',
 353:                 'VS Code': 'Code',
 354:                 'Acrobat Reader': 'Reader',
 355:                 'Google Chrome': 'Chrome',
 356:                 'Winword': 'Word',
 357:             }.get(button_text, button_text)
 358:             
 359:             pin_btn = tk.Button(item_frame, text=app_name_display, 
 360:                             bg=bg_color, fg=fg_color,
 361:                             relief=tk.RAISED, bd=1, cursor='hand2',
 362:                             font=('Arial', 8), 
 363:                             width=10,  # Wider to accommodate app names
 364:                             wraplength=60,  # Allow text wrapping
 365:                             justify='center',
 366:                             height=1,  # Keep height at 1 as requested
 367:                             command=lambda: self.toggle_pin(window))
 368:             pin_btn.pack(side=tk.LEFT, padx=3, pady=2)
 369:             
 370:         except Exception as e:
 371:             print(f"Error creating pin button: {e}")
 372:             # Fallback pin button
 373:             pin_btn = tk.Button(item_frame, text="Pin", 
 374:                             bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 375:                             relief=tk.RAISED, bd=1, cursor='hand2',
 376:                             font=('Arial', 8), width=10, height=1,
 377:                             command=lambda: self.toggle_pin(window))
 378:             pin_btn.pack(side=tk.LEFT, padx=3, pady=2)
 379:         
 380:         # Add color indicator on right side FIRST (so it appears on the far right)
 381:         try:
 382:             if hasattr(window, 'colors'):
 383:                 color_indicator = tk.Frame(item_frame, bg=window.colors['bg'], width=5)
 384:                 color_indicator.pack(side=tk.RIGHT, fill=tk.Y, padx=(0, 2))
 385:         except:
 386:             pass  # Skip color indicator if there's an issue
 387:         
 388:         # Window name label - pack after color indicator so it fills the middle space
 389:         label_bg = Colors.WINDOW_HIDDEN if window.is_hidden else Colors.WINDOW_VISIBLE
 390:         label_fg = Colors.WHITE if window.is_hidden else Colors.BLACK
 391:         
 392:         # Use the display name
 393:         display_text = window.display_name if hasattr(window, 'display_name') else window.title
 394:         
 395:         # Truncate very long names
 396:         max_chars = 200  # Reduced because button is wider now
 397:         if len(display_text) > max_chars:
 398:             display_text = display_text[:max_chars-3] + "..."
 399:         
 400:         name_label = tk.Label(item_frame, text=display_text, 
 401:                             bg=label_bg, fg=label_fg,
 402:                             font=('Arial', 9), anchor='w',
 403:                             cursor='hand2', padx=5, pady=2)
 404:         name_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
 405:         
 406:         # Bind click events
 407:         name_label.bind("<Button-1>", lambda e: self.show_window(window))
 408:         name_label.bind("<Double-Button-1>", lambda e: self.remove_window(window))
 409:         
 410:         # Store references for updating
 411:         self.window_items[window.hwnd] = {
 412:             'frame': item_frame,
 413:             'label': name_label,
 414:             'pin_btn': pin_btn,
 415:             'window': window
 416:         }
 417:         
 418:         # Force the frame to update
 419:         item_frame.update_idletasks()
 420:     
 421:     def toggle_window_visibility(self, window: ManagedWindow):
 422:         """Toggle window visibility and update UI"""
 423:         if self.window_manager.toggle_window_visibility(window):
 424:             self.update_window_item(window)
 425:     
 426:     def show_window(self, window: ManagedWindow):
 427:         """Show the window"""
 428:         window.show()
 429:         window.bring_to_front()
 430: 
 431:     def update_window_item(self, window: ManagedWindow):
 432:         """Update the UI for a specific window item"""
 433:         if window.hwnd not in self.window_items:
 434:             return
 435:         
 436:         item = self.window_items[window.hwnd]
 437:         
 438:         # Update label color based on visibility
 439:         label_bg = Colors.WINDOW_HIDDEN if window.is_hidden else Colors.WINDOW_VISIBLE
 440:         label_fg = Colors.WHITE if window.is_hidden else Colors.BLACK
 441:         item['label'].configure(bg=label_bg, fg=label_fg)
 442: 
 443:     def remove_window(self, window: ManagedWindow):
 444:         """Close window and remove label button from windows_menu  """
 445:         self.window_manager.close_managed_window(window)
 446:         self.refresh_window_list()
 447: 
 448:     def toggle_pin(self, window: ManagedWindow):
 449:         """Toggle window pin state"""
 450:         print(f"\n=== TOGGLE PIN DEBUG ===")
 451:         print(f"Window: {window.display_name}")
 452:         print(f"Was pinned: {window.is_pinned}")
 453:         
 454:         if window.is_pinned:
 455:             self.window_manager.unpin_window(window)
 456:         else:
 457:             self.window_manager.pin_window(window)
 458:         
 459:         print(f"Now pinned: {window.is_pinned}")
 460:         
 461:         # Notify callback to update taskbar
 462:         if self.on_pin_callback:
 463:             print(f"Calling on_pin_callback: {self.on_pin_callback}")
 464:             self.on_pin_callback()
 465:         else:
 466:             print("ERROR: on_pin_callback is None!")
 467:         
 468:         # Remove this window from the list since it's now pinned
 469:         if window.is_pinned:
 470:             self.refresh_window_list()
 471:         
 472:         # List all pinned windows
 473:         pinned = self.window_manager.get_pinned_windows()
 474:         print(f"Total pinned windows: {len(pinned)}")
 475:         for pw in pinned:
 476:             print(f"  - {pw.display_name}")
 477:         print("=== END DEBUG ===\n")
 478:     
 479:     def get_current_geometry(self):
 480:         """Get current window geometry string"""
 481:         return self.geometry()
 482:     
 483:     def close_window(self):
 484:         """Close the windows menu"""
 485:         # Store geometry before closing
 486:         if hasattr(self.parent, 'windows_menu_geometry'):
 487:             self.parent.stored_geometry = self.get_current_geometry()
 488:             print(f"Storing geometry on close: {self.parent.windows_menu_geometry}")  # Debug
 489:         
 490:         # Unbind mousewheel to prevent errors
 491:         self.canvas.unbind_all("<MouseWheel>")
 492:         self.destroy()
 493: 
 494:     def refresh_window_list(self, only_update_titles=False):
 495:         """Refresh the list of windows or just update titles"""
 496:         if only_update_titles and self.window_items:
 497:             # Just update existing titles without full refresh
 498:             current_windows = self.window_manager.get_relevant_windows()
 499:             
 500:             for window in current_windows:
 501:                 if window.hwnd in self.window_items and not window.is_pinned:
 502:                     self.update_window_title(window)
 503:             
 504:             return
 505:         
 506:         
 507:         # Clear existing items
 508:         for widget in self.scrollable_frame.winfo_children():
 509:             widget.destroy()
 510:         self.window_items.clear()
 511:         
 512:         # Get current windows and filter out pinned ones
 513:         all_windows = self.window_manager.get_relevant_windows()
 514:         windows = [w for w in all_windows if not w.is_pinned]
 515:         
 516:         if not windows:
 517:             label = tk.Label(self.scrollable_frame, text="No unpinned windows found", 
 518:                         bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 519:                         font=Fonts.MENU_ITEM)
 520:             label.pack(pady=20)
 521:             return
 522:         
 523:         # Create item for each window
 524:         for window in windows:
 525:             self.create_window_item(window)
 526:     
 527:     def update_window_title(self, window: ManagedWindow):
 528:         """Update a specific window's title without refreshing entire list"""
 529:         if window.hwnd in self.window_items:
 530:             item = self.window_items[window.hwnd]
 531:             
 532:             # Update the label text
 533:             display_text = window.display_name
 534:             
 535:             # Truncate very long names
 536:             max_chars = 60
 537:             if len(display_text) > max_chars:
 538:                 display_text = display_text[:max_chars-3] + "..."
 539:             
 540:             item['label'].configure(text=display_text)
 541:             
 542:             # Update colors if file type changed (e.g., opened different file type in Notepad)
 543:             if hasattr(window, 'colors'):
 544:                 # Update pin button colors
 545:                 item['pin_btn'].configure(
 546:                     bg=window.colors['bg'], 
 547:                     fg=window.colors['fg']
 548:                 )
 549:                 
 550:                 # Update color indicator if it exists
 551:                 for widget in item['frame'].winfo_children():
 552:                     if isinstance(widget, tk.Frame) and widget.winfo_width() == 3:
 553:                         widget.configure(bg=window.colors['bg'])
 554:                         break

────────────────────────────────────────────────────────────────────────────────
FILE: requirements.txt
────────────────────────────────────────────────────────────────────────────────
Path: requirements.txt
Size: 42.0 B
Lines: 5 total, 5 non-empty
Characters: 38
Type: Python package dependencies
────────────────────────────────────────────────────────────────────────────────

PySide6
pywin32
Pillow
psutil
comtypes


================================================================================
                           EXPORT SUMMARY
================================================================================

Files Processed: 23
Total Size: 330.4 KB
Total Python Lines: 8,224

File Breakdown:
    README.md                  718.0 B (  31 lines)
    browse_choice_dialog.py     7.0 KB ( 187 lines)
    config.py                   7.1 KB ( 175 lines)
    email_manager.py           20.0 KB ( 480 lines)
    email_menu.py              15.0 KB ( 348 lines)
    email_options_menu.py       6.5 KB ( 173 lines)
    enhanced_folder_inventory.py  23.5 KB ( 569 lines)
    explorer_utils.py           8.9 KB ( 226 lines)
    folder_inventory.py        25.8 KB ( 619 lines)
    inventory_view_examples.py  10.5 KB ( 299 lines)
    inventory_view_window.py   32.0 KB ( 757 lines)
    links_manager.py           10.8 KB ( 306 lines)
    main.py                     1.1 KB (  42 lines)
    pinned_windows.py          13.3 KB ( 338 lines)
    quick_links.py             36.3 KB ( 867 lines)
    restore_deskop.py           1.5 KB (  41 lines)
    snip_feature.py            16.1 KB ( 410 lines)
    taskbar.py                 22.4 KB ( 542 lines)
    ui_components.py           28.7 KB ( 745 lines)
    utils.py                    7.0 KB ( 211 lines)
    window_manager.py          13.6 KB ( 336 lines)
    windows_menu.py            22.5 KB ( 554 lines)
    requirements.txt            42.0 B (   5 lines)

================================================================================
                    END OF SUITEVIEW SOURCE CODE
================================================================================
