
================================================================================
                    SUITEVIEW TASKBAR APPLICATION
                         COMPLETE SOURCE CODE
================================================================================

Export Information:
    Generated on: 2025-07-04 14:32:21
    Project Directory: C:\Users\rober\Documents\Code\TaskBarApp
    Export Tool: SuiteView Code Exporter v1.0

Description:
    This file contains the complete source code for the SuiteView Taskbar 
    Application - a customizable Windows taskbar replacement with quick links
    functionality, drag-and-drop support, and modern UI components.

Project Structure:
    • Main Application Files: main.py, taskbar.py
    • UI Components: ui_components.py, quick_links.py
    • Data Management: links_manager.py, config.py
    • Utilities: utils.py, browse_choice_dialog.py, restore_deskop.py
    • Configuration: requirements.txt, README.md

================================================================================


────────────────────────────────────────────────────────────────────────────────
FILE: README.md
────────────────────────────────────────────────────────────────────────────────
Path: README.md
Size: 718.0 B
Lines: 31 total, 26 non-empty
Characters: 688
Type: Project documentation and setup instructions
────────────────────────────────────────────────────────────────────────────────

# SuiteView Taskbar App

A simple, customizable taskbar app for Windows 11, built with PySide2.

## Features
- Always-on-top, borderless taskbar bar
- Two-tone green theme
- System tray integration
- Easy to extend with new buttons and features

## Setup
1. Install Python 3.8+
2. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```
3. Run the app:
   ```bash
   python main.py
   ```

## Packaging (Optional)
To create a standalone executable, install PyInstaller:
```bash
pip install pyinstaller
pyinstaller --onefile --windowed main.py
```

## Customization
- Add new buttons and features by editing `main.py`.
- Update colors and styles in the code as desired. 

────────────────────────────────────────────────────────────────────────────────
FILE: browse_choice_dialog.py
────────────────────────────────────────────────────────────────────────────────
Path: browse_choice_dialog.py
Size: 7.0 KB
Lines: 187 total, 153 non-empty
Characters: 6,939
Type: File/folder selection dialog
────────────────────────────────────────────────────────────────────────────────

   1: # browse_choice_dialog.py
   2: """
   3: Custom dialog for choosing between file and folder browsing
   4: Replaces messagebox with properly styled, topmost dialog
   5: """
   6: 
   7: import tkinter as tk
   8: from tkinter import filedialog
   9: from config import Colors, Fonts, Dimensions
  10: from ui_components import CustomDialog
  11: 
  12: class BrowseChoiceDialog(CustomDialog):
  13:     """Custom dialog for choosing between File or Folder browsing"""
  14:     
  15:     def __init__(self, parent):
  16:         super().__init__(parent, "Browse Type", width=350, height=350)
  17:         
  18:         self.choice_result = None  # Will store 'file', 'folder', or None
  19:         self.selected_path = None  # Will store the selected path
  20:         
  21:         # Make sure dialog stays on top of everything
  22:         self.attributes('-topmost', True)
  23:         self.lift()
  24:         self.focus_force()
  25:         
  26:         self.create_content()
  27:         self.create_buttons()
  28:         
  29:         # Bind keyboard shortcuts
  30:         self.bind('<F>', lambda e: self.choose_file())
  31:         self.bind('<f>', lambda e: self.choose_file())
  32:         self.bind('<D>', lambda e: self.choose_folder())
  33:         self.bind('<d>', lambda e: self.choose_folder())
  34:         self.bind('<Escape>', lambda e: self.cancel())
  35:     
  36:     def create_content(self):
  37:         """Create the dialog content"""
  38:         # Icon
  39:         icon_label = tk.Label(self.dialog_content, text="📁", bg=Colors.LIGHT_GREEN,
  40:                              fg=Colors.DARK_GREEN, font=('Arial', 24))
  41:         icon_label.pack(pady=10)
  42:         
  43:         # Main message
  44:         message_label = tk.Label(self.dialog_content, 
  45:                                text="What would you like to browse for?", 
  46:                                bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
  47:                                font=Fonts.DIALOG_LABEL, wraplength=300)
  48:         message_label.pack(pady=5)
  49:         
  50:         # Instructions
  51:         instruction_label = tk.Label(self.dialog_content, 
  52:                                    text="Choose File for documents, applications, etc.\nChoose Folder for directories", 
  53:                                    bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
  54:                                    font=(Fonts.DIALOG_LABEL[0], Fonts.DIALOG_LABEL[1] - 1),
  55:                                    justify=tk.CENTER)
  56:         instruction_label.pack(pady=5)
  57:     
  58:     def create_buttons(self):
  59:         """Create the choice buttons"""
  60:         # Make sure button frame is visible and has proper height
  61:         self.button_frame.configure(height=80)
  62:         self.button_frame.pack_propagate(False)
  63:         
  64:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
  65:         button_container.pack(expand=True, fill=tk.BOTH, pady=10)
  66:         
  67:         # File button (primary choice)
  68:         file_btn = tk.Button(button_container, text="File", 
  69:                            bg=Colors.DARK_GREEN, fg=Colors.WHITE,
  70:                            command=self.choose_file, 
  71:                            width=10, height=20,
  72:                            font=Fonts.DIALOG_BUTTON, 
  73:                            relief=tk.RAISED, bd=2,
  74:                            cursor='hand2')
  75:         file_btn.pack(side=tk.LEFT, padx=15, pady=10)
  76:         
  77:         # Folder button
  78:         folder_btn = tk.Button(button_container, text="Folder", 
  79:                              bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
  80:                              command=self.choose_folder, 
  81:                              width=10, height=20,
  82:                              font=Fonts.DIALOG_BUTTON, 
  83:                              relief=tk.RAISED, bd=2,
  84:                              cursor='hand2')
  85:         folder_btn.pack(side=tk.LEFT, padx=15, pady=10)
  86:         
  87:         # Cancel button
  88:         cancel_btn = tk.Button(button_container, text="Cancel", 
  89:                              bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
  90:                              command=self.cancel, 
  91:                              width=8, height=20,
  92:                              font=Fonts.DIALOG_BUTTON, 
  93:                              relief=tk.RAISED, bd=1)
  94:         cancel_btn.pack(side=tk.LEFT, padx=15, pady=10)
  95:         
  96:         # Set focus on File button (most common choice)
  97:         file_btn.focus_set()
  98:     
  99:     def choose_file(self):
 100:         """Handle file selection"""
 101:         self.choice_result = 'file'
 102:         
 103:         # Disable topmost and hide this dialog temporarily
 104:         self.attributes('-topmost', False)
 105:         self.withdraw()  # Hide this dialog temporarily
 106:         
 107:         # Use the parent window for the file dialog
 108:         try:
 109:             path = filedialog.askopenfilename(
 110:                 parent=self.parent,
 111:                 title="Select File",
 112:                 filetypes=[
 113:                     ("All Files", "*.*"),
 114:                     ("Executables", "*.exe"),
 115:                     ("Documents", "*.pdf;*.doc;*.docx;*.txt"),
 116:                     ("Spreadsheets", "*.xls;*.xlsx;*.csv"),
 117:                     ("Images", "*.png;*.jpg;*.jpeg;*.gif;*.bmp")
 118:                 ]
 119:             )
 120:             
 121:             if path:
 122:                 self.selected_path = path
 123:                 self.result = True
 124:             else:
 125:                 self.result = None
 126:                 
 127:         except Exception as e:
 128:             print(f"Error in file dialog: {e}")
 129:             self.result = None
 130:         
 131:         self.destroy()
 132:     
 133:     def choose_folder(self):
 134:         """Handle folder selection"""
 135:         self.choice_result = 'folder'
 136:                 
 137:         # Disable topmost and hide this dialog temporarily
 138:         self.attributes('-topmost', False)
 139:         self.withdraw()  # Hide this dialog temporarily
 140:         
 141:         # Use the parent window for the folder dialog
 142:         try:
 143:             path = filedialog.askdirectory(
 144:                 parent=self.parent,
 145:                 title="Select Folder"
 146:             )
 147:             
 148:             if path:
 149:                 self.selected_path = path
 150:                 self.result = True
 151:             else:
 152:                 self.result = None
 153:                 
 154:         except Exception as e:
 155:             print(f"Error in folder dialog: {e}")
 156:             self.result = None
 157:         
 158:         self.destroy()
 159:     
 160:     def cancel(self):
 161:         """Cancel the dialog"""
 162:         self.choice_result = None
 163:         self.selected_path = None
 164:         self.result = None
 165:         self.destroy()
 166:     
 167:     @classmethod
 168:     def get_path(cls, parent):
 169:         """
 170:         Show the browse choice dialog and return the selected path
 171:         
 172:         Returns:
 173:             tuple: (choice_type, selected_path) where choice_type is 'file', 'folder', or None
 174:         """
 175:         dialog = cls(parent)
 176:         
 177:         # Ensure dialog is visible and on top
 178:         dialog.deiconify()
 179:         dialog.lift()
 180:         dialog.attributes('-topmost', True)
 181:         dialog.focus_force()
 182:         dialog.grab_set()
 183:         
 184:         # Wait for dialog to complete
 185:         parent.wait_window(dialog)
 186:         
 187:         return dialog.choice_result, dialog.selected_path

────────────────────────────────────────────────────────────────────────────────
FILE: config.py
────────────────────────────────────────────────────────────────────────────────
Path: config.py
Size: 7.4 KB
Lines: 186 total, 155 non-empty
Characters: 7,353
Type: Application configuration and constants
────────────────────────────────────────────────────────────────────────────────

   1: # config.py
   2: """
   3: Configuration constants for SuiteView Taskbar Application
   4: Contains colors, sizes, paths, and other application settings
   5: """
   6: 
   7: from pathlib import Path
   8: 
   9: # Color Scheme (Two-Tone Green)
  10: class Colors:
  11:     #DARK_GREEN = '#006600'      # Main taskbar, headers, borders
  12:     DARK_GREEN = "#2d5a2d"
  13:     MEDIUM_GREEN = '#00AA00'    # Menu backgrounds, inactive elements  
  14:     #LIGHT_GREEN = '#B3FFB3'     # Input fields, hover states, active elements (lighter green)
  15:     LIGHT_GREEN = "#e8f5e8"
  16:     HOVER_GREEN = '#008800'     # Hover effects
  17:     INACTIVE_GRAY = '#666666'   # Cancel buttons, disabled elements
  18:     WHITE = '#FFFFFF'
  19:     BLACK = '#000000'
  20: 
  21:     WINDOW_HIDDEN = '#FF6666'      # Red tint for hidden windows
  22:     WINDOW_VISIBLE = '#66FF66'     # Green tint for visible windows
  23:     PINNED_SECTION_BG = '#004400'  # Darker green for pinned section
  24:     PIN_BUTTON_COLOR = '#FFFF00'   # Yellow for pin buttons
  25: 
  26: # Font Settings
  27: class Fonts:
  28:     TASKBAR_TITLE = ('Arial', 14, 'bold italic')
  29:     TASKBAR_BUTTON = ('Arial', 10)
  30:     MENU_HEADER = ('Arial', 10, 'bold')
  31:     MENU_ITEM = ('Arial', 8)
  32:     DIALOG_TITLE = ('Arial', 10, 'bold')
  33:     DIALOG_LABEL = ('Arial', 9)
  34:     DIALOG_BUTTON = ('Arial', 9)
  35:     WARNING_ICON = ('Arial', 20)
  36:     
  37:     # Tree view fonts for folder inventory
  38:     TREE_ITEM = ('Arial', 9)
  39:     TREE_HEADING = ('Arial', 9, 'bold')
  40:     
  41:     # Generic button font
  42:     BUTTON = ('Arial', 9)
  43:     
  44:     # Status bar font
  45:     STATUS = ('Arial', 8)
  46: 
  47: # Window Dimensions
  48: class Dimensions:
  49:     TASKBAR_HEIGHT = 40
  50:     MENU_MIN_WIDTH = 200
  51:     MENU_MIN_HEIGHT = 100
  52:     DIALOG_BUTTON_WIDTH = 8
  53:     DIALOG_PADDING = 10
  54: 
  55: # File Paths
  56: class Paths:
  57:     CONFIG_DIR = Path.home() / '.suiteview'
  58:     LINKS_FILE = CONFIG_DIR / 'links.json'
  59:     
  60:     @classmethod
  61:     def ensure_config_dir(cls):
  62:         """Ensure configuration directory exists"""
  63:         cls.CONFIG_DIR.mkdir(exist_ok=True)
  64:     
  65:     @classmethod
  66:     def get_config_dir_str(cls):
  67:         """Get configuration directory as normalized Windows path string"""
  68:         import os
  69:         return os.path.normpath(str(cls.CONFIG_DIR))
  70:     
  71:     @classmethod
  72:     def get_links_file_str(cls):
  73:         """Get links file path as normalized Windows path string"""
  74:         import os
  75:         return os.path.normpath(str(cls.LINKS_FILE))
  76: 
  77: # Windows API Constants
  78: class WindowsAPI:
  79:     SPI_SETWORKAREA = 0x002F
  80:     SPI_GETWORKAREA = 0x0030
  81:     HWND_TOPMOST = -1
  82:     SWP_NOMOVE = 0x0002
  83:     SWP_NOSIZE = 0x0001
  84:     SPIF_SENDCHANGE = 0x0002
  85: 
  86: # Default Categories for Links
  87: DEFAULT_CATEGORIES = ["Quick Links", "Applications", "Folders", "Websites"]
  88: 
  89: # Application Settings
  90: class Settings:
  91:     APP_NAME = "SuiteView"
  92:     VERSION = "2.0"
  93:     TASKBAR_OPACITY = 1.00
  94:     MENU_OPACITY = 1.00
  95:     AUTO_REFRESH_INTERVAL = 1000  # milliseconds
  96:     PINNED_SECTION_WIDTH = 400     # Width allocated for pinned windows
  97:     PINNED_BUTTON_WIDTH = 80       # Width of each pinned window button
  98: 
  99: 
 100: class AppColors:
 101:     """Application-specific color schemes"""
 102:     
 103:     # Define app colors with background and appropriate foreground colors
 104:     APP_COLORS = {
 105:         # Microsoft Office
 106:         'winword': {'bg': '#2B579A', 'fg': '#FFFFFF'},      # Word Blue
 107:         'excel': {'bg': '#217346', 'fg': '#FFFFFF'},        # Excel Green
 108:         'powerpnt': {'bg': '#D24726', 'fg': '#FFFFFF'},     # PowerPoint Orange
 109:         'outlook': {'bg': '#0072C6', 'fg': '#FFFFFF'},      # Outlook Blue
 110:         'msaccess': {'bg': '#A4373A', 'fg': '#FFFFFF'},     # Access Red
 111:         'onenote': {'bg': '#7719AA', 'fg': '#FFFFFF'},      # OneNote Purple
 112:         'mspub': {'bg': '#077568', 'fg': '#FFFFFF'},        # Publisher Teal
 113:         'teams': {'bg': '#6264A7', 'fg': '#FFFFFF'},        # Teams Purple
 114:         
 115:         # Browsers
 116:         'chrome': {'bg': '#4285F4', 'fg': '#FFFFFF'},       # Chrome Blue
 117:         'firefox': {'bg': '#FF7139', 'fg': '#FFFFFF'},      # Firefox Orange
 118:         'msedge': {'bg': '#0078D7', 'fg': '#FFFFFF'},       # Edge Blue
 119:         'opera': {'bg': '#FF1B2D', 'fg': '#FFFFFF'},        # Opera Red
 120:         'brave': {'bg': '#FB542B', 'fg': '#FFFFFF'},        # Brave Orange
 121:         
 122:         # Development Tools
 123:         'code': {'bg': '#007ACC', 'fg': '#FFFFFF'},         # VS Code Blue
 124:         'devenv': {'bg': '#5C2D91', 'fg': '#FFFFFF'},       # Visual Studio Purple
 125:         'pycharm64': {'bg': '#21D789', 'fg': '#FFFFFF'},    # PyCharm Green
 126:         'sublime_text': {'bg': '#FF9800', 'fg': '#FFFFFF'}, # Sublime Orange
 127:         'notepad++': {'bg': '#90C53F', 'fg': '#FFFFFF'},    # Notepad++ Green
 128:         'cursor': {'bg': '#000000', 'fg': '#FFFFFF'},       # Cursor AI Black
 129:         
 130:         # File Types/Readers
 131:         'acrobat': {'bg': '#EC1C24', 'fg': '#FFFFFF'},      # Adobe Acrobat Red
 132:         'acrord32': {'bg': '#EC1C24', 'fg': '#FFFFFF'},     # Adobe Reader Red
 133:         
 134:         # Communication
 135:         'slack': {'bg': '#4A154B', 'fg': '#FFFFFF'},        # Slack Purple
 136:         'discord': {'bg': '#5865F2', 'fg': '#FFFFFF'},      # Discord Blurple
 137:         'zoom': {'bg': '#2D8CFF', 'fg': '#FFFFFF'},         # Zoom Blue
 138:         'skype': {'bg': '#00AFF0', 'fg': '#FFFFFF'},        # Skype Blue
 139:         
 140:         # Media/Creative
 141:         'photoshop': {'bg': '#31A8FF', 'fg': '#FFFFFF'},    # Photoshop Blue
 142:         'illustrator': {'bg': '#FF9A00', 'fg': '#FFFFFF'},  # Illustrator Orange
 143:         'premiere': {'bg': '#EA77FF', 'fg': '#000000'},     # Premiere Purple
 144:         'spotify': {'bg': '#1DB954', 'fg': '#FFFFFF'},      # Spotify Green
 145:         'vlc': {'bg': '#FF8800', 'fg': '#FFFFFF'},          # VLC Orange
 146:         
 147:         # System/Utilities
 148:         'explorer': {'bg': '#FFB900', 'fg': '#000000'},     # File Explorer Yellow
 149:         'cmd': {'bg': '#0C0C0C', 'fg': '#FFFFFF'},          # Command Prompt Black
 150:         'powershell': {'bg': '#012456', 'fg': '#FFFFFF'},   # PowerShell Blue
 151:         'taskmgr': {'bg': '#0078D7', 'fg': '#FFFFFF'},      # Task Manager Blue
 152:         'notepad': {'bg': '#D0D0D0', 'fg': '#000000'},      # Notepad Light Gray
 153:         
 154:         # Default
 155:         'default': {'bg': '#6B6B6B', 'fg': '#FFFFFF'}       # Default Gray
 156:     }
 157:     
 158:     @classmethod
 159:     def get_app_colors(cls, process_name):
 160:         """Get colors for an application based on process name"""
 161:         # Remove .exe extension and convert to lowercase
 162:         app_name = process_name.replace('.exe', '').lower()
 163:         
 164:         # Check for file extensions in the window title
 165:         # This will be handled in the ManagedWindow class
 166:         
 167:         return cls.APP_COLORS.get(app_name, cls.APP_COLORS['default'])
 168:     
 169:     @classmethod
 170:     def get_colors_for_file_type(cls, title):
 171:         """Get colors based on file type in window title"""
 172:         title_lower = title.lower()
 173:         
 174:         # Check for file types in title
 175:         if '.xlsx' in title_lower or '.xls' in title_lower or '.csv' in title_lower:
 176:             return cls.APP_COLORS['excel']
 177:         elif '.docx' in title_lower or '.doc' in title_lower:
 178:             return cls.APP_COLORS['winword']
 179:         elif '.pptx' in title_lower or '.ppt' in title_lower:
 180:             return cls.APP_COLORS['powerpnt']
 181:         elif '.pdf' in title_lower:
 182:             return cls.APP_COLORS['acrobat']
 183:         elif '.accdb' in title_lower or '.mdb' in title_lower:
 184:             return cls.APP_COLORS['msaccess']
 185:         
 186:         return None

────────────────────────────────────────────────────────────────────────────────
FILE: email_manager.py
────────────────────────────────────────────────────────────────────────────────
Path: email_manager.py
Size: 20.0 KB
Lines: 480 total, 398 non-empty
Characters: 19,998
Type: Email functionality and management
────────────────────────────────────────────────────────────────────────────────

   1: # email_manager.py
   2: """
   3: Updated email attachment management with support for both received and sent emails
   4: """
   5: 
   6: import win32com.client
   7: from datetime import datetime, timedelta
   8: import tkinter as tk
   9: import json
  10: import os
  11: from pathlib import Path
  12: import threading
  13: import time
  14: 
  15: # Keep existing EmailCache class as-is
  16: class EmailCache:
  17:     """Handles caching of email scan results"""
  18:     
  19:     def __init__(self, cache_dir: str | Path = None):
  20:         """Initialize the email cache"""
  21:         if cache_dir is None:
  22:             # Use app config directory
  23:             self.cache_dir = Path.home() / '.suiteview' / 'email_cache'
  24:         else:
  25:             self.cache_dir = cache_dir
  26:         
  27:         # Ensure cache directory exists
  28:         self.cache_dir.mkdir(parents=True, exist_ok=True)
  29:     
  30:     def get_cache_file(self, scan_type: str) -> Path:
  31:         """Get the cache file path for a specific scan type"""
  32:         return self.cache_dir / f"{scan_type}_cache.json"
  33:     
  34:     def save_scan(self, scan_type: str, data: list[dict], metadata: dict):
  35:         """Save scan results to cache"""
  36:         cache_file = self.get_cache_file(scan_type)
  37:         cache_data = {
  38:             'metadata': metadata,
  39:             'data': data,
  40:             'cached_at': datetime.now().isoformat()
  41:         }
  42:         
  43:         try:
  44:             with open(cache_file, 'w', encoding='utf-8') as f:
  45:                 json.dump(cache_data, f, indent=2, ensure_ascii=False)
  46:             return True
  47:         except Exception as e:
  48:             print(f"Error saving cache: {e}")
  49:             return False
  50:     
  51:     def load_scan(self, scan_type: str) -> dict | None:
  52:         """Load scan results from cache"""
  53:         cache_file = self.get_cache_file(scan_type)
  54:         
  55:         if not cache_file.exists():
  56:             return None
  57:         
  58:         try:
  59:             with open(cache_file, 'r', encoding='utf-8') as f:
  60:                 cache_data = json.load(f)
  61:             
  62:             # Convert cached_at back to datetime
  63:             cache_data['cached_at'] = datetime.fromisoformat(cache_data['cached_at'])
  64:             return cache_data
  65:         except Exception as e:
  66:             print(f"Error loading cache: {e}")
  67:             return None
  68:     
  69:     def is_cache_valid(self, scan_type: str, max_age_minutes: int = 60) -> bool:
  70:         """Check if cache exists and is still valid"""
  71:         cache_data = self.load_scan(scan_type)
  72:         if not cache_data:
  73:             return False
  74:         
  75:         cached_at = cache_data['cached_at']
  76:         age = datetime.now() - cached_at
  77:         return age.total_seconds() < (max_age_minutes * 60)
  78:     
  79:     def clear_cache(self, scan_type: str | None = None):
  80:         """Clear cache for specific scan type or all caches"""
  81:         if scan_type:
  82:             cache_file = self.get_cache_file(scan_type)
  83:             if cache_file.exists():
  84:                 cache_file.unlink()
  85:         else:
  86:             # Clear all cache files
  87:             for cache_file in self.cache_dir.glob("*_cache.json"):
  88:                 cache_file.unlink()
  89: 
  90: 
  91: class EmailManager:
  92:     """Enhanced email manager with caching and support for received/sent emails"""
  93:     
  94:     # Scan type constants
  95:     SCAN_ATTACHMENTS = "attachments"
  96:     SCAN_ATTACHMENTS_SENT = "attachments_sent"
  97:     SCAN_IMPORTANT = "important"
  98:     SCAN_FLAGGED = "flagged"
  99:     SCAN_UNREAD = "unread"
 100:     
 101:     def __init__(self, weeks_back: int = 2):
 102:         """Initialize the email manager"""
 103:         self.weeks_back = weeks_back
 104:         self.outlook = None
 105:         self.cache = EmailCache()
 106:         self._initialize_outlook()
 107:         
 108:         # Track if a scan is in progress
 109:         self.scan_in_progress = False
 110:         self.current_scan_thread = None
 111:     
 112:     def _initialize_outlook(self):
 113:         """Initialize Outlook connection"""
 114:         try:
 115:             self.outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
 116:         except Exception as e:
 117:             print(f"Error initializing Outlook: {e}")
 118:             self.outlook = None
 119:     
 120:     def get_emails_with_attachments(self, use_cache: bool = True, 
 121:                                    force_refresh: bool = False,
 122:                                    email_type: str = 'received') -> dict:
 123:         """
 124:         Get emails with attachments, using cache if available
 125:         
 126:         Args:
 127:             use_cache: Whether to use cached data
 128:             force_refresh: Force a fresh scan
 129:             email_type: 'received' or 'sent'
 130:         
 131:         Returns:
 132:             Dictionary with 'data', 'metadata', and 'from_cache' keys
 133:         """
 134:         scan_type = self.SCAN_ATTACHMENTS if email_type == 'received' else self.SCAN_ATTACHMENTS_SENT
 135:         
 136:         # Check cache first if requested
 137:         if use_cache and not force_refresh:
 138:             cached_data = self.cache.load_scan(scan_type)
 139:             if cached_data and self.cache.is_cache_valid(scan_type):
 140:                 return {
 141:                     'data': cached_data['data'],
 142:                     'metadata': cached_data['metadata'],
 143:                     'from_cache': True,
 144:                     'cached_at': cached_data['cached_at']
 145:                 }
 146:         
 147:         # Perform fresh scan
 148:         if email_type == 'received':
 149:             return self._scan_emails_with_attachments()
 150:         else:
 151:             return self._scan_sent_emails_with_attachments()
 152:     
 153:     def _scan_sent_emails_with_attachments(self) -> dict:
 154:         """Scan sent emails for attachments"""
 155:         start_time = datetime.now()
 156:         email_attachments = []
 157:         
 158:         try:
 159:             # Create a new Outlook instance for this thread
 160:             import pythoncom
 161:             pythoncom.CoInitialize()
 162:             
 163:             # Create fresh Outlook connection for this scan
 164:             outlook_app = win32com.client.Dispatch("Outlook.Application")
 165:             namespace = outlook_app.GetNamespace("MAPI")
 166:             
 167:             # Get the Sent Items folder (5 = olFolderSentMail)
 168:             sent_folder = namespace.GetDefaultFolder(5)
 169:             messages = sent_folder.Items
 170:             
 171:             # Filter messages by date
 172:             start_date = datetime.now() - timedelta(weeks=self.weeks_back)
 173:             date_filter = f"[SentOn] >= '{start_date.strftime('%m/%d/%Y %H:%M %p')}'"
 174:             messages = messages.Restrict(date_filter)
 175:             
 176:             total_scanned = 0
 177:             total_emails_with_attachments = 0
 178:             
 179:             for message in messages:
 180:                 total_scanned += 1
 181:                 try:
 182:                     if message.Attachments.Count > 0:
 183:                         total_emails_with_attachments += 1
 184:                         
 185:                         # Get recipients
 186:                         recipients = []
 187:                         for i in range(1, message.Recipients.Count + 1):
 188:                             try:
 189:                                 recipient = message.Recipients.Item(i)
 190:                                 recipients.append(recipient.Name)
 191:                             except:
 192:                                 pass
 193:                         to_string = "; ".join(recipients) if recipients else "Unknown"
 194:                         
 195:                         # Create one entry per attachment
 196:                         for i in range(1, message.Attachments.Count + 1):
 197:                             try:
 198:                                 attachment = message.Attachments.Item(i)
 199:                                 attachment_name = attachment.FileName
 200:                                 
 201:                                 # Get file extension
 202:                                 if '.' in attachment_name:
 203:                                     extension = attachment_name.rsplit('.', 1)[1].upper()
 204:                                 else:
 205:                                     extension = 'NONE'
 206:                                 
 207:                                 # Try to get size
 208:                                 try:
 209:                                     attachment_size = attachment.Size
 210:                                 except:
 211:                                     attachment_size = 0
 212:                                 
 213:                                 attachment_data = {
 214:                                     'Date': message.SentOn.strftime("%Y-%m-%d %H:%M"),
 215:                                     'To': to_string,  # Changed from 'From' to 'To'
 216:                                     'Subject': message.Subject,
 217:                                     'AttachmentName': attachment_name,
 218:                                     'Extension': extension,
 219:                                     'Size': attachment_size,
 220:                                     'SizeFormatted': self._format_size(attachment_size) if attachment_size > 0 else "Unknown",
 221:                                     'EntryID': message.EntryID,
 222:                                     'AttachmentIndex': i,
 223:                                     'SentOn': message.SentOn.isoformat(),
 224:                                 }
 225:                                 email_attachments.append(attachment_data)
 226:                                 
 227:                             except Exception as e:
 228:                                 print(f"Error processing attachment {i}: {e}")
 229:                                 # Still add an entry for failed attachments
 230:                                 attachment_data = {
 231:                                     'Date': message.SentOn.strftime("%Y-%m-%d %H:%M"),
 232:                                     'To': to_string,
 233:                                     'Subject': message.Subject,
 234:                                     'AttachmentName': "(Error reading attachment)",
 235:                                     'Extension': 'ERROR',
 236:                                     'Size': 0,
 237:                                     'SizeFormatted': "Error",
 238:                                     'EntryID': message.EntryID,
 239:                                     'AttachmentIndex': i,
 240:                                     'SentOn': message.SentOn.isoformat(),
 241:                                 }
 242:                                 email_attachments.append(attachment_data)
 243:                                 
 244:                 except Exception as e:
 245:                     print(f"Error processing message: {e}")
 246:                     continue
 247:             
 248:             # Sort by date, newest first
 249:             email_attachments.sort(key=lambda x: x['SentOn'], reverse=True)
 250:             
 251:             # Prepare metadata
 252:             metadata = {
 253:                 'scan_type': self.SCAN_ATTACHMENTS_SENT,
 254:                 'weeks_back': self.weeks_back,
 255:                 'start_date': start_date.isoformat(),
 256:                 'end_date': datetime.now().isoformat(),
 257:                 'total_scanned': total_scanned,
 258:                 'total_emails_with_attachments': total_emails_with_attachments,
 259:                 'total_attachment_lines': len(email_attachments),
 260:                 'scan_duration': (datetime.now() - start_time).total_seconds()
 261:             }
 262:             
 263:             # Save to cache
 264:             self.cache.save_scan(self.SCAN_ATTACHMENTS_SENT, email_attachments, metadata)
 265:             
 266:             return {
 267:                 'data': email_attachments,
 268:                 'metadata': metadata,
 269:                 'from_cache': False
 270:             }
 271:         
 272:         except Exception as e:
 273:             print(f"Error retrieving sent emails: {e}")
 274:             return {'data': [], 'metadata': {}, 'from_cache': False}
 275:             
 276:         finally:
 277:             # Uninitialize COM for this thread
 278:             try:
 279:                 pythoncom.CoUninitialize()
 280:             except:
 281:                 pass
 282:     
 283:     def _scan_emails_with_attachments(self) -> dict:
 284:         """Perform a fresh scan for emails with attachments - one line per attachment"""
 285:         
 286:         start_time = datetime.now()
 287:         email_attachments = []
 288:         
 289:         try:
 290:             # Create a new Outlook instance for this thread
 291:             import pythoncom
 292:             pythoncom.CoInitialize()
 293:             
 294:             # Create fresh Outlook connection for this scan
 295:             outlook_app = win32com.client.Dispatch("Outlook.Application")
 296:             namespace = outlook_app.GetNamespace("MAPI")
 297:             
 298:             # Try to get the default inbox
 299:             inbox = namespace.GetDefaultFolder(6)  # 6 = olFolderInbox
 300:             messages = inbox.Items
 301:             
 302:             # Filter messages by date
 303:             start_date = datetime.now() - timedelta(weeks=self.weeks_back)
 304:             date_filter = f"[ReceivedTime] >= '{start_date.strftime('%m/%d/%Y %H:%M %p')}'"
 305:             messages = messages.Restrict(date_filter)
 306:             
 307:             total_scanned = 0
 308:             total_emails_with_attachments = 0
 309:             
 310:             for message in messages:
 311:                 total_scanned += 1
 312:                 try:
 313:                     if message.Attachments.Count > 0:
 314:                         total_emails_with_attachments += 1
 315:                         
 316:                         # Create one entry per attachment
 317:                         for i in range(1, message.Attachments.Count + 1):
 318:                             try:
 319:                                 attachment = message.Attachments.Item(i)
 320:                                 attachment_name = attachment.FileName
 321:                                 
 322:                                 # Get file extension
 323:                                 if '.' in attachment_name:
 324:                                     extension = attachment_name.rsplit('.', 1)[1].upper()
 325:                                 else:
 326:                                     extension = 'NONE'
 327:                                 
 328:                                 # Try to get size
 329:                                 try:
 330:                                     attachment_size = attachment.Size
 331:                                 except:
 332:                                     attachment_size = 0
 333:                                 
 334:                                 attachment_data = {
 335:                                     'Date': message.ReceivedTime.strftime("%Y-%m-%d %H:%M"),
 336:                                     'From': message.SenderName,
 337:                                     'Subject': message.Subject,
 338:                                     'AttachmentName': attachment_name,
 339:                                     'Extension': extension,
 340:                                     'Size': attachment_size,
 341:                                     'SizeFormatted': self._format_size(attachment_size) if attachment_size > 0 else "Unknown",
 342:                                     'EntryID': message.EntryID,
 343:                                     'AttachmentIndex': i,
 344:                                     'ReceivedTime': message.ReceivedTime.isoformat(),
 345:                                 }
 346:                                 email_attachments.append(attachment_data)
 347:                                 
 348:                             except Exception as e:
 349:                                 print(f"Error processing attachment {i}: {e}")
 350:                                 # Still add an entry for failed attachments
 351:                                 attachment_data = {
 352:                                     'Date': message.ReceivedTime.strftime("%Y-%m-%d %H:%M"),
 353:                                     'From': message.SenderName,
 354:                                     'Subject': message.Subject,
 355:                                     'AttachmentName': "(Error reading attachment)",
 356:                                     'Extension': 'ERROR',
 357:                                     'Size': 0,
 358:                                     'SizeFormatted': "Error",
 359:                                     'EntryID': message.EntryID,
 360:                                     'AttachmentIndex': i,
 361:                                     'ReceivedTime': message.ReceivedTime.isoformat(),
 362:                                 }
 363:                                 email_attachments.append(attachment_data)
 364:                                 
 365:                 except Exception as e:
 366:                     print(f"Error processing message: {e}")
 367:                     continue
 368:             
 369:             # Sort by date, newest first
 370:             email_attachments.sort(key=lambda x: x['ReceivedTime'], reverse=True)
 371:             
 372:             # Prepare metadata
 373:             metadata = {
 374:                 'scan_type': self.SCAN_ATTACHMENTS,
 375:                 'weeks_back': self.weeks_back,
 376:                 'start_date': start_date.isoformat(),
 377:                 'end_date': datetime.now().isoformat(),
 378:                 'total_scanned': total_scanned,
 379:                 'total_emails_with_attachments': total_emails_with_attachments,
 380:                 'total_attachment_lines': len(email_attachments),
 381:                 'scan_duration': (datetime.now() - start_time).total_seconds()
 382:             }
 383:             
 384:             # Save to cache
 385:             self.cache.save_scan(self.SCAN_ATTACHMENTS, email_attachments, metadata)
 386:             
 387:             return {
 388:                 'data': email_attachments,
 389:                 'metadata': metadata,
 390:                 'from_cache': False
 391:             }
 392:         
 393:         except Exception as e:
 394:             print(f"Error retrieving emails: {e}")
 395:             return {'data': [], 'metadata': {}, 'from_cache': False}
 396:             
 397:         finally:
 398:             # Uninitialize COM for this thread
 399:             try:
 400:                 pythoncom.CoUninitialize()
 401:             except:
 402:                 pass
 403:     
 404:     def open_attachment(self, entry_id: str, attachment_index: int):
 405:         """Open a specific attachment from an email"""
 406:         if not self.outlook:
 407:             self._initialize_outlook()
 408:             
 409:         if not self.outlook:
 410:             print("Cannot connect to Outlook")
 411:             return
 412:         
 413:         try:
 414:             import tempfile
 415:             import os
 416:             
 417:             outlook_app = win32com.client.Dispatch("Outlook.Application")
 418:             mail_item = outlook_app.Session.GetItemFromID(entry_id)
 419:             
 420:             if attachment_index <= mail_item.Attachments.Count:
 421:                 attachment = mail_item.Attachments.Item(attachment_index)
 422:                 
 423:                 # Save attachment to temp directory
 424:                 temp_dir = tempfile.gettempdir()
 425:                 temp_path = os.path.join(temp_dir, attachment.FileName)
 426:                 attachment.SaveAsFile(temp_path)
 427:                 
 428:                 # Open the file
 429:                 os.startfile(temp_path)
 430:             else:
 431:                 print(f"Attachment index {attachment_index} not found")
 432:                 
 433:         except Exception as e:
 434:             print(f"Error opening attachment: {e}")
 435:     
 436:     def _format_size(self, size_bytes: int) -> str:
 437:         """Format file size in human readable format"""
 438:         if size_bytes == 0:
 439:             return "0 B"
 440:         
 441:         size_names = ["B", "KB", "MB", "GB"]
 442:         i = 0
 443:         size = float(size_bytes)
 444:         
 445:         while size >= 1024.0 and i < len(size_names) - 1:
 446:             size /= 1024.0
 447:             i += 1
 448:         
 449:         if i == 0:
 450:             return f"{int(size)} {size_names[i]}"
 451:         else:
 452:             return f"{size:.1f} {size_names[i]}"
 453:     
 454:     def open_email(self, entry_id: str):
 455:         """Open a specific email in Outlook"""
 456:         if not self.outlook:
 457:             return
 458:         
 459:         try:
 460:             outlook_app = win32com.client.Dispatch("Outlook.Application")
 461:             mail_item = outlook_app.Session.GetItemFromID(entry_id)
 462:             mail_item.Display()
 463:         except Exception as e:
 464:             print(f"Error opening email: {e}")
 465:     
 466:     def clear_cache(self, scan_type: str | None = None):
 467:         """Clear email cache"""
 468:         self.cache.clear_cache(scan_type)
 469:     
 470:     def get_cache_info(self, scan_type: str) -> dict | None:
 471:         """Get information about cached data"""
 472:         cached_data = self.cache.load_scan(scan_type)
 473:         if not cached_data:
 474:             return None
 475:         
 476:         return {
 477:             'cached_at': cached_data['cached_at'],
 478:             'item_count': len(cached_data['data']),
 479:             'metadata': cached_data['metadata']
 480:         }

────────────────────────────────────────────────────────────────────────────────
FILE: email_menu.py
────────────────────────────────────────────────────────────────────────────────
Path: email_menu.py
Size: 18.2 KB
Lines: 436 total, 364 non-empty
Characters: 18,193
Type: Email menu UI and interactions
────────────────────────────────────────────────────────────────────────────────

   1: # email_menu.py
   2: """
   3: Updated email attachments menu with support for both received and sent emails
   4: """
   5: 
   6: import tkinter as tk
   7: from simple_window_factory import SimpleWindow, create_inventory_window
   8: from email_manager import EmailManager
   9: from ui_components import CustomDialog, WarningDialog
  10: from config import Colors, Fonts, Dimensions
  11: import threading
  12: 
  13: class EmailAttachmentsMenu:
  14:     """Enhanced email attachments menu with caching and support for sent/received"""
  15:     
  16:     def __init__(self, parent_window):
  17:         """Initialize the email attachments menu"""
  18:         self.parent = parent_window
  19:         self.email_manager = EmailManager(weeks_back=8)
  20:         self.inventory_window = None
  21:         self.loading_dialog = None
  22:     
  23:     def show_email_attachments(self, force_refresh: bool = False, email_type: str = 'received'):
  24:         """
  25:         Display the email attachments in an inventory view window
  26:         
  27:         Args:
  28:             force_refresh: Force a fresh scan
  29:             email_type: 'received' or 'sent'
  30:         """
  31:         # Check if we need to do a fresh scan
  32:         scan_type = EmailManager.SCAN_ATTACHMENTS if email_type == 'received' else EmailManager.SCAN_ATTACHMENTS_SENT
  33:         cache_exists = self.email_manager.get_cache_info(scan_type) is not None
  34:         needs_fresh_scan = force_refresh or not cache_exists or not self.email_manager.cache.is_cache_valid(scan_type)
  35:         
  36:         if needs_fresh_scan:
  37:             # Show loading indicator and scan in background
  38:             self.show_loading_dialog(email_type)
  39:             
  40:             scan_thread = threading.Thread(
  41:                 target=self._perform_scan,
  42:                 args=(email_type,),
  43:                 daemon=True
  44:             )
  45:             scan_thread.start()
  46:         else:
  47:             # Use cached data directly
  48:             result = self.email_manager.get_emails_with_attachments(
  49:                 use_cache=True, 
  50:                 force_refresh=False,
  51:                 email_type=email_type
  52:             )
  53:             self._display_emails_from_result(result, email_type)
  54:     
  55:     def _perform_scan(self, email_type: str):
  56:         """Perform email scan in background thread"""
  57:         result = self.email_manager.get_emails_with_attachments(
  58:             use_cache=False,
  59:             force_refresh=True,
  60:             email_type=email_type
  61:         )
  62:         
  63:         if self.loading_dialog:
  64:             self.loading_dialog.after(0, lambda: self._scan_complete(result, email_type))
  65:     
  66:     def _scan_complete(self, result: dict, email_type: str):
  67:         """Handle scan completion"""
  68:         # Close loading dialog
  69:         if self.loading_dialog:
  70:             self.loading_dialog.destroy()
  71:             self.loading_dialog = None
  72:         
  73:         # Display results
  74:         self._display_emails_from_result(result, email_type)
  75:     
  76:     def _display_emails_from_result(self, result: dict, email_type: str):
  77:         """Display emails from scan result"""
  78:         attachments = result['data']
  79:         metadata = result.get('metadata', {})
  80:         from_cache = result.get('from_cache', False)
  81:         
  82:         if not attachments:
  83:             self._show_no_emails_message(email_type)
  84:             return
  85:         
  86:         # Prepare additional info
  87:         additional_info = {
  88:             'Period': f"Last {metadata.get('weeks_back', 2)} weeks",
  89:             'Total Emails': metadata.get('total_emails_with_attachments', 'Unknown'),
  90:             'Total Attachments': len(attachments),
  91:             'Source': 'Cached' if from_cache else 'Fresh Scan',
  92:             'Type': 'Sent' if email_type == 'sent' else 'Received'
  93:         }
  94:         
  95:         if from_cache and 'cached_at' in result:
  96:             cached_time = result['cached_at'].strftime('%Y-%m-%d %H:%M')
  97:             additional_info['Cached At'] = cached_time
  98:         
  99:         if 'scan_duration' in metadata and not from_cache:
 100:             additional_info['Scan Time'] = f"{metadata['scan_duration']:.1f}s"
 101:         
 102:         # Configure columns based on email type
 103:         if email_type == 'sent':
 104:             columns = [
 105:                 {'key': 'Date', 'header': 'Date', 'width': 120, 'type': 'date'},
 106:                 {'key': 'To', 'header': 'To', 'width': 180, 'type': 'text'},
 107:                 {'key': 'Subject', 'header': 'Subject', 'width': 300, 'type': 'text'},
 108:                 {'key': 'AttachmentName', 'header': 'Attachment', 'width': 250, 'type': 'text'},
 109:                 {'key': 'Extension', 'header': 'Type', 'width': 60, 'type': 'text'},
 110:                 {'key': 'SizeFormatted', 'header': 'Size', 'width': 80, 'type': 'text'}
 111:             ]
 112:             title = 'Sent Email Attachments'
 113:         else:
 114:             columns = [
 115:                 {'key': 'Date', 'header': 'Date', 'width': 120, 'type': 'date'},
 116:                 {'key': 'From', 'header': 'From', 'width': 180, 'type': 'text'},
 117:                 {'key': 'Subject', 'header': 'Subject', 'width': 300, 'type': 'text'},
 118:                 {'key': 'AttachmentName', 'header': 'Attachment', 'width': 250, 'type': 'text'},
 119:                 {'key': 'Extension', 'header': 'Type', 'width': 60, 'type': 'text'},
 120:                 {'key': 'SizeFormatted', 'header': 'Size', 'width': 80, 'type': 'text'}
 121:             ]
 122:             title = 'Received Email Attachments'
 123:         
 124:         # Configure the inventory view window
 125:         window_config = {
 126:             'title': title,
 127:             'columns': columns,
 128:             'on_item_click': self._handle_item_click,
 129:             'on_item_double_click': self._open_email,
 130:             'show_stats': True,
 131:             'allow_export': True,
 132:             'window_width': 1200,
 133:             'window_height': 600,
 134:             'additional_info': additional_info
 135:         }
 136:         
 137:         # Create custom inventory window with refresh button
 138:         self.inventory_window = EmailInventoryWindow(
 139:             self.parent, 
 140:             attachments, 
 141:             window_config,
 142:             lambda: self.refresh_emails(email_type),
 143:             lambda: self.full_refresh_emails(email_type),
 144:             email_type
 145:         )
 146:     
 147:     def _handle_item_click(self, item: dict, column_key: str = None):
 148:         """Handle clicks on specific columns"""
 149:         if not column_key:
 150:             return
 151:             
 152:         if column_key == 'Subject':
 153:             # Open the email
 154:             self._open_email(item)
 155:         elif column_key == 'AttachmentName':
 156:             # Open the attachment
 157:             self._open_attachment(item)
 158:     
 159:     def _open_attachment(self, attachment_data: dict):
 160:         """Handle click on attachment to open it"""
 161:         if 'EntryID' in attachment_data and 'AttachmentIndex' in attachment_data:
 162:             self.email_manager.open_attachment(
 163:                 attachment_data['EntryID'], 
 164:                 attachment_data['AttachmentIndex']
 165:             )
 166: 
 167:     def refresh_emails(self, email_type: str):
 168:         """Quick refresh - check for new emails only"""
 169:         if self.inventory_window and hasattr(self.inventory_window, 'show_refreshing'):
 170:             self.inventory_window.show_refreshing()
 171:         
 172:         # For now, just do a full refresh
 173:         # Could be optimized later to only check recent emails
 174:         thread = threading.Thread(
 175:             target=self._perform_quick_refresh,
 176:             args=(email_type,),
 177:             daemon=True
 178:         )
 179:         thread.start()
 180:     
 181:     def _perform_quick_refresh(self, email_type: str):
 182:         """Perform quick refresh in background"""
 183:         result = self.email_manager.get_emails_with_attachments(
 184:             use_cache=False,
 185:             force_refresh=True,
 186:             email_type=email_type
 187:         )
 188:         
 189:         if self.inventory_window:
 190:             self.inventory_window.after(0, lambda: self._update_inventory(result))
 191:     
 192:     def full_refresh_emails(self, email_type: str):
 193:         """Full refresh - rescan all emails"""
 194:         if self.inventory_window:
 195:             self.inventory_window.destroy()
 196:         self.show_email_attachments(force_refresh=True, email_type=email_type)
 197:     
 198:     def _update_inventory(self, result: dict):
 199:         """Update inventory window with new data"""
 200:         if self.inventory_window and self.inventory_window.winfo_exists():
 201:             # Update the data
 202:             self.inventory_window.original_data = result['data']
 203:             self.inventory_window.filtered_data = result['data']
 204:             self.inventory_window.populate_grid()
 205:             self.inventory_window.update_stats()
 206:             
 207:             # Show refresh complete message
 208:             self.inventory_window.show_refresh_complete("Refresh complete")
 209:     
 210:     def _open_email(self, email_data: dict):
 211:         """Handle double-click on email item to open it"""
 212:         if 'EntryID' in email_data:
 213:             self.email_manager.open_email(email_data['EntryID'])
 214:     
 215:     def _show_no_emails_message(self, email_type: str):
 216:         """Show a message when no emails with attachments are found"""
 217:         email_type_text = "sent" if email_type == 'sent' else "received"
 218:         WarningDialog.show(
 219:             self.parent,
 220:             "No Emails Found",
 221:             f"No {email_type_text} emails with attachments found in the last {self.email_manager.weeks_back} weeks."
 222:         )
 223:     
 224:     def show_loading_dialog(self, email_type: str):
 225:         """Show loading dialog during email scan"""
 226:         email_type_text = "sent" if email_type == 'sent' else "received"
 227:         self.loading_dialog = LoadingDialog(self.parent, f"Scanning {email_type_text} emails...")
 228: 
 229: 
 230: class EmailInventoryWindow(SimpleWindow):
 231:     """Extended inventory window with refresh capabilities using SimpleWindow"""
 232:     
 233:     def __init__(self, parent, data, config, quick_refresh_callback, full_refresh_callback, email_type):
 234:         self.quick_refresh_callback = quick_refresh_callback
 235:         self.full_refresh_callback = full_refresh_callback
 236:         self.email_type = email_type
 237:         self.original_data = data
 238:         self.filtered_data = data
 239:         self.config = config
 240:         
 241:         # Initialize SimpleWindow
 242:         super().__init__(parent, config.get('title', 'Email Attachments'))
 243:         
 244:         # Set window size
 245:         window_width = config.get('window_width', 1200)
 246:         window_height = config.get('window_height', 600)
 247:         self.geometry(f"{window_width}x{window_height}")
 248:         
 249:         # Create the inventory view
 250:         self._create_inventory_view()
 251:         
 252:         # Show the window
 253:         self.lift()
 254:         self.focus_force()
 255:     
 256:     def _create_inventory_view(self):
 257:         """Create the embedded inventory view"""
 258:         # Create inventory view in the content frame
 259:         self.inventory_view = create_inventory_view(
 260:             self.content_frame,
 261:             self.original_data,
 262:             self.config
 263:         )
 264:         
 265:         # Pack the inventory view (it returns a frame)
 266:         self.inventory_view.pack(fill=tk.BOTH, expand=True)
 267:         
 268:         # Add custom footer with refresh buttons
 269:         self._create_footer()
 270:         
 271:         # Store references for updates
 272:         self.treeview = None
 273:         self.filter_status_label = None
 274:         self.refresh_status_label = None
 275:         
 276:         # Find the treeview widget for updates
 277:         self._find_treeview_widget()
 278:     
 279:     def _find_treeview_widget(self):
 280:         """Find the treeview widget in the inventory view"""
 281:         def find_treeview(widget):
 282:             if hasattr(widget, 'winfo_class') and widget.winfo_class() == 'Treeview':
 283:                 return widget
 284:             for child in widget.winfo_children():
 285:                 result = find_treeview(child)
 286:                 if result:
 287:                     return result
 288:             return None
 289:         
 290:         self.treeview = find_treeview(self.inventory_view)
 291:     
 292:     def _create_footer(self):
 293:         """Create footer with refresh buttons"""
 294:         footer_frame = tk.Frame(self.content_frame, bg=Colors.DARK_GREEN, height=50)
 295:         footer_frame.pack(fill=tk.X, side=tk.BOTTOM, padx=2, pady=2)
 296:         footer_frame.pack_propagate(False)
 297:         
 298:         # Left side - filter status and refresh status
 299:         left_frame = tk.Frame(footer_frame, bg=Colors.DARK_GREEN)
 300:         left_frame.pack(side=tk.LEFT, fill=tk.Y)
 301:         
 302:         self.filter_status_label = tk.Label(left_frame, text="No filters applied", 
 303:                                            bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 304:                                            font=Fonts.MENU_ITEM)
 305:         self.filter_status_label.pack(side=tk.LEFT, padx=10, pady=5)
 306:         
 307:         # Refresh status label
 308:         self.refresh_status_label = tk.Label(left_frame, text="", 
 309:                                            bg=Colors.DARK_GREEN, fg=Colors.LIGHT_GREEN,
 310:                                            font=Fonts.MENU_ITEM)
 311:         self.refresh_status_label.pack(side=tk.LEFT, padx=10, pady=5)
 312:         
 313:         # Right side - action buttons
 314:         button_frame = tk.Frame(footer_frame, bg=Colors.DARK_GREEN)
 315:         button_frame.pack(side=tk.RIGHT, fill=tk.Y)
 316:         
 317:         # Quick Refresh button
 318:         quick_refresh_btn = tk.Button(button_frame, text="↻ Quick Refresh", 
 319:                                      bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 320:                                      relief=tk.RAISED, bd=1, cursor='hand2',
 321:                                      font=Fonts.MENU_ITEM, padx=10,
 322:                                      command=self.quick_refresh_callback)
 323:         quick_refresh_btn.pack(side=tk.LEFT, padx=5, pady=5)
 324:         
 325:         # Full Refresh button
 326:         full_refresh_btn = tk.Button(button_frame, text="⟳ Full Refresh", 
 327:                                     bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 328:                                     relief=tk.RAISED, bd=1, cursor='hand2',
 329:                                     font=Fonts.MENU_ITEM, padx=10,
 330:                                     command=self.full_refresh_callback)
 331:         full_refresh_btn.pack(side=tk.LEFT, padx=5, pady=5)
 332:         
 333:         # Clear Filters button
 334:         clear_btn = tk.Button(button_frame, text="Clear All Filters", 
 335:                              bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 336:                              relief=tk.RAISED, bd=1, cursor='hand2',
 337:                              font=Fonts.MENU_ITEM, padx=10,
 338:                              command=self.clear_all_filters)
 339:         clear_btn.pack(side=tk.LEFT, padx=5, pady=5)
 340:         
 341:         # Export to Excel
 342:         if self.config.get('allow_export', False):
 343:             export_btn = tk.Button(button_frame, text="Export to Excel", 
 344:                                   bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 345:                                   relief=tk.RAISED, bd=1, cursor='hand2',
 346:                                   font=Fonts.MENU_ITEM, padx=10,
 347:                                   command=self.export_to_excel)
 348:             export_btn.pack(side=tk.LEFT, padx=5, pady=5)
 349:         
 350:         # Close button
 351:         close_btn = tk.Button(button_frame, text="Close", 
 352:                              bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 353:                              relief=tk.RAISED, bd=1, cursor='hand2',
 354:                              font=Fonts.MENU_ITEM, padx=10,
 355:                              command=self.close_window)
 356:         close_btn.pack(side=tk.LEFT, padx=5, pady=5)
 357:     
 358:     def show_refreshing(self):
 359:         """Show refreshing status"""
 360:         if self.refresh_status_label:
 361:             self.refresh_status_label.config(text="Refreshing...")
 362:     
 363:     def show_refresh_complete(self, message: str):
 364:         """Show refresh complete status"""
 365:         if self.refresh_status_label:
 366:             self.refresh_status_label.config(text=message)
 367:             # Clear message after 3 seconds
 368:             self.after(3000, lambda: self.refresh_status_label.config(text=""))
 369:     
 370:     def populate_grid(self):
 371:         """Populate the grid with current data"""
 372:         if self.treeview:
 373:             # Clear existing items
 374:             for item in self.treeview.get_children():
 375:                 self.treeview.delete(item)
 376:             
 377:             # Add new items
 378:             for item in self.filtered_data:
 379:                 values = []
 380:                 for col in self.config.get('columns', []):
 381:                     values.append(str(item.get(col['key'], '')))
 382:                 self.treeview.insert('', 'end', values=values)
 383:     
 384:     def update_stats(self):
 385:         """Update statistics display"""
 386:         # This would update any stats display - for now just pass
 387:         pass
 388:     
 389:     def clear_all_filters(self):
 390:         """Clear all applied filters"""
 391:         self.filtered_data = self.original_data.copy()
 392:         self.populate_grid()
 393:         if self.filter_status_label:
 394:             self.filter_status_label.config(text="No filters applied")
 395:     
 396:     def export_to_excel(self):
 397:         """Export current data to Excel"""
 398:         # Import here to avoid circular imports
 399:         from utils import export_to_excel
 400:         if self.filtered_data:
 401:             export_to_excel(self.filtered_data, f"{self.email_type}_email_attachments")
 402: 
 403: 
 404: class LoadingDialog(CustomDialog):
 405:     """Simple loading dialog"""
 406:     
 407:     def __init__(self, parent, message="Loading..."):
 408:         super().__init__(parent, "Please Wait", width=300, height=150)
 409:         
 410:         # Loading message
 411:         msg_label = tk.Label(self.dialog_content, text=message,
 412:                            bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 413:                            font=Fonts.DIALOG_LABEL)
 414:         msg_label.pack(pady=20)
 415:         
 416:         # Progress indicator (simple animation)
 417:         self.progress_label = tk.Label(self.dialog_content, text="⏳",
 418:                                      bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 419:                                      font=('Arial', 24))
 420:         self.progress_label.pack(pady=10)
 421:         
 422:         # Remove button frame
 423:         self.button_frame.pack_forget()
 424:         
 425:         # Start animation
 426:         self.animate_progress()
 427:     
 428:     def animate_progress(self):
 429:         """Simple progress animation"""
 430:         current = self.progress_label.cget("text")
 431:         if current == "⏳":
 432:             self.progress_label.config(text="⌛")
 433:         else:
 434:             self.progress_label.config(text="⏳")
 435:         
 436:         self.after(500, self.animate_progress)

────────────────────────────────────────────────────────────────────────────────
FILE: email_options_menu.py
────────────────────────────────────────────────────────────────────────────────
Path: email_options_menu.py
Size: 6.9 KB
Lines: 186 total, 150 non-empty
Characters: 6,855
Type: Email options and configuration menu
────────────────────────────────────────────────────────────────────────────────

   1: # email_options_menu.py
   2: """
   3: Email options popup menu for SuiteView Taskbar
   4: Updated to use SimpleWindow from simple_window_factory
   5: """
   6: 
   7: import tkinter as tk
   8: from simple_window_factory import SimpleWindow
   9: from config import Colors, Fonts
  10: from email_menu import EmailAttachmentsMenu
  11: 
  12: class EmailOptionsMenu(SimpleWindow):
  13:     """Popup menu for email options"""
  14: 
  15:     def __init__(self, parent, button, taskbar_instance):
  16:         """
  17:         Initialize email options menu
  18:         
  19:         Args:
  20:             parent: Parent window
  21:             button: The button that triggered this menu
  22:             taskbar_instance: Reference to the main taskbar
  23:         """
  24:         self.taskbar_instance = taskbar_instance
  25:         self.button = button
  26:         
  27:         # Initialize with no resize handles for menu
  28:         super().__init__(parent, "Email Options", resize_handles=None)
  29:         
  30:         # Position near button
  31:         self._position_near_button()
  32:         
  33:         # Set transparency
  34:         self.attributes('-alpha', 0.98)
  35:         
  36:         # Track mouse over menu for hover effects
  37:         self.bind("<Enter>", lambda e: setattr(self, 'mouse_over_menu', True))
  38:         self.bind("<Leave>", lambda e: setattr(self, 'mouse_over_menu', False))
  39:         self.mouse_over_menu = False
  40:         
  41:         # Create the menu content
  42:         self._create_menu_content()
  43:         
  44:         # Enable click-outside detection
  45:         self._setup_click_outside_detection()
  46:     
  47:     def _position_near_button(self):
  48:         """Position menu near the button that triggered it"""
  49:         if self.button:
  50:             # Get button position
  51:             button_x = self.button.winfo_rootx()
  52:             button_y = self.button.winfo_rooty()
  53:             button_height = self.button.winfo_height()
  54:             
  55:             # Position menu below button
  56:             self.geometry(f"+{button_x}+{button_y + button_height + 5}")
  57:     
  58:     def _create_menu_content(self):
  59:         """Create the menu content"""
  60:         # Override the light green background with dark green for menu style
  61:         self.content_frame.configure(bg=Colors.DARK_GREEN)
  62:         
  63:         # Menu items container with light background
  64:         items_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
  65:         items_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
  66:         
  67:         # Attachments Received option
  68:         received_item = self._create_menu_item(
  69:             items_frame, 
  70:             "📥",
  71:             "Attachments Received", 
  72:             self.show_received_attachments
  73:         )
  74:         received_item.pack(fill=tk.X, padx=2, pady=1)
  75:         
  76:         # Attachments Sent option
  77:         sent_item = self._create_menu_item(
  78:             items_frame, 
  79:             "📤",
  80:             "Attachments Sent", 
  81:             self.show_sent_attachments
  82:         )
  83:         sent_item.pack(fill=tk.X, padx=2, pady=1)
  84:         
  85:         # Update window size after content is created
  86:         self.update_idletasks()
  87:         width = max(250, self.winfo_reqwidth())
  88:         self.geometry(f"{width}x{self.winfo_reqheight()}")
  89:     
  90:     def _create_menu_item(self, parent, icon, text, command):
  91:         """Create a single menu item with icon and text"""
  92:         item_frame = tk.Frame(parent, bg=Colors.LIGHT_GREEN, height=35)
  93:         item_frame.pack_propagate(False)
  94:         
  95:         # Large icon on the left
  96:         icon_label = tk.Label(item_frame, text=icon, bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
  97:                             font=('Arial', 18), width=2, anchor='center')
  98:         icon_label.pack(side=tk.LEFT, padx=(10, 5))
  99:         
 100:         # Text label
 101:         text_label = tk.Label(item_frame, text=text, bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 102:                             font=Fonts.MENU_ITEM, anchor='w')
 103:         text_label.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
 104:         
 105:         # Hover effect for the entire frame
 106:         def on_enter(e):
 107:             item_frame.configure(bg=Colors.HOVER_GREEN)
 108:             icon_label.configure(bg=Colors.HOVER_GREEN, fg=Colors.WHITE)
 109:             text_label.configure(bg=Colors.HOVER_GREEN, fg=Colors.WHITE)
 110:         
 111:         def on_leave(e):
 112:             item_frame.configure(bg=Colors.LIGHT_GREEN)
 113:             icon_label.configure(bg=Colors.LIGHT_GREEN, fg=Colors.BLACK)
 114:             text_label.configure(bg=Colors.LIGHT_GREEN, fg=Colors.BLACK)
 115:         
 116:         # Bind events to all components
 117:         for widget in [item_frame, icon_label, text_label]:
 118:             widget.bind("<Enter>", on_enter)
 119:             widget.bind("<Leave>", on_leave)
 120:             widget.bind("<Button-1>", lambda e: self._execute_command(command))
 121:             widget.configure(cursor='hand2')
 122:         
 123:         return item_frame
 124:     
 125:     def _setup_click_outside_detection(self):
 126:         """Set up detection for clicks outside the menu"""
 127:         # Bind to all windows to detect clicks anywhere
 128:         self.bind_all("<Button-1>", self._check_click_outside, "+")
 129:         
 130:     def _check_click_outside(self, event):
 131:         """Check if click was outside the menu"""
 132:         try:
 133:             # Get the widget that was clicked
 134:             clicked_widget = event.widget
 135:             
 136:             # Check if the clicked widget is part of this menu
 137:             widget = clicked_widget
 138:             while widget:
 139:                 if widget == self:
 140:                     # Click was inside the menu
 141:                     return
 142:                 widget = widget.master
 143:             
 144:             # Click was outside - close the menu
 145:             self.close_window()
 146:         except:
 147:             pass
 148:     
 149:     def _execute_command(self, command):
 150:         """Execute menu command and close menu"""
 151:         # Close menu first
 152:         self.close_window()
 153:         # Then execute command
 154:         command()
 155:     
 156:     def show_received_attachments(self):
 157:         """Show received email attachments"""
 158:         # Get the taskbar instance
 159:         taskbar = self.taskbar_instance
 160:             
 161:         if not hasattr(taskbar, 'email_menu'):
 162:             taskbar.email_menu = EmailAttachmentsMenu(taskbar.root)
 163:         
 164:         # Show received attachments (default behavior)
 165:         taskbar.email_menu.show_email_attachments(email_type='received')
 166:     
 167:     def show_sent_attachments(self):
 168:         """Show sent email attachments"""
 169:         # Get the taskbar instance
 170:         taskbar = self.taskbar_instance
 171:             
 172:         if not hasattr(taskbar, 'email_menu'):
 173:             taskbar.email_menu = EmailAttachmentsMenu(taskbar.root)
 174:         
 175:         # Show sent attachments
 176:         taskbar.email_menu.show_email_attachments(email_type='sent')
 177:     
 178:     def close_window(self):
 179:         """Override to clean up bindings before closing"""
 180:         try:
 181:             # Unbind the click detection
 182:             self.unbind_all("<Button-1>")
 183:         except:
 184:             pass
 185:         # Call parent close method
 186:         super().close_window()

────────────────────────────────────────────────────────────────────────────────
FILE: explorer_utils.py
────────────────────────────────────────────────────────────────────────────────
Path: explorer_utils.py
Size: 8.9 KB
Lines: 226 total, 183 non-empty
Characters: 8,916
Type: File explorer utilities and helpers
────────────────────────────────────────────────────────────────────────────────

   1: # explorer_utils.py
   2: """
   3: Utility functions for detecting and interacting with File Explorer windows
   4: """
   5: 
   6: import win32gui
   7: import win32process
   8: import psutil
   9: from pathlib import Path
  10: import os
  11: 
  12: class ExplorerDetector:
  13:     """Utility class for detecting open File Explorer windows"""
  14:     
  15:     @staticmethod
  16:     def get_open_explorer_folders():
  17:         """
  18:         Get a list of currently open File Explorer folder paths
  19:         Returns list of folder paths, ordered by most recently active
  20:         """
  21:         explorer_folders = []
  22:         
  23:         def enum_window_callback(hwnd, folders_list):
  24:             """Callback function for window enumeration"""
  25:             try:
  26:                 # Check if window is visible
  27:                 if not win32gui.IsWindowVisible(hwnd):
  28:                     return True
  29:                 
  30:                 # Get window class name
  31:                 class_name = win32gui.GetClassName(hwnd)
  32:                 
  33:                 # Check if it's a File Explorer window
  34:                 if class_name in ['CabinetWClass', 'ExploreWClass']:
  35:                     # Get process information
  36:                     _, pid = win32process.GetWindowThreadProcessId(hwnd)
  37:                     
  38:                     try:
  39:                         process = psutil.Process(pid)
  40:                         if process.name().lower() == 'explorer.exe':
  41:                             # Try to get the folder path from the window
  42:                             folder_path = ExplorerDetector._get_explorer_path(hwnd)
  43:                             if folder_path and os.path.exists(folder_path):
  44:                                 folders_list.append({
  45:                                     'path': folder_path,
  46:                                     'hwnd': hwnd,
  47:                                     'title': win32gui.GetWindowText(hwnd)
  48:                                 })
  49:                     except (psutil.NoSuchProcess, psutil.AccessDenied):
  50:                         pass
  51:                         
  52:             except Exception as e:
  53:                 print(f"Error processing window {hwnd}: {e}")
  54:                 
  55:             return True
  56:         
  57:         # Enumerate all top-level windows
  58:         win32gui.EnumWindows(enum_window_callback, explorer_folders)
  59:         
  60:         # Sort by Z-order (topmost first) - approximate by hwnd order
  61:         # The most recently active windows typically have higher hwnd values
  62:         explorer_folders.sort(key=lambda x: x['hwnd'], reverse=True)
  63:         
  64:         return [folder['path'] for folder in explorer_folders]
  65:     
  66:     @staticmethod
  67:     def _get_explorer_path(hwnd):
  68:         """
  69:         Extract the current folder path from a File Explorer window
  70:         This uses the window title to determine the path
  71:         """
  72:         try:
  73:             window_title = win32gui.GetWindowText(hwnd)
  74:             
  75:             # File Explorer titles usually contain the folder name
  76:             # Try different approaches to extract the path
  77:             
  78:             # Method 1: Direct path in title (Windows 11 style)
  79:             normalized_title = os.path.normpath(window_title)
  80:             if os.path.exists(normalized_title):
  81:                 return normalized_title
  82:             
  83:             # Method 2: Parse common File Explorer title formats
  84:             # Remove common prefixes/suffixes
  85:             title_cleaned = window_title
  86:             
  87:             # Remove " - File Explorer" suffix if present
  88:             if title_cleaned.endswith(' - File Explorer'):
  89:                 title_cleaned = title_cleaned[:-15]
  90:             
  91:             # Remove " - Windows Explorer" suffix if present  
  92:             if title_cleaned.endswith(' - Windows Explorer'):
  93:                 title_cleaned = title_cleaned[:-18]
  94:             
  95:             # Normalize and check if cleaned title is a valid path
  96:             title_cleaned = os.path.normpath(title_cleaned)
  97:             if os.path.exists(title_cleaned):
  98:                 return title_cleaned
  99:             
 100:             # Method 3: Try to construct common paths
 101:             common_paths = [
 102:                 os.path.expanduser('~'),  # User home
 103:                 os.path.expanduser('~/Desktop'),
 104:                 os.path.expanduser('~/Documents'),
 105:                 os.path.expanduser('~/Downloads'),
 106:                 'C:\\',
 107:                 'D:\\',
 108:             ]
 109:             
 110:             for base_path in common_paths:
 111:                 potential_path = os.path.normpath(os.path.join(base_path, title_cleaned))
 112:                 if os.path.exists(potential_path):
 113:                     return potential_path
 114:             
 115:             # Method 4: Check if it's a special folder name
 116:             special_folders = {
 117:                 'Desktop': os.path.expanduser('~/Desktop'),
 118:                 'Documents': os.path.expanduser('~/Documents'),
 119:                 'Downloads': os.path.expanduser('~/Downloads'),
 120:                 'Pictures': os.path.expanduser('~/Pictures'),
 121:                 'Videos': os.path.expanduser('~/Videos'),
 122:                 'Music': os.path.expanduser('~/Music'),
 123:                 'This PC': os.path.expanduser('~'),
 124:                 'Computer': os.path.expanduser('~'),
 125:             }
 126:             
 127:             if title_cleaned in special_folders:
 128:                 return os.path.normpath(special_folders[title_cleaned])
 129:             
 130:             # Method 5: Advanced COM-based approach (fallback)
 131:             try:
 132:                 return ExplorerDetector._get_explorer_path_com(hwnd)
 133:             except:
 134:                 pass
 135:             
 136:             return None
 137:             
 138:         except Exception as e:
 139:             print(f"Error getting explorer path for window {hwnd}: {e}")
 140:             return None
 141:     
 142:     @staticmethod
 143:     def _get_explorer_path_com(hwnd):
 144:         """
 145:         Use COM interface to get the actual path from File Explorer
 146:         This is more reliable but also more complex
 147:         """
 148:         try:
 149:             import win32com.client
 150:             
 151:             # Get Shell Windows collection
 152:             shell_windows = win32com.client.Dispatch("Shell.Application").Windows()
 153:             
 154:             for window in shell_windows:
 155:                 try:
 156:                     # Check if this window matches our hwnd
 157:                     if hasattr(window, 'HWND') and window.HWND == hwnd:
 158:                         # Get the location URL and convert to path
 159:                         location = window.LocationURL
 160:                         if location.startswith('file:///'):
 161:                             # Convert file URL to local path
 162:                             import urllib.parse
 163:                             path = urllib.parse.unquote(location[8:])  # Remove 'file:///'
 164:                             path = path.replace('/', '\\')  # Convert to Windows path
 165:                             # Normalize the path to fix any mixed slash issues
 166:                             path = os.path.normpath(path)
 167:                             if os.path.exists(path):
 168:                                 return path
 169:                 except:
 170:                     continue
 171:                     
 172:         except Exception as e:
 173:             print(f"COM approach failed: {e}")
 174:             
 175:         return None
 176:     
 177:     @staticmethod
 178:     def get_topmost_explorer_folder():
 179:         """
 180:         Get the path of the topmost (most recently active) File Explorer folder
 181:         Returns None if no File Explorer windows are open
 182:         """
 183:         folders = ExplorerDetector.get_open_explorer_folders()
 184:         return folders[0] if folders else None
 185:     
 186:     @staticmethod
 187:     def get_best_default_folder():
 188:         """
 189:         Get the best folder to use as default for scanning
 190:         Priority: 1) Topmost Explorer folder, 2) User Documents, 3) User Home
 191:         All paths are normalized to use consistent backslashes
 192:         """
 193:         # Try to get topmost explorer folder first
 194:         explorer_folder = ExplorerDetector.get_topmost_explorer_folder()
 195:         if explorer_folder:
 196:             return os.path.normpath(explorer_folder)
 197:         
 198:         # Fallback to Documents folder
 199:         documents_folder = os.path.expanduser('~/Documents')
 200:         if os.path.exists(documents_folder):
 201:             return os.path.normpath(documents_folder)
 202:         
 203:         # Final fallback to user home
 204:         return os.path.normpath(os.path.expanduser('~'))
 205: 
 206: 
 207: # Test function for debugging
 208: def test_explorer_detection():
 209:     """Test function to see what Explorer windows are detected"""
 210:     print("Testing Explorer Detection...")
 211:     
 212:     folders = ExplorerDetector.get_open_explorer_folders()
 213:     print(f"Found {len(folders)} open File Explorer folders:")
 214:     
 215:     for i, folder in enumerate(folders, 1):
 216:         print(f"  {i}. {folder}")
 217:     
 218:     topmost = ExplorerDetector.get_topmost_explorer_folder()
 219:     print(f"\nTopmost folder: {topmost}")
 220:     
 221:     best_default = ExplorerDetector.get_best_default_folder()
 222:     print(f"Best default folder: {best_default}")
 223: 
 224: 
 225: if __name__ == "__main__":
 226:     test_explorer_detection()

────────────────────────────────────────────────────────────────────────────────
FILE: folder_inventory.py
────────────────────────────────────────────────────────────────────────────────
Path: folder_inventory.py
Size: 29.7 KB
Lines: 736 total, 593 non-empty
Characters: 29,713
Type: Folder inventory scanning and management
────────────────────────────────────────────────────────────────────────────────

   1: # folder_inventory.py
   2: """
   3: Folder Inventory feature for SuiteView Taskbar Application
   4: Provides dialog for configuration and tree view of folder contents
   5: """
   6: 
   7: import tkinter as tk
   8: from tkinter import ttk, messagebox, filedialog
   9: import os
  10: import subprocess
  11: import shutil
  12: from pathlib import Path
  13: from datetime import datetime
  14: import threading
  15: from simple_window_factory import SimpleWindow, InventoryViewWindow
  16: from config import Colors, Fonts
  17: from explorer_utils import ExplorerDetector
  18: 
  19: class FolderInventoryDialog(SimpleWindow):
  20:     """Dialog for configuring folder inventory scan using SimpleWindow"""
  21:     
  22:     def __init__(self, parent):
  23:         # Initialize SimpleWindow without resize handles
  24:         super().__init__(parent, "Folder Inventory", resize_handles=None)
  25:         
  26:         # Set background color to light green
  27:         self.content_frame.configure(bg=Colors.LIGHT_GREEN)
  28:         
  29:         # Set window size
  30:         self.geometry("500x350")
  31:         
  32:         # Center window
  33:         self.update_idletasks()
  34:         x = (self.winfo_screenwidth() - 500) // 2
  35:         y = (self.winfo_screenheight() - 350) // 2
  36:         self.geometry(f"500x350+{x}+{y}")
  37:         
  38:         # Set background color to light green
  39:         self.content_frame.configure(bg=Colors.LIGHT_GREEN)
  40:         
  41:         self.selected_folder = ""
  42:         self.scan_thread = None
  43:         self.cancel_scan = False
  44:         self.inventory_data = []
  45:         
  46:         self._create_content()
  47:         
  48:         # Auto-populate folder field
  49:         self.auto_populate_folder()
  50:         
  51:         # Set focus on folder field
  52:         self.folder_entry.focus_set()
  53:     
  54:     def _create_content(self):
  55:         """Create the dialog content"""
  56:         content = self.content_frame
  57:         
  58:         # Folder selection
  59:         folder_frame = tk.Frame(content, bg=Colors.LIGHT_GREEN)
  60:         folder_frame.pack(fill='x', padx=10, pady=(10, 0))
  61:         
  62:         tk.Label(folder_frame, text="Folder to scan:", 
  63:                 bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
  64:                 font=Fonts.DIALOG_LABEL).pack(anchor='w')
  65:         
  66:         folder_input_frame = tk.Frame(folder_frame, bg=Colors.LIGHT_GREEN)
  67:         folder_input_frame.pack(fill='x', pady=(5, 0))
  68:         
  69:         self.folder_var = tk.StringVar()
  70:         self.folder_entry = tk.Entry(folder_input_frame, textvariable=self.folder_var,
  71:                                     font=Fonts.DIALOG_LABEL, bg='white')
  72:         self.folder_entry.pack(side='left', fill='x', expand=True)
  73:         
  74:         browse_btn = tk.Button(folder_input_frame, text="Browse...", 
  75:                              command=self.browse_folder,
  76:                              bg=Colors.DARK_GREEN, fg='white',
  77:                              font=Fonts.BUTTON, relief='flat',
  78:                              cursor='hand2', padx=10)
  79:         browse_btn.pack(side='right', padx=(5, 0))
  80:         
  81:         # Scan depth option
  82:         depth_frame = tk.Frame(content, bg=Colors.LIGHT_GREEN)
  83:         depth_frame.pack(fill='x', padx=10, pady=(20, 0))
  84:         
  85:         tk.Label(depth_frame, text="Scan Depth:", 
  86:                 bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
  87:                 font=Fonts.DIALOG_LABEL).pack(anchor='w')
  88:         
  89:         self.depth_var = tk.IntVar(value=0)
  90:         
  91:         depth_options = tk.Frame(depth_frame, bg=Colors.LIGHT_GREEN)
  92:         depth_options.pack(fill='x', pady=(5, 0))
  93:         
  94:         tk.Radiobutton(depth_options, text="All levels", variable=self.depth_var, value=0,
  95:                       bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
  96:                       font=Fonts.DIALOG_LABEL,
  97:                       selectcolor=Colors.LIGHT_GREEN).pack(side='left')
  98:         
  99:         tk.Radiobutton(depth_options, text="1 level", variable=self.depth_var, value=1,
 100:                       bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 101:                       font=Fonts.DIALOG_LABEL,
 102:                       selectcolor=Colors.LIGHT_GREEN).pack(side='left', padx=(20, 0))
 103:         
 104:         tk.Radiobutton(depth_options, text="2 levels", variable=self.depth_var, value=2,
 105:                       bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 106:                       font=Fonts.DIALOG_LABEL,
 107:                       selectcolor=Colors.LIGHT_GREEN).pack(side='left', padx=(20, 0))
 108:         
 109:         # Content type option
 110:         content_frame = tk.Frame(content, bg=Colors.LIGHT_GREEN)
 111:         content_frame.pack(fill='x', padx=10, pady=(20, 0))
 112:         
 113:         tk.Label(content_frame, text="Show:", 
 114:                 bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 115:                 font=Fonts.DIALOG_LABEL).pack(anchor='w')
 116:         
 117:         self.content_var = tk.StringVar(value="all")
 118:         
 119:         content_options = tk.Frame(content_frame, bg=Colors.LIGHT_GREEN)
 120:         content_options.pack(fill='x', pady=(5, 0))
 121:         
 122:         tk.Radiobutton(content_options, text="All items", variable=self.content_var, value="all",
 123:                       bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 124:                       font=Fonts.DIALOG_LABEL,
 125:                       selectcolor=Colors.LIGHT_GREEN).pack(side='left')
 126:         
 127:         tk.Radiobutton(content_options, text="Folders only", variable=self.content_var, value="folders",
 128:                       bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 129:                       font=Fonts.DIALOG_LABEL,
 130:                       selectcolor=Colors.LIGHT_GREEN).pack(side='left', padx=(20, 0))
 131:         
 132:         tk.Radiobutton(content_options, text="Files only", variable=self.content_var, value="files",
 133:                       bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 134:                       font=Fonts.DIALOG_LABEL,
 135:                       selectcolor=Colors.LIGHT_GREEN).pack(side='left', padx=(20, 0))
 136:         
 137:         # Buttons
 138:         button_frame = tk.Frame(content, bg=Colors.LIGHT_GREEN)
 139:         button_frame.pack(side='bottom', pady=20)
 140:         
 141:         scan_btn = tk.Button(button_frame, text="Scan", 
 142:                             bg=Colors.DARK_GREEN, fg='white',
 143:                             command=self.start_scan,
 144:                             font=Fonts.DIALOG_BUTTON, relief='flat',
 145:                             cursor='hand2', padx=20)
 146:         scan_btn.pack(side='left', padx=10)
 147:         
 148:         cancel_btn = tk.Button(button_frame, text="Cancel", 
 149:                               bg=Colors.INACTIVE_GRAY, fg='white',
 150:                               command=self.cancel,
 151:                               font=Fonts.DIALOG_BUTTON, relief='flat',
 152:                               padx=20)
 153:         cancel_btn.pack(side='left', padx=10)
 154:     
 155:     def auto_populate_folder(self):
 156:         """Auto-populate the folder field with the best default folder"""
 157:         try:
 158:             best_folder = ExplorerDetector.get_best_default_folder()
 159:             if best_folder:
 160:                 self.folder_var.set(best_folder)
 161:                 self.selected_folder = best_folder
 162:         except Exception as e:
 163:             print(f"Error auto-populating folder: {e}")
 164:             try:
 165:                 fallback_folder = os.path.expanduser('~')
 166:                 self.folder_var.set(fallback_folder)
 167:                 self.selected_folder = fallback_folder
 168:             except:
 169:                 pass
 170:     
 171:     def browse_folder(self):
 172:         """Browse for folder to scan"""
 173:         folder = filedialog.askdirectory(parent=self, title="Select Folder to Inventory")
 174:         if folder:
 175:             self.folder_var.set(folder)
 176:             self.selected_folder = folder
 177:     
 178:     def start_scan(self):
 179:         """Start the folder scan"""
 180:         folder = self.folder_var.get().strip()
 181:         if not folder:
 182:             messagebox.showwarning("Invalid Input", "Please select a folder to scan.")
 183:             return
 184:             
 185:         if not os.path.exists(folder):
 186:             messagebox.showerror("Invalid Folder", "The selected folder does not exist.")
 187:             return
 188:         
 189:         # Show progress window
 190:         self.progress_window = ProgressWindow(self, "Scanning...")
 191:         self.progress_window.update()
 192:         
 193:         # Start scan in background thread
 194:         self.cancel_scan = False
 195:         self.scan_thread = threading.Thread(target=self.perform_scan, args=(folder,))
 196:         self.scan_thread.start()
 197:     
 198:     def perform_scan(self, folder):
 199:         """Perform the actual folder scan"""
 200:         try:
 201:             self.inventory_data = []
 202:             max_depth = self.depth_var.get()
 203:             content_type = self.content_var.get()
 204:             
 205:             # Scan folder recursively
 206:             self._scan_folder(folder, 0, max_depth, content_type)
 207:             
 208:             # Close progress window
 209:             if self.progress_window:
 210:                 self.progress_window.after(0, self.progress_window.destroy)
 211:             
 212:             # Open inventory window in main thread
 213:             self.after(0, self.show_inventory_window, folder)
 214:             
 215:         except Exception as e:
 216:             if self.progress_window:
 217:                 self.progress_window.after(0, self.progress_window.destroy)
 218:             self.after(0, lambda: messagebox.showerror("Scan Error", f"Error scanning folder: {str(e)}"))
 219:     
 220:     def _scan_folder(self, folder_path, current_depth, max_depth, content_type):
 221:         """Recursively scan folder"""
 222:         if self.cancel_scan:
 223:             return
 224:             
 225:         try:
 226:             path = Path(folder_path)
 227:             
 228:             # Update progress
 229:             if self.progress_window:
 230:                 self.progress_window.after(0, lambda: self.progress_window.update_message(f"Scanning: {path.name}"))
 231:             
 232:             # Scan items in current folder
 233:             for item in path.iterdir():
 234:                 if self.cancel_scan:
 235:                     return
 236:                     
 237:                 try:
 238:                     if item.is_dir():
 239:                         if content_type in ['all', 'folders']:
 240:                             # Add folder to inventory
 241:                             self.inventory_data.append({
 242:                                 'name': item.name,
 243:                                 'path': str(item),
 244:                                 'type': 'Folder',
 245:                                 'size': self._get_folder_size(item),
 246:                                 'modified': datetime.fromtimestamp(item.stat().st_mtime)
 247:                             })
 248:                         
 249:                         # Recursively scan subfolder if within depth limit
 250:                         if max_depth == 0 or current_depth < max_depth:
 251:                             self._scan_folder(item, current_depth + 1, max_depth, content_type)
 252:                             
 253:                     elif item.is_file() and content_type in ['all', 'files']:
 254:                         # Add file to inventory
 255:                         self.inventory_data.append({
 256:                             'name': item.name,
 257:                             'path': str(item),
 258:                             'type': item.suffix[1:].upper() if item.suffix else 'File',
 259:                             'size': item.stat().st_size,
 260:                             'modified': datetime.fromtimestamp(item.stat().st_mtime)
 261:                         })
 262:                         
 263:                 except Exception as e:
 264:                     print(f"Error scanning {item}: {e}")
 265:                     
 266:         except Exception as e:
 267:             print(f"Error scanning folder {folder_path}: {e}")
 268:     
 269:     def _get_folder_size(self, folder):
 270:         """Get folder item count"""
 271:         try:
 272:             count = len(list(folder.iterdir()))
 273:             return count
 274:         except:
 275:             return 0
 276:     
 277:     def show_inventory_window(self, folder):
 278:         """Show the inventory window with scan results"""
 279:         # Close dialog
 280:         self.destroy()
 281:         
 282:         # Create and show inventory window
 283:         inventory_window = FolderInventoryWindow(self.master, folder, self.inventory_data)
 284:         inventory_window.lift()
 285:         inventory_window.focus_force()
 286:     
 287:     def cancel(self):
 288:         """Cancel the dialog or scan"""
 289:         self.cancel_scan = True
 290:         if self.scan_thread and self.scan_thread.is_alive():
 291:             # Wait briefly for thread to stop
 292:             self.scan_thread.join(timeout=0.5)
 293:         self.destroy()
 294: 
 295: 
 296: class ProgressWindow(SimpleWindow):
 297:     """Simple progress window for scanning"""
 298:     
 299:     def __init__(self, parent, title="Progress"):
 300:         super().__init__(parent, title, resize_handles=None)
 301:         
 302:         self.geometry("300x120")
 303:         
 304:         # Center on parent
 305:         self.update_idletasks()
 306:         parent.update_idletasks()
 307:         x = parent.winfo_x() + (parent.winfo_width() - 300) // 2
 308:         y = parent.winfo_y() + (parent.winfo_height() - 120) // 2
 309:         self.geometry(f"300x120+{x}+{y}")
 310:         
 311:         # Set background color
 312:         self.content_frame.configure(bg=Colors.LIGHT_GREEN)
 313:         
 314:         # Create content
 315:         self.message_label = tk.Label(self.content_frame, text="Scanning folders...",
 316:                                      bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 317:                                      font=Fonts.DIALOG_LABEL)
 318:         self.message_label.pack(pady=20)
 319:         
 320:         # Progress indicator
 321:         self.progress_label = tk.Label(self.content_frame, text="⏳",
 322:                                       bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 323:                                       font=('Arial', 24))
 324:         self.progress_label.pack()
 325:         
 326:         self.animate()
 327:     
 328:     def update_message(self, message):
 329:         """Update progress message"""
 330:         self.message_label.config(text=message[:40] + "..." if len(message) > 40 else message)
 331:     
 332:     def animate(self):
 333:         """Simple animation"""
 334:         current = self.progress_label.cget("text")
 335:         self.progress_label.config(text="⌛" if current == "⏳" else "⏳")
 336:         self.after(500, self.animate)
 337: 
 338: 
 339: class FolderInventoryWindow(SimpleWindow):
 340:     """Window for displaying folder inventory using SimpleWindow with filtering"""
 341:     
 342:     def __init__(self, parent, initial_path=None, scan_data=None):
 343:         self.current_path = Path(initial_path) if initial_path else Path.home()
 344:         self.scan_data = scan_data
 345:         
 346:         # Set window title
 347:         window_title = f"Folder Inventory - {self.current_path.name}"
 348:         
 349:         # Initialize SimpleWindow
 350:         super().__init__(parent, window_title, resize_handles=None)
 351:         
 352:         # Set window size
 353:         self.geometry("1000x700")
 354:         
 355:         # Center window
 356:         self.update_idletasks()
 357:         x = (self.winfo_screenwidth() - 1000) // 2
 358:         y = (self.winfo_screenheight() - 700) // 2
 359:         self.geometry(f"1000x700+{x}+{y}")
 360:         
 361:         # Set background color
 362:         self.content_frame.configure(bg=Colors.LIGHT_GREEN)
 363:         
 364:         # Prepare data
 365:         if self.scan_data:
 366:             self.inventory_data = self._prepare_scan_data()
 367:         else:
 368:             self.inventory_data = self._prepare_folder_data()
 369:         
 370:         # Create the inventory view directly in the content frame
 371:         self._create_inventory_view()
 372:     
 373:     def _create_inventory_view(self):
 374:         """Create the inventory view directly in the content frame"""
 375:         # Header info
 376:         info_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
 377:         info_frame.pack(fill=tk.X, padx=10, pady=5)
 378:         
 379:         path_label = tk.Label(info_frame, text=f"Path: {self.current_path}", 
 380:                              bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 381:                              font=Fonts.DIALOG_LABEL, anchor='w')
 382:         path_label.pack(side=tk.LEFT)
 383:         
 384:         items_label = tk.Label(info_frame, text=f"Items: {len(self.inventory_data)}", 
 385:                               bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 386:                               font=Fonts.DIALOG_LABEL, anchor='e')
 387:         items_label.pack(side=tk.RIGHT)
 388:         
 389:         # Main treeview area
 390:         tree_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
 391:         tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
 392:         
 393:         # Create Treeview
 394:         self.tree = ttk.Treeview(tree_frame, columns=('Type', 'Size', 'Modified'), 
 395:                                 show='tree headings')
 396:         
 397:         # Configure columns
 398:         self.tree.column('#0', width=300, minwidth=200)
 399:         self.tree.column('Type', width=100, minwidth=80)
 400:         self.tree.column('Size', width=120, minwidth=100)
 401:         self.tree.column('Modified', width=150, minwidth=120)
 402:         
 403:         # Configure headings with filtering
 404:         self.tree.heading('#0', text='Name', anchor='w', command=lambda: self._show_filter('name'))
 405:         self.tree.heading('Type', text='Type', anchor='w', command=lambda: self._show_filter('type'))
 406:         self.tree.heading('Size', text='Size', anchor='e', command=lambda: self._show_filter('size_display'))
 407:         self.tree.heading('Modified', text='Modified', anchor='w', command=lambda: self._show_filter('modified_display'))
 408:         
 409:         # Initialize filter state
 410:         self.active_filters = {}
 411:         self.original_data = self.inventory_data.copy()
 412:         
 413:         # Scrollbars
 414:         v_scroll = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.tree.yview)
 415:         h_scroll = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, command=self.tree.xview)
 416:         self.tree.configure(yscrollcommand=v_scroll.set, xscrollcommand=h_scroll.set)
 417:         
 418:         # Grid layout
 419:         self.tree.grid(row=0, column=0, sticky='nsew')
 420:         v_scroll.grid(row=0, column=1, sticky='ns')
 421:         h_scroll.grid(row=1, column=0, sticky='ew')
 422:         
 423:         tree_frame.grid_rowconfigure(0, weight=1)
 424:         tree_frame.grid_columnconfigure(0, weight=1)
 425:         
 426:         # Style the treeview
 427:         style = ttk.Style()
 428:         style.configure('Treeview', background=Colors.LIGHT_GREEN, 
 429:                        foreground=Colors.BLACK, fieldbackground='white')
 430:         style.configure('Treeview.Heading', background=Colors.DARK_GREEN,
 431:                        foreground='white', font=('Arial', 10, 'bold'))
 432:         style.map('Treeview',
 433:                  background=[('selected', Colors.MEDIUM_GREEN)],
 434:                  foreground=[('selected', 'white')])
 435:         
 436:         # Populate the tree
 437:         self._populate_tree()
 438:         
 439:         # Bind events
 440:         self.tree.bind('<Double-1>', self._on_tree_double_click)
 441:         self.tree.bind('<Button-3>', self._on_tree_right_click)
 442:         
 443:         # Add filter status bar
 444:         self.filter_frame = tk.Frame(self.content_frame, bg=Colors.DARK_GREEN, height=25)
 445:         self.filter_frame.pack(fill=tk.X, side=tk.BOTTOM, padx=10, pady=5)
 446:         self.filter_frame.pack_propagate(False)
 447:         
 448:         self.filter_status = tk.Label(self.filter_frame, text="No filters applied", 
 449:                                      bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 450:                                      font=('Arial', 9))
 451:         self.filter_status.pack(side=tk.LEFT, padx=5, pady=2)
 452:         
 453:         clear_filters_btn = tk.Button(self.filter_frame, text="Clear All Filters", 
 454:                                      bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 455:                                      command=self._clear_all_filters,
 456:                                      font=('Arial', 9), relief=tk.RAISED, bd=1)
 457:         clear_filters_btn.pack(side=tk.RIGHT, padx=5, pady=2)
 458:     
 459:     def _populate_tree(self):
 460:         """Populate the treeview with inventory data"""
 461:         # Clear existing items
 462:         for item in self.tree.get_children():
 463:             self.tree.delete(item)
 464:         
 465:         # Add items to tree
 466:         for item_data in self.inventory_data:
 467:             self.tree.insert('', 'end', 
 468:                            text=item_data['name'],
 469:                            values=(item_data['type'], 
 470:                                   item_data['size_display'],
 471:                                   item_data['modified_display']),
 472:                            tags=(item_data['path'],))
 473:     
 474:     def _on_tree_double_click(self, event):
 475:         """Handle double-click on tree item"""
 476:         selection = self.tree.selection()
 477:         if not selection:
 478:             return
 479:             
 480:         item = self.tree.item(selection[0])
 481:         if not item['tags']:
 482:             return
 483:             
 484:         path = Path(item['tags'][0])
 485:         
 486:         if path.is_dir():
 487:             # Navigate to folder
 488:             new_window = FolderInventoryWindow(self.master, str(path))
 489:             self.close_window()
 490:         else:
 491:             # Open file
 492:             try:
 493:                 os.startfile(str(path))
 494:             except:
 495:                 messagebox.showerror("Error", f"Cannot open {path.name}")
 496:     
 497:     def _on_tree_right_click(self, event):
 498:         """Handle right-click context menu"""
 499:         item = self.tree.identify('item', event.x, event.y)
 500:         if item:
 501:             self.tree.selection_set(item)
 502:             
 503:             # Create context menu
 504:             menu = tk.Menu(self, tearoff=0)
 505:             menu.configure(bg=Colors.DARK_GREEN, fg='white',
 506:                           activebackground=Colors.MEDIUM_GREEN,
 507:                           activeforeground='white')
 508:             
 509:             # Get selected item info
 510:             tree_item = self.tree.item(item)
 511:             if tree_item['tags']:
 512:                 path = Path(tree_item['tags'][0])
 513:                 
 514:                 if path.is_file():
 515:                     menu.add_command(label="Open", command=lambda: self._open_file(path))
 516:                     menu.add_separator()
 517:                     
 518:                 menu.add_command(label="Properties", command=lambda: self._show_properties(path))
 519:                 
 520:                 # Show menu
 521:                 menu.post(event.x_root, event.y_root)
 522:     
 523:     def _open_file(self, path):
 524:         """Open file with default application"""
 525:         try:
 526:             os.startfile(str(path))
 527:         except:
 528:             messagebox.showerror("Error", f"Cannot open {path.name}")
 529:     
 530:     def _show_properties(self, path):
 531:         """Show file/folder properties"""
 532:         try:
 533:             subprocess.run(['explorer', '/select,', str(path)])
 534:         except Exception as e:
 535:             messagebox.showerror("Error", f"Cannot show properties: {str(e)}")
 536:     
 537:     def _prepare_scan_data(self):
 538:         """Prepare scanned data"""
 539:         inventory_data = []
 540:         
 541:         for item in self.scan_data:
 542:             # Format size display
 543:             if item['type'] == 'Folder':
 544:                 size_display = f"{item['size']} items"
 545:             else:
 546:                 size_display = self._format_size(item['size'])
 547:             
 548:             # Format modified date
 549:             modified_display = item['modified'].strftime('%Y-%m-%d %H:%M')
 550:             
 551:             inventory_data.append({
 552:                 'name': item['name'],
 553:                 'type': item['type'],
 554:                 'size': item['size'],
 555:                 'size_display': size_display,
 556:                 'modified': item['modified'],
 557:                 'modified_display': modified_display,
 558:                 'path': item['path']
 559:             })
 560:         
 561:         return inventory_data
 562:     
 563:     def _prepare_folder_data(self):
 564:         """Prepare folder data"""
 565:         inventory_data = []
 566:         
 567:         try:
 568:             path = self.current_path
 569:             if not path.exists():
 570:                 return inventory_data
 571:             
 572:             # Add folders first
 573:             for item in sorted(path.iterdir()):
 574:                 if item.is_dir():
 575:                     try:
 576:                         item_count = len(list(item.iterdir()))
 577:                         modified = datetime.fromtimestamp(item.stat().st_mtime)
 578:                         inventory_data.append({
 579:                             'name': item.name,
 580:                             'type': 'Folder',
 581:                             'size': item_count,
 582:                             'size_display': f"{item_count} items",
 583:                             'modified': modified,
 584:                             'modified_display': modified.strftime('%Y-%m-%d %H:%M'),
 585:                             'path': str(item)
 586:                         })
 587:                     except:
 588:                         continue
 589:             
 590:             # Add files
 591:             for item in sorted(path.iterdir()):
 592:                 if item.is_file():
 593:                     try:
 594:                         file_size = item.stat().st_size
 595:                         modified = datetime.fromtimestamp(item.stat().st_mtime)
 596:                         file_type = item.suffix[1:].upper() if item.suffix else 'File'
 597:                         
 598:                         inventory_data.append({
 599:                             'name': item.name,
 600:                             'type': file_type,
 601:                             'size': file_size,
 602:                             'size_display': self._format_size(file_size),
 603:                             'modified': modified,
 604:                             'modified_display': modified.strftime('%Y-%m-%d %H:%M'),
 605:                             'path': str(item)
 606:                         })
 607:                     except:
 608:                         continue
 609:             
 610:         except Exception as e:
 611:             print(f"Error preparing folder data: {e}")
 612:         
 613:         return inventory_data
 614:     
 615:     def _format_size(self, size):
 616:         """Format file size"""
 617:         for unit in ['B', 'KB', 'MB', 'GB']:
 618:             if size < 1024.0:
 619:                 return f"{size:.1f} {unit}"
 620:             size /= 1024.0
 621:         return f"{size:.1f} TB"
 622:     
 623:     def _show_filter(self, column_key):
 624:         """Show filter dialog for a column"""
 625:         # Get unique values for this column
 626:         unique_values = set()
 627:         for item in self.original_data:
 628:             value = str(item.get(column_key, ''))
 629:             if value:
 630:                 unique_values.add(value)
 631:         
 632:         unique_values = sorted(list(unique_values))
 633:         
 634:         # Get current selection
 635:         current_selection = self.active_filters.get(column_key, set())
 636:         
 637:         # Show filter dialog
 638:         from simple_window_factory import FilterMenuDialog
 639:         
 640:         column_headers = {
 641:             'name': 'Name',
 642:             'type': 'Type', 
 643:             'size_display': 'Size',
 644:             'modified_display': 'Modified'
 645:         }
 646:         
 647:         header = column_headers.get(column_key, column_key)
 648:         FilterMenuDialog(self, column_key, header, unique_values, 
 649:                         current_selection, self._apply_filter)
 650:     
 651:     def _apply_filter(self, column_key, selected_values):
 652:         """Apply filter to column"""
 653:         if selected_values:
 654:             self.active_filters[column_key] = set(selected_values)
 655:         else:
 656:             self.active_filters.pop(column_key, None)
 657:         
 658:         self._filter_data()
 659:         self._update_filter_status()
 660:         self._update_column_headers()
 661:     
 662:     def _filter_data(self):
 663:         """Apply all active filters to data"""
 664:         self.inventory_data = []
 665:         
 666:         for item in self.original_data:
 667:             include_item = True
 668:             
 669:             for filter_col, filter_values in self.active_filters.items():
 670:                 item_value = str(item.get(filter_col, ''))
 671:                 if item_value not in filter_values:
 672:                     include_item = False
 673:                     break
 674:             
 675:             if include_item:
 676:                 self.inventory_data.append(item)
 677:         
 678:         self._populate_tree()
 679:         
 680:         # Update items count
 681:         for widget in self.content_frame.winfo_children():
 682:             if isinstance(widget, tk.Frame):
 683:                 for child in widget.winfo_children():
 684:                     if isinstance(child, tk.Label) and "Items:" in child.cget("text"):
 685:                         child.config(text=f"Items: {len(self.inventory_data)}")
 686:                         break
 687:                 break
 688:     
 689:     def _update_filter_status(self):
 690:         """Update filter status display"""
 691:         if not self.active_filters:
 692:             self.filter_status.config(text="No filters applied")
 693:         else:
 694:             filter_count = len(self.active_filters)
 695:             self.filter_status.config(text=f"{filter_count} filter{'s' if filter_count > 1 else ''} applied")
 696:     
 697:     def _update_column_headers(self):
 698:         """Update column headers to show filter indicators"""
 699:         headers = {
 700:             'name': 'Name',
 701:             'type': 'Type',
 702:             'size_display': 'Size', 
 703:             'modified_display': 'Modified'
 704:         }
 705:         
 706:         for col_key, header_text in headers.items():
 707:             if col_key in self.active_filters:
 708:                 display_text = f"{header_text} ▼"
 709:             else:
 710:                 display_text = header_text
 711:                 
 712:             if col_key == 'name':
 713:                 self.tree.heading('#0', text=display_text)
 714:             elif col_key == 'type':
 715:                 self.tree.heading('Type', text=display_text)
 716:             elif col_key == 'size_display':
 717:                 self.tree.heading('Size', text=display_text)
 718:             elif col_key == 'modified_display':
 719:                 self.tree.heading('Modified', text=display_text)
 720:     
 721:     def _clear_all_filters(self):
 722:         """Clear all active filters"""
 723:         self.active_filters = {}
 724:         self.inventory_data = self.original_data.copy()
 725:         self._populate_tree()
 726:         self._update_filter_status()
 727:         self._update_column_headers()
 728:         
 729:         # Update items count
 730:         for widget in self.content_frame.winfo_children():
 731:             if isinstance(widget, tk.Frame):
 732:                 for child in widget.winfo_children():
 733:                     if isinstance(child, tk.Label) and "Items:" in child.cget("text"):
 734:                         child.config(text=f"Items: {len(self.inventory_data)}")
 735:                         break
 736:                 break

────────────────────────────────────────────────────────────────────────────────
FILE: links_manager.py
────────────────────────────────────────────────────────────────────────────────
Path: links_manager.py
Size: 10.8 KB
Lines: 306 total, 253 non-empty
Characters: 11,087
Type: Data management for links and categories
────────────────────────────────────────────────────────────────────────────────

   1: # links_manager.py
   2: """
   3: Data management for Quick Links
   4: Handles loading, saving, and CRUD operations for links
   5: """
   6: 
   7: import json
   8: import os
   9: from pathlib import Path
  10: from config import Paths, DEFAULT_CATEGORIES
  11: from utils import FileUtils  # Import FileUtils for path normalization
  12: 
  13: class LinksManager:
  14:     """Manages saved links with categories"""
  15:     
  16:     def __init__(self):
  17:         # Ensure config directory exists
  18:         Paths.ensure_config_dir()
  19:         self.config_file = Paths.LINKS_FILE
  20:         self.links = self.load_links()
  21:     
  22:     def load_links(self):
  23:         """Load links from config file"""
  24:         try:
  25:             if self.config_file.exists():
  26:                 with open(self.config_file, 'r', encoding='utf-8') as f:
  27:                     data = json.load(f)
  28:                     # Validate structure
  29:                     if "categories" in data and "links" in data:
  30:                         # Fix any existing path issues
  31:                         self._fix_path_separators(data)
  32:                         return data
  33:                     else:
  34:                         print("Invalid config structure, creating new config")
  35:                         return self._create_default_config()
  36:             else:
  37:                 return self._create_default_config()
  38:         except (json.JSONDecodeError, FileNotFoundError, KeyError) as e:
  39:                 print(f"Error loading links: {e}. Creating new config.")
  40:                 return self._create_default_config()
  41:         
  42:     def _fix_path_separators(self, data):
  43:         """Fix forward slash path separators in existing links"""
  44:         for link in data.get("links", []):
  45:             if "path" in link:
  46:                 link["path"] = FileUtils.normalize_path(link["path"])
  47:     
  48:     def _create_default_config(self):
  49:         """Create default configuration"""
  50:         return {
  51:             "categories": DEFAULT_CATEGORIES.copy(),
  52:             "links": [],
  53:             "ui_preferences": {
  54:                 "menu_height": 300  # Default menu height
  55:             }
  56:         }
  57:     
  58:     def save_links(self):
  59:         """Save links to config file"""
  60:         try:
  61:             with open(self.config_file, 'w', encoding='utf-8') as f:
  62:                 json.dump(self.links, f, indent=2, ensure_ascii=False)
  63:             return True
  64:         except Exception as e:
  65:             print(f"Error saving links: {e}")
  66:             return False
  67:     
  68:     def add_link(self, name, path, category, icon="📄"):
  69:         """Add a new link"""
  70:         if not name or not path:
  71:             return False
  72:             
  73:         # Normalize the path for Windows
  74:         normalized_path = FileUtils.normalize_path(path)
  75:         
  76:         # Ensure category exists
  77:         if category not in self.links["categories"]:
  78:             self.links["categories"].append(category)
  79:         
  80:         new_link = {
  81:             "name": name.strip(),
  82:             "path": normalized_path,
  83:             "category": category,
  84:             "icon": icon
  85:         }
  86:         
  87:         self.links["links"].append(new_link)
  88:         return self.save_links()
  89:     
  90:     def update_link(self, index, name, path, category, icon="📄"):
  91:         """Update an existing link"""
  92:         if not (0 <= index < len(self.links["links"])):
  93:             return False
  94:         
  95:         if not name or not path:
  96:             return False
  97:         
  98:         # Normalize the path for Windows
  99:         normalized_path = FileUtils.normalize_path(path)
 100:         
 101:         # Ensure category exists
 102:         if category not in self.links["categories"]:
 103:             self.links["categories"].append(category)
 104:         
 105:         self.links["links"][index] = {
 106:             "name": name.strip(),
 107:             "path": normalized_path,
 108:             "category": category,
 109:             "icon": icon
 110:         }
 111:         
 112:         return self.save_links()
 113:     
 114:     def remove_link(self, index):
 115:         """Remove a link by index"""
 116:         if 0 <= index < len(self.links["links"]):
 117:             del self.links["links"][index]
 118:             return self.save_links()
 119:         return False
 120:     
 121:     def get_links_by_category(self, category):
 122:         """Get all links in a category"""
 123:         return [link for link in self.links["links"] if link["category"] == category]
 124:     
 125:     def get_all_links(self):
 126:         """Get all links"""
 127:         return self.links["links"].copy()
 128:     
 129:     def get_categories(self):
 130:         """Get all categories"""
 131:         return self.links["categories"].copy()
 132:     
 133:     def add_category(self, category_name):
 134:         """Add a new category"""
 135:         if category_name and category_name not in self.links["categories"]:
 136:             self.links["categories"].append(category_name)
 137:             return self.save_links()
 138:         return False
 139:     
 140:     def remove_category(self, category_name):
 141:         """Remove a category and all its links"""
 142:         if category_name in self.links["categories"]:
 143:             # Remove all links in this category
 144:             self.links["links"] = [
 145:                 link for link in self.links["links"] 
 146:                 if link["category"] != category_name
 147:             ]
 148:             # Remove the category
 149:             self.links["categories"].remove(category_name)
 150:             return self.save_links()
 151:         return False
 152:     
 153:     def move_link(self, from_index, to_index):
 154:         """Move a link from one position to another"""
 155:         if (0 <= from_index < len(self.links["links"]) and 
 156:             0 <= to_index < len(self.links["links"])):
 157:             
 158:             link = self.links["links"].pop(from_index)
 159:             self.links["links"].insert(to_index, link)
 160:             return self.save_links()
 161:         return False
 162:     
 163:     def search_links(self, query):
 164:         """Search links by name or path"""
 165:         query = query.lower().strip()
 166:         if not query:
 167:             return self.get_all_links()
 168:         
 169:         results = []
 170:         for link in self.links["links"]:
 171:             if (query in link["name"].lower() or 
 172:                 query in link["path"].lower() or
 173:                 query in link["category"].lower()):
 174:                 results.append(link)
 175:         
 176:         return results
 177:     
 178:     def get_stats(self):
 179:         """Get statistics about links"""
 180:         total_links = len(self.links["links"])
 181:         categories_count = {}
 182:         
 183:         for link in self.links["links"]:
 184:             category = link["category"]
 185:             categories_count[category] = categories_count.get(category, 0) + 1
 186:         
 187:         return {
 188:             "total_links": total_links,
 189:             "total_categories": len(self.links["categories"]),
 190:             "links_per_category": categories_count
 191:         }
 192:     
 193:     def export_links(self, file_path):
 194:         """Export links to a JSON file"""
 195:         try:
 196:             with open(file_path, 'w', encoding='utf-8') as f:
 197:                 json.dump(self.links, f, indent=2, ensure_ascii=False)
 198:             return True
 199:         except Exception as e:
 200:             print(f"Error exporting links: {e}")
 201:             return False
 202:     
 203:     def import_links(self, file_path, merge=True):
 204:         """Import links from a JSON file"""
 205:         try:
 206:             with open(file_path, 'r', encoding='utf-8') as f:
 207:                 imported_data = json.load(f)
 208:             
 209:             if not merge:
 210:                 # Replace all data
 211:                 self.links = imported_data
 212:             else:
 213:                 # Merge data
 214:                 for category in imported_data.get("categories", []):
 215:                     if category not in self.links["categories"]:
 216:                         self.links["categories"].append(category)
 217:                 
 218:                 for link in imported_data.get("links", []):
 219:                     # Check for duplicates (same name and path)
 220:                     duplicate = any(
 221:                         existing["name"] == link["name"] and existing["path"] == link["path"]
 222:                         for existing in self.links["links"]
 223:                     )
 224:                     if not duplicate:
 225:                         self.links["links"].append(link)
 226:             
 227:             return self.save_links()
 228:         except Exception as e:
 229:             print(f"Error importing links: {e}")
 230:             return False
 231:     
 232:     def get_menu_height(self):
 233:         """Get stored menu height"""
 234:         return self.links.get("ui_preferences", {}).get("menu_height", 300)
 235:     
 236:     def set_menu_height(self, height):
 237:         """Set menu height and save"""
 238:         if "ui_preferences" not in self.links:
 239:             self.links["ui_preferences"] = {}
 240:         self.links["ui_preferences"]["menu_height"] = height
 241:         return self.save_links()
 242:     
 243:     def move_link_to_category(self, link_index, new_category):
 244:         """Move a link to a different category"""
 245:         if not (0 <= link_index < len(self.links["links"])):
 246:             return False
 247:         
 248:         # Ensure new category exists
 249:         if new_category not in self.links["categories"]:
 250:             self.links["categories"].append(new_category)
 251:         
 252:         # Update the link's category
 253:         self.links["links"][link_index]["category"] = new_category
 254:         return self.save_links()
 255:     
 256:     def reorder_links_in_category(self, category, old_position, new_position):
 257:         """Reorder links within a category"""
 258:         category_links = [i for i, link in enumerate(self.links["links"]) 
 259:                          if link["category"] == category]
 260:         
 261:         if not (0 <= old_position < len(category_links) and 
 262:                 0 <= new_position < len(category_links)):
 263:             return False
 264:         
 265:         # Get the actual indices in the main links array
 266:         old_index = category_links[old_position]
 267:         new_index = category_links[new_position]
 268:         
 269:         # Move the link
 270:         link_to_move = self.links["links"].pop(old_index)
 271:         
 272:         # Adjust new_index if it's affected by the removal
 273:         if old_index < new_index:
 274:             new_index -= 1
 275:         
 276:         # Calculate the correct insertion position
 277:         if new_position == 0:
 278:             # Insert at the beginning of the category
 279:             insert_index = category_links[0] if old_index != category_links[0] else 0
 280:         elif new_position == len(category_links) - 1:
 281:             # Insert at the end of the category
 282:             insert_index = len(self.links["links"])
 283:         else:
 284:             # Insert at the specified position
 285:             insert_index = category_links[new_position]
 286:             if old_index < insert_index:
 287:                 insert_index -= 1
 288:         
 289:         self.links["links"].insert(insert_index, link_to_move)
 290:         return self.save_links()
 291:     
 292:     def get_link_position_in_category(self, link_index):
 293:         """Get the position of a link within its category"""
 294:         if not (0 <= link_index < len(self.links["links"])):
 295:             return -1
 296:         
 297:         link = self.links["links"][link_index]
 298:         category = link["category"]
 299:         
 300:         category_links = [i for i, l in enumerate(self.links["links"]) 
 301:                          if l["category"] == category]
 302:         
 303:         try:
 304:             return category_links.index(link_index)
 305:         except ValueError:
 306:             return -1

────────────────────────────────────────────────────────────────────────────────
FILE: main.py
────────────────────────────────────────────────────────────────────────────────
Path: main.py
Size: 1.5 KB
Lines: 58 total, 47 non-empty
Characters: 1,442
Type: Main application entry point
────────────────────────────────────────────────────────────────────────────────

   1: # main.py
   2: """
   3: Main entry point for SuiteView Taskbar Application
   4: """
   5: import sys
   6: import os
   7: import sys
   8: 
   9: print(sys.prefix)  # Shows venv path if active
  10: print(sys.base_prefix)  # Shows original Python installation
  11: 
  12: # Am I in a venv?
  13: in_venv = sys.prefix != sys.base_prefix
  14: 
  15: if in_venv:
  16:     print("I am in a venv")
  17: else:
  18:     print("I am not in a venv") 
  19: 
  20: # Add the current directory to the Python path to ensure imports work
  21: current_dir = os.path.dirname(os.path.abspath(__file__))
  22: #print(f"Current directory: {current_dir}")
  23: 
  24: if current_dir not in sys.path:
  25:     sys.path.insert(0, current_dir)
  26: 
  27: #print(f"sys.path: {sys.path}")
  28: 
  29: # Now import our modules
  30: try:
  31:     from taskbar import SuiteViewTaskbar
  32:     from config import Settings
  33: except ImportError as e:
  34:     print(f"Import error: {e}")
  35:     print(f"Current directory: {current_dir}")
  36:     print(f"Files in directory: {os.listdir(current_dir)}")
  37:     sys.exit(1)
  38: 
  39: def main():
  40:     """Main application entry point"""
  41:     try:
  42:         print(f"Starting {Settings.APP_NAME} v{Settings.VERSION}")
  43:         
  44:         # Create and run the taskbar application
  45:         app = SuiteViewTaskbar()
  46:         app.run()
  47:         
  48:     except KeyboardInterrupt:
  49:         print("Application interrupted by user")
  50:         sys.exit(0)
  51:     except Exception as e:
  52:         print(f"Error starting application: {e}")
  53:         import traceback
  54:         traceback.print_exc()
  55:         sys.exit(1)
  56: 
  57: if __name__ == "__main__":
  58:     main()

────────────────────────────────────────────────────────────────────────────────
FILE: pinned_windows.py
────────────────────────────────────────────────────────────────────────────────
Path: pinned_windows.py
Size: 13.3 KB
Lines: 338 total, 266 non-empty
Characters: 13,293
Type: Pinned windows management and tracking
────────────────────────────────────────────────────────────────────────────────

   1: # pinned_windows.py (modified)
   2: """
   3: Pinned windows section for SuiteView Taskbar
   4: Manages the pinned window buttons in the taskbar
   5: Modified to blend seamlessly with taskbar
   6: """
   7: 
   8: import tkinter as tk
   9: from config import Colors, Fonts, Settings
  10: from window_manager import ManagedWindow, WindowManager
  11: from ui_components import ConfirmationDialog
  12: import win32gui
  13: import win32con
  14: 
  15: class PinnedWindowButton(tk.Frame):
  16:     """Individual pinned window button with app-specific colors"""
  17:     
  18:     def __init__(self, parent, window: ManagedWindow, window_manager: WindowManager, 
  19:                  on_unpin_callback):
  20:         super().__init__(parent, bg=Colors.DARK_GREEN, bd=0, highlightthickness=0)
  21:         self.window = window
  22:         self.window_manager = window_manager
  23:         self.on_unpin_callback = on_unpin_callback
  24:         
  25:         # Create button
  26:         self.create_button()
  27:         
  28:         # Bind right-click for unpin
  29:         self.button.bind("<Button-3>", self.show_unpin_menu)
  30:     
  31:     def create_button(self):
  32:         """Create the toggle button with app-specific colors"""
  33:         # Get app colors
  34:         bg_color = self.window.colors['bg']
  35:         fg_color = self.window.colors['fg']
  36:         
  37:         # Use shortened display name (without app prefix)
  38:         display_text = self.window.display_name
  39:         
  40:         # Truncate if too long
  41:         max_chars = 12
  42:         if len(display_text) > max_chars:
  43:             display_text = display_text[:max_chars-2] + ".."
  44:         
  45:         self.button = tk.Button(self, text=display_text,
  46:                                bg=bg_color, fg=fg_color,
  47:                                relief=tk.RAISED, bd=2,
  48:                                width=6,  # Slightly wider for better text fit
  49:                                font=('Arial', 8),
  50:                                padx=0,
  51:                                cursor='hand2',
  52:                                wraplength=40,  # Allow text wrapping
  53:                                activebackground=self._lighten_color(bg_color),
  54:                                activeforeground=fg_color,
  55:                                command=self.bring_window_to_front)
  56:         self.button.pack(fill=tk.BOTH, expand=True)
  57:         
  58:         # Update visual state if window is hidden
  59:         if self.window.is_hidden:
  60:             self.button.configure(relief=tk.SUNKEN, bd=1)
  61:     
  62:     def _lighten_color(self, hex_color):
  63:         """Lighten a hex color for hover effect"""
  64:         # Convert hex to RGB
  65:         hex_color = hex_color.lstrip('#')
  66:         r, g, b = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
  67:         
  68:         # Lighten by 20%
  69:         r = min(255, int(r * 1.2))
  70:         g = min(255, int(g * 1.2))
  71:         b = min(255, int(b * 1.2))
  72:         
  73:         return f'#{r:02x}{g:02x}{b:02x}'
  74:     
  75:     def bring_window_to_front(self):
  76:         """Toggle window - hide if fully visible/on top, otherwise bring to front"""
  77:         
  78:         try:
  79:             import win32gui
  80:             
  81:             if self.window.is_hidden:
  82:                 self.window_manager.toggle_window_visibility(self.window)
  83: 
  84:             self.window.bring_to_front()
  85: 
  86:                 
  87:                 
  88:                 # Window is visible - check if it's the foreground window
  89:                 # current_foreground = win32gui.GetForegroundWindow()
  90:                 
  91:                 # # Check if window is minimized
  92:                 # if win32gui.IsIconic(self.window.hwnd):
  93:                 #     print(f"Window {self.window.display_name} is minimized - restoring")
  94:                 #     self.window.bring_to_front()
  95:                 # elif current_foreground == self.window.hwnd:
  96:                 #     # Window is the foreground window - hide it
  97:                 #     print(f"Window {self.window.display_name} is foreground - hiding")
  98:                 #     self.window_manager.toggle_window_visibility(self.window)
  99:                 # else:
 100:                 #     # Window is visible but not foreground - bring it to front
 101:                 #     print(f"Window {self.window.display_name} is not foreground - bringing to front")
 102:                 #     self.window.bring_to_front()
 103:                 
 104:         except Exception as e:
 105:             print(f"Error in bring_window_to_front: {e}")
 106:             import traceback
 107:             traceback.print_exc()
 108:             # Fallback to just bringing to front
 109:             self.window.bring_to_front()
 110:             
 111:         # Don't update appearance - keep button color consistent
 112:     
 113:     def show_unpin_menu(self, event):
 114:         """Show right-click menu for unpinning"""
 115:         # Get taskbar position for proper dialog placement
 116:         taskbar = self.winfo_toplevel()
 117:         taskbar_x = taskbar.winfo_x()
 118:         taskbar_y = taskbar.winfo_y()
 119:         
 120:         # Get button position relative to taskbar
 121:         button_x = self.winfo_rootx()
 122:         
 123:         # Create custom confirmation dialog positioned above taskbar
 124:         dialog = UnpinConfirmationDialog(
 125:             taskbar,
 126:             self.window.app_name,
 127:             button_x,
 128:             taskbar_y
 129:         )
 130:         
 131:         # Wait for dialog result
 132:         taskbar.wait_window(dialog)
 133:         
 134:         if dialog.result:
 135:             self.window_manager.unpin_window(self.window)
 136:             self.on_unpin_callback()
 137:             
 138:         # Prevent event from propagating to parent widgets (taskbar)
 139:         return 'break'
 140:     
 141:     def update_window_title(self, window: ManagedWindow):
 142:         """Update the title of a specific pinned window button"""
 143:         if window.hwnd in self.pinned_buttons:
 144:             button_widget = self.pinned_buttons[window.hwnd]
 145:             
 146:             # Update button text with new display name
 147:             display_text = window.display_name
 148:             
 149:             # Truncate if too long
 150:             max_chars = 12
 151:             if len(display_text) > max_chars:
 152:                 display_text = display_text[:max_chars-2] + ".."
 153:             
 154:             button_widget.button.configure(text=display_text)
 155:             print(f"Updated pinned button text to: {display_text}")
 156: 
 157: class PinnedWindowsSection(tk.Frame):
 158:     """Section in taskbar for pinned windows - now blends with taskbar"""
 159:     
 160:     def __init__(self, parent, window_manager: WindowManager, on_pin_changed_callback=None):
 161:         # Use same background as taskbar, no border
 162:         super().__init__(parent, bg=Colors.DARK_GREEN, relief=tk.FLAT, bd=0)
 163:         self.window_manager = window_manager
 164:         self.pinned_buttons = {}
 165:         self.on_pin_changed_callback = on_pin_changed_callback
 166:         
 167:         # Debug output
 168:         # print(f"\n=== CREATING PINNED WINDOWS SECTION ===")
 169:         # print(f"Parent: {parent}")
 170:         # print(f"Window manager: {window_manager}")
 171: 
 172:         # Don't set a fixed width - let it expand based on content
 173:         self.configure(height=40)  # Match taskbar height
 174:         
 175:         # Remove any visible border
 176:         self.configure(highlightbackground=Colors.DARK_GREEN, highlightthickness=0)
 177:         
 178:         # Create container for buttons with no padding
 179:         self.button_container = tk.Frame(self, bg=Colors.DARK_GREEN)
 180:         self.button_container.pack(fill=tk.BOTH, expand=True)  # No padding
 181:         
 182:         # No empty state label - just leave it blank
 183:         
 184:         # print(f"PinnedWindowsSection created successfully: {self}")
 185:         # print(f"=== END CREATING PINNED WINDOWS SECTION ===\n")
 186:     
 187:     def refresh(self):
 188:         """Refresh the pinned windows display"""
 189:         # print(f"\n=== PINNED SECTION REFRESH ===")
 190:         # print(f"Current button count: {len(self.pinned_buttons)}")
 191:         
 192:         # Clear existing buttons
 193:         for hwnd in list(self.pinned_buttons.keys()):
 194:             print(f"Destroying old button for hwnd: {hwnd}")
 195:             self.pinned_buttons[hwnd].destroy()
 196:             del self.pinned_buttons[hwnd]
 197:         
 198:         # Get pinned windows
 199:         pinned_windows = self.window_manager.get_pinned_windows()
 200:         print(f"Found {len(pinned_windows)} pinned windows")
 201:         
 202:         if pinned_windows:
 203:             # Create buttons for pinned windows
 204:             for i, window in enumerate(pinned_windows):
 205:                 print(f"{i}. Creating button for: {window.display_name} (hwnd: {window.hwnd})")
 206:                 if window.is_valid():
 207:                     button = PinnedWindowButton(
 208:                         self.button_container, 
 209:                         window, 
 210:                         self.window_manager,
 211:                         self.on_pin_changed
 212:                     )
 213:                     button.pack(side=tk.LEFT, fill=tk.BOTH, expand=False)  # No padding, fill height
 214:                     self.pinned_buttons[window.hwnd] = button
 215:                     print(f"   Button created and packed")
 216:                     
 217:                     # Force update to ensure visibility
 218:                     button.update()
 219:                     self.button_container.update()
 220:                 else:
 221:                     print(f"   Window is not valid!")
 222:         
 223:         # Force the section to update
 224:         self.update_idletasks()
 225:         # print(f"Button container visible: {self.button_container.winfo_viewable()}")
 226:         # print(f"Section geometry: {self.winfo_width()}x{self.winfo_height()}")
 227:         # print("=== END REFRESH ===\n")
 228:     
 229:     def on_pin_changed(self):
 230:         """Called when a window is pinned/unpinned from the button"""
 231:         # Refresh the pinned section
 232:         self.refresh()
 233:         
 234:         # Also call the taskbar callback if it exists
 235:         if self.on_pin_changed_callback:
 236:             self.on_pin_changed_callback()
 237: 
 238: 
 239: class UnpinConfirmationDialog(tk.Toplevel):
 240:     """Custom unpin confirmation dialog positioned above taskbar"""
 241:     
 242:     def __init__(self, parent, app_name, button_x, taskbar_y):
 243:         super().__init__(parent)
 244:         self.result = False
 245:         
 246:         # Window setup
 247:         self.overrideredirect(True)
 248:         self.configure(bg=Colors.DARK_GREEN)
 249:         self.attributes('-topmost', True)
 250:         
 251:         # Create main frame with border
 252:         main_frame = tk.Frame(self, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=2)
 253:         main_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
 254:         
 255:         # Create header
 256:         header = tk.Frame(main_frame, bg=Colors.DARK_GREEN, height=25)
 257:         header.pack(fill=tk.X)
 258:         header.pack_propagate(False)
 259:         
 260:         # Title with icon
 261:         title_label = tk.Label(header, text="📌 Unpin Window", 
 262:                              bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 263:                              font=Fonts.DIALOG_TITLE)
 264:         title_label.pack(side=tk.LEFT, padx=10, pady=3)
 265:         
 266:         # Close button
 267:         close_btn = tk.Label(header, text="×", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 268:                            font=('Arial', 12, 'bold'), cursor='hand2')
 269:         close_btn.pack(side=tk.RIGHT, padx=5)
 270:         close_btn.bind("<Button-1>", lambda e: self.cancel())
 271:         
 272:         # Content area
 273:         content = tk.Frame(main_frame, bg=Colors.LIGHT_GREEN)
 274:         content.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
 275:         
 276:         # Pin icon
 277:         icon_label = tk.Label(content, text="📌", bg=Colors.LIGHT_GREEN,
 278:                             font=('Arial', 24))
 279:         icon_label.pack(pady=5)
 280:         
 281:         # Message
 282:         msg = f"Unpin '{app_name}' from taskbar?"
 283:         msg_label = tk.Label(content, text=msg, bg=Colors.LIGHT_GREEN,
 284:                            fg=Colors.BLACK, font=Fonts.DIALOG_LABEL)
 285:         msg_label.pack(pady=5)
 286:         
 287:         # Buttons
 288:         button_frame = tk.Frame(content, bg=Colors.LIGHT_GREEN)
 289:         button_frame.pack(pady=10)
 290:         
 291:         yes_btn = tk.Button(button_frame, text="Yes", 
 292:                           bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 293:                           command=self.yes, width=8,
 294:                           font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 295:         yes_btn.pack(side=tk.LEFT, padx=5)
 296:         
 297:         no_btn = tk.Button(button_frame, text="No", 
 298:                          bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 299:                          command=self.cancel, width=8,
 300:                          font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 301:         no_btn.pack(side=tk.LEFT, padx=5)
 302:         
 303:         # Set dialog size
 304:         dialog_width = 350
 305:         dialog_height = 200
 306:         
 307:         # Position dialog above taskbar, centered on button
 308:         x = button_x - dialog_width // 2
 309:         y = taskbar_y - dialog_height - 5  # 5px gap above taskbar
 310:         
 311:         # Ensure dialog stays on screen
 312:         screen_width = self.winfo_screenwidth()
 313:         if x < 0:
 314:             x = 0
 315:         elif x + dialog_width > screen_width:
 316:             x = screen_width - dialog_width
 317:         
 318:         self.geometry(f"{dialog_width}x{dialog_height}+{x}+{y}")
 319:         
 320:         # Focus on No button (safer default)
 321:         no_btn.focus_set()
 322:         
 323:         # Bind keys
 324:         self.bind('<Return>', lambda e: self.yes())
 325:         self.bind('<Escape>', lambda e: self.cancel())
 326:         
 327:         # Make modal
 328:         self.grab_set()
 329:     
 330:     def yes(self):
 331:         """Yes button clicked"""
 332:         self.result = True
 333:         self.destroy()
 334:     
 335:     def cancel(self):
 336:         """No button clicked or dialog cancelled"""
 337:         self.result = False
 338:         self.destroy()

────────────────────────────────────────────────────────────────────────────────
FILE: quick_links.py
────────────────────────────────────────────────────────────────────────────────
Path: quick_links.py
Size: 36.3 KB
Lines: 867 total, 691 non-empty
Characters: 36,277
Type: Quick links menu and management
────────────────────────────────────────────────────────────────────────────────

   1: # quick_links.py
   2: """
   3: Quick Links feature for SuiteView Taskbar
   4: Contains the links menu, dialogs, and management interface
   5: """
   6: 
   7: import tkinter as tk
   8: from tkinter import ttk, filedialog
   9: from config import Colors, Fonts, Dimensions
  10: from utils import UIUtils, FileUtils
  11: from ui_components import CustomDialog, ConfirmationDialog, FormField, CategoryHeader, WarningDialog, ErrorDialog
  12: from links_manager import LinksManager
  13: 
  14: class QuickLinksMenu(tk.Toplevel):
  15:     """Enhanced right-click context menu for managing links with column layout"""
  16:     
  17:     def __init__(self, parent, taskbar_instance, x, y):
  18:         super().__init__(parent)
  19:         self.parent = parent
  20:         self.taskbar_instance = taskbar_instance
  21:         self.links_manager = taskbar_instance.links_manager
  22:         
  23:         # Window setup
  24:         self.overrideredirect(True)
  25:         self.configure(bg=Colors.DARK_GREEN)
  26:         self.attributes('-topmost', True)
  27:         self.attributes('-alpha', 0.98)
  28:         
  29:         # Initialize resize variables
  30:         self.is_resizing = False
  31:         self.resize_start_y = 0
  32:         self.original_height = 0
  33:         self.bottom_y = 0  # Track bottom position for locked resizing
  34:         
  35:         # Initialize drag and drop variables
  36:         self.is_dragging_link = False
  37:         self.drag_start_time = 0
  38:         self.drag_threshold = 5  # pixels to move before considering it a drag
  39:         self.drag_time_threshold = 200  # milliseconds to wait before drag
  40:         self.dragged_link_data = None
  41:         self.dragged_link_index = None
  42:         self.drag_visual = None
  43:         self.drop_indicators = []
  44:         
  45:         # Position the menu
  46:         self.geometry(f"+{x}+{y}")
  47:         
  48:         # Main container with dark green border
  49:         self.main_frame = tk.Frame(self, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=2)
  50:         self.main_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
  51:         
  52:         # Header frame with buttons
  53:         self.create_header()
  54:         
  55:         # Content area with light green background
  56:         self.content_frame = tk.Frame(self.main_frame, bg=Colors.LIGHT_GREEN, relief=tk.SUNKEN, bd=1)
  57:         self.content_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
  58:         
  59:         # Create column layout for all categories
  60:         self.create_column_layout()
  61:         
  62:         # Bind events
  63:         self.bind("<FocusOut>", lambda e: self.destroy())
  64:         self.focus_set()
  65:         
  66:         # Set minimum size based on content and stored preferences
  67:         self.update_idletasks()
  68:         self.menu_width = max(Dimensions.MENU_MIN_WIDTH, self.winfo_reqwidth())
  69:         
  70:         # Use stored menu height or default
  71:         stored_height = self.links_manager.get_menu_height()
  72:         calculated_height = max(Dimensions.MENU_MIN_HEIGHT, self.winfo_reqheight())
  73:         self.menu_height = max(stored_height, calculated_height)
  74:         
  75:         self.geometry(f"{self.menu_width}x{self.menu_height}")
  76:         
  77:         # Store bottom position for locked resizing
  78:         self.update_idletasks()
  79:         self.bottom_y = self.winfo_y() + self.winfo_height()
  80:         
  81:         # Setup resize functionality
  82:         self.setup_resize_functionality()
  83:         
  84:     
  85:     def create_header(self):
  86:         """Create header with title and buttons"""
  87:         self.header_frame = tk.Frame(self.main_frame, bg=Colors.DARK_GREEN, height=25)
  88:         self.header_frame.pack(fill=tk.X, padx=1, pady=1)
  89:         self.header_frame.pack_propagate(False)
  90:         
  91:         # Create a resize area at the top of the header
  92:         resize_area = tk.Frame(self.header_frame, bg=Colors.MEDIUM_GREEN, height=3, cursor='sb_v_double_arrow')
  93:         resize_area.pack(fill=tk.X, side=tk.TOP)
  94:         
  95:         # Main header content
  96:         header_content = tk.Frame(self.header_frame, bg=Colors.DARK_GREEN)
  97:         header_content.pack(fill=tk.BOTH, expand=True)
  98:         
  99:         # Resize handle (left side) - more prominent
 100:         resize_handle = tk.Label(header_content, text="═══", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 101:                                font=('Arial', 6), cursor='sb_v_double_arrow', width=4)
 102:         resize_handle.pack(side=tk.LEFT, padx=2, pady=3)
 103:         
 104:         # Title with resize capability
 105:         title_label = tk.Label(header_content, text="Quick Links ↕", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 106:                              font=Fonts.MENU_HEADER, cursor='sb_v_double_arrow')
 107:         title_label.pack(side=tk.LEFT, padx=5, pady=3)
 108:         
 109:         # Bind resize events to multiple elements for better usability
 110:         for widget in [resize_area, resize_handle, title_label, self.header_frame]:
 111:             widget.bind("<Button-1>", self.start_resize)
 112:             widget.bind("<B1-Motion>", self.do_resize)
 113:             widget.bind("<ButtonRelease-1>", self.end_resize)
 114:             widget.bind("<Enter>", lambda e: self.configure(cursor='sb_v_double_arrow'))
 115:             widget.bind("<Leave>", lambda e: self.configure(cursor=''))
 116:         
 117:         # Buttons with green theme
 118:         button_frame = tk.Frame(header_content, bg=Colors.DARK_GREEN)
 119:         button_frame.pack(side=tk.RIGHT, padx=5)
 120:         
 121:         # Add button
 122:         add_btn = tk.Button(button_frame, text="Add", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 123:                            relief=tk.RAISED, bd=1, cursor='hand2', 
 124:                            font=Fonts.MENU_ITEM, width=4, height=1,
 125:                            command=self.add_new_link)
 126:         add_btn.pack(side=tk.LEFT, padx=1)
 127:         
 128:         # # View button (placeholder for future features)
 129:         # view_btn = tk.Button(button_frame, text="Vie", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 130:         #                     relief=tk.RAISED, bd=1, cursor='hand2',
 131:         #                     font=Fonts.MENU_ITEM, width=4, height=1)
 132:         # view_btn.pack(side=tk.LEFT, padx=1)
 133:         
 134:         # Close button
 135:         close_btn = tk.Button(button_frame, text="X", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 136:                              relief=tk.RAISED, bd=1, cursor='hand2',
 137:                              font=Fonts.MENU_ITEM, width=3, height=1,
 138:                              command=self.destroy)
 139:         close_btn.pack(side=tk.LEFT, padx=1)
 140:     
 141:     def create_column_layout(self):
 142:         """Create column layout showing all categories"""
 143:         # Container for columns
 144:         columns_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
 145:         columns_frame.pack(fill=tk.BOTH, expand=True, padx=3, pady=3)
 146:         
 147:         categories = self.links_manager.get_categories()
 148:         num_categories = len(categories)
 149:         
 150:         # Create columns for each category
 151:         for i, category in enumerate(categories):
 152:             column_frame = tk.Frame(columns_frame, bg=Colors.LIGHT_GREEN, relief=tk.FLAT)
 153:             column_frame.grid(row=0, column=i, sticky='nsew', padx=2, pady=1)
 154:             
 155:             # Configure grid weights for equal distribution
 156:             columns_frame.grid_columnconfigure(i, weight=1)
 157:         
 158:         columns_frame.grid_rowconfigure(0, weight=1)
 159:         
 160:         # Populate each column
 161:         for i, category in enumerate(categories):
 162:             self.create_category_column(columns_frame, category, i)
 163:     
 164:     def create_category_column(self, parent, category, column_index):
 165:         """Create a column for a specific category"""
 166:         # Get the column frame
 167:         column_frame = parent.grid_slaves(row=0, column=column_index)[0]
 168:         
 169:         # Category header
 170:         header = CategoryHeader(column_frame, category)
 171:         header.pack(fill=tk.X, pady=(0, 2))
 172:         
 173:         # Links container with light green background
 174:         links_container = tk.Frame(column_frame, bg=Colors.LIGHT_GREEN)
 175:         links_container.pack(fill=tk.BOTH, expand=True)
 176:         
 177:         # Store category for drop operations
 178:         links_container.category = category
 179:         links_container.bind("<Enter>", lambda e: self.on_category_drop_zone_enter(e, category))
 180:         links_container.bind("<Leave>", lambda e: self.on_category_drop_zone_leave(e, category))
 181:         
 182:         # Get links for this category
 183:         links = self.links_manager.get_links_by_category(category)
 184:         
 185:         if links:
 186:             for link in links:
 187:                 # Find the actual index in the full links list
 188:                 actual_index = self.links_manager.get_all_links().index(link)
 189:                 self.create_compact_link_item(links_container, link, actual_index)
 190:         else:
 191:             # Empty state - also acts as a drop zone
 192:             empty_label = tk.Label(links_container, text="", bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 193:                                  font=(Fonts.MENU_ITEM[0], Fonts.MENU_ITEM[1], 'italic'))
 194:             empty_label.pack(pady=5)
 195:             empty_label.category = category
 196:             empty_label.bind("<Enter>", lambda e: self.on_empty_category_enter(e, category))
 197:             empty_label.bind("<Leave>", lambda e: self.on_empty_category_leave(e, category))
 198:     
 199:     def create_compact_link_item(self, parent, link, index):
 200:         """Create a compact link item with drag-and-drop support"""
 201:         # Create a frame to hold the link (easier for drag operations)
 202:         link_frame = tk.Frame(parent, bg=Colors.LIGHT_GREEN, relief=tk.FLAT)
 203:         link_frame.pack(fill=tk.X, padx=2, pady=1)
 204:         
 205:         # Create the link label
 206:         link_label = tk.Label(link_frame, text=f"{link['name']}", bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 207:                              font=Fonts.MENU_ITEM, anchor='w', height=1,
 208:                              cursor='hand2', relief=tk.FLAT, padx=5, pady=2)
 209:         link_label.pack(fill=tk.X)
 210:         
 211:         # Store link data for drag operations
 212:         link_frame.link_data = link
 213:         link_frame.link_index = index
 214:         link_frame.category = link['category']
 215:         link_label.link_data = link
 216:         link_label.link_index = index
 217:         link_label.category = link['category']
 218:         
 219:         # Apply hover effects
 220:         UIUtils.apply_hover_effect(link_label, Colors.LIGHT_GREEN, Colors.HOVER_GREEN, 
 221:                                   Colors.BLACK, Colors.WHITE)
 222:         
 223:         # Bind drag and drop events
 224:         for widget in [link_frame, link_label]:
 225:             widget.bind("<Button-1>", lambda e, l=link, i=index: self.on_link_press(e, l, i))
 226:             widget.bind("<B1-Motion>", lambda e, l=link, i=index: self.on_link_drag(e, l, i))
 227:             widget.bind("<ButtonRelease-1>", lambda e, l=link, i=index: self.on_link_release(e, l, i))
 228:             widget.bind("<Button-3>", lambda e, l=link, i=index: self.show_link_context_menu(e, l, i))
 229:         
 230:         # Mark as drop zone
 231:         link_frame.bind("<Enter>", lambda e: self.on_drop_zone_enter(e, link, index))
 232:         link_frame.bind("<Leave>", lambda e: self.on_drop_zone_leave(e, link, index))
 233:     
 234:     def show_link_context_menu(self, event, link, index):
 235:         """Show context menu for individual link"""
 236:         context_menu = tk.Menu(self, tearoff=0, bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 237:                               activebackground=Colors.HOVER_GREEN, activeforeground=Colors.WHITE)
 238:         
 239:         context_menu.add_command(label=f"Open {link['name']}", 
 240:                                 command=lambda: FileUtils.open_path(link['path'], self.parent))
 241:         context_menu.add_separator()
 242:         context_menu.add_command(label="Edit", 
 243:                                 command=lambda: self.edit_link(link, index))
 244:         context_menu.add_command(label="Delete", 
 245:                                 command=lambda: self.delete_link(link, index))
 246:         
 247:         try:
 248:             context_menu.tk_popup(event.x_root, event.y_root)
 249:         finally:
 250:             context_menu.grab_release()
 251:     
 252:     def edit_link(self, link, index):
 253:         """Edit an existing link"""
 254:         self.destroy()
 255:         AddEditLinkDialog.show_edit_dialog(self.parent, self.links_manager, self.taskbar_instance, link, index)
 256:     
 257:     def delete_link(self, link, index):
 258:         """Delete a link with confirmation"""
 259:         result = ConfirmationDialog.ask(
 260:             self.parent, 
 261:             "Delete Link", 
 262:             f"Are you sure you want to delete:\n'{link['name']}'?"
 263:         )
 264:         
 265:         if result:
 266:             self.links_manager.remove_link(index)
 267:             self.destroy()
 268:             # Refresh menu
 269:             self.taskbar_instance.show_links_menu(None)
 270:     
 271:     def add_new_link(self):
 272:         """Show dialog to add a new link"""
 273:         self.destroy()
 274:         AddEditLinkDialog.show_add_dialog(self.parent, self.links_manager, self.taskbar_instance)
 275:     
 276:     def setup_resize_functionality(self):
 277:         """Setup resize functionality with minimum size constraints"""
 278:         self.min_height = 150  # Minimum height
 279:         self.max_height = 600  # Maximum height for usability
 280:         
 281:         # Allow window to be resizable
 282:         self.resizable(False, True)  # Only allow vertical resizing
 283:     
 284:     def start_resize(self, event):
 285:         """Start resizing operation"""
 286:         self.is_resizing = True
 287:         self.resize_start_y = event.y_root
 288:         self.original_height = self.winfo_height()
 289:         self.original_x = self.winfo_x()
 290:         
 291:         # Update bottom position
 292:         self.bottom_y = self.winfo_y() + self.winfo_height()
 293:         
 294:         # Change cursor to indicate resizing
 295:         self.configure(cursor='sb_v_double_arrow')
 296:         
 297:         # Visual feedback
 298:         self.header_frame.configure(bg=Colors.HOVER_GREEN)
 299:         
 300:         print(f"Starting resize: height={self.original_height}, bottom_y={self.bottom_y}")
 301:     
 302:     def do_resize(self, event):
 303:         """Handle resize drag motion"""
 304:         if not self.is_resizing:
 305:             return
 306:         
 307:         # Calculate the change in Y position
 308:         delta_y = event.y_root - self.resize_start_y
 309:         
 310:         # Calculate new height (drag up = smaller delta = taller window)
 311:         new_height = self.original_height - delta_y
 312:         
 313:         # Apply constraints
 314:         new_height = max(self.min_height, min(self.max_height, new_height))
 315:         
 316:         # Calculate new Y position to keep bottom locked
 317:         new_y = self.bottom_y - new_height
 318:         
 319:         # Apply the new geometry
 320:         try:
 321:             self.geometry(f"{self.menu_width}x{int(new_height)}+{self.original_x}+{int(new_y)}")
 322:         except Exception as e:
 323:             print(f"Resize error: {e}")
 324:     
 325:     def end_resize(self, event):
 326:         """End resizing operation"""
 327:         self.is_resizing = False
 328:         self.configure(cursor='')
 329:         
 330:         # Remove visual feedback
 331:         self.header_frame.configure(bg=Colors.DARK_GREEN)
 332:         
 333:         # Update the stored height
 334:         self.menu_height = self.winfo_height()
 335:         
 336:         # Save the new height persistently
 337:         self.links_manager.set_menu_height(self.menu_height)
 338:         
 339:         print(f"Resize ended: new height={self.menu_height} (saved)")
 340:     
 341:     # Drag and Drop Event Handlers
 342:     def on_link_press(self, event, link, index):
 343:         """Handle mouse press on link - start potential drag or prepare for click"""
 344:         import time
 345:         self.drag_start_time = time.time() * 1000  # Convert to milliseconds
 346:         self.drag_start_x = event.x_root
 347:         self.drag_start_y = event.y_root
 348:         self.dragged_link_data = link
 349:         self.dragged_link_index = index
 350:         self.potential_drag = True
 351:         
 352:         # Schedule a delayed check for click vs drag
 353:         self.after(self.drag_time_threshold, lambda: self.check_for_click_or_drag(event, link, index))
 354:     
 355:     def on_link_drag(self, event, link, index):
 356:         """Handle mouse drag on link"""
 357:         if not hasattr(self, 'potential_drag') or not self.potential_drag:
 358:             return
 359:         
 360:         # Calculate distance moved
 361:         distance = ((event.x_root - self.drag_start_x) ** 2 + (event.y_root - self.drag_start_y) ** 2) ** 0.5
 362:         
 363:         if distance > self.drag_threshold:
 364:             self.start_link_drag(event, link, index)
 365:     
 366:     def on_link_release(self, event, link, index):
 367:         """Handle mouse release on link"""
 368:         if self.is_dragging_link:
 369:             self.end_link_drag(event, link, index)
 370:         elif hasattr(self, 'potential_drag') and self.potential_drag:
 371:             # This was a click, not a drag
 372:             self.handle_link_click(link)
 373:         
 374:         # Reset drag state
 375:         self.potential_drag = False
 376:         self.is_dragging_link = False
 377:     
 378:     def check_for_click_or_drag(self, event, link, index):
 379:         """Determine if this was a click or start of drag after delay"""
 380:         if hasattr(self, 'potential_drag') and self.potential_drag and not self.is_dragging_link:
 381:             # Still within time threshold and no drag started, treat as click
 382:             pass  # Let the release handler manage the click
 383:     
 384:     def handle_link_click(self, link):
 385:         """Handle regular link click to open file"""
 386:         FileUtils.open_path(link['path'], self.parent)
 387:         self.destroy()
 388:     
 389:     def start_link_drag(self, event, link, index):
 390:         """Start dragging a link"""
 391:         if self.is_dragging_link:
 392:             return
 393:         
 394:         self.is_dragging_link = True
 395:         self.potential_drag = False
 396:         
 397:         # Create drag visual
 398:         self.create_drag_visual(event, link)
 399:         
 400:         # Show drop indicators
 401:         self.show_drop_indicators()
 402:         
 403:         print(f"Started dragging: {link['name']}")
 404:     
 405:     def create_drag_visual(self, event, link):
 406:         """Create visual feedback for dragging"""
 407:         if self.drag_visual:
 408:             self.drag_visual.destroy()
 409:         
 410:         self.drag_visual = tk.Toplevel(self)
 411:         self.drag_visual.overrideredirect(True)
 412:         self.drag_visual.attributes('-topmost', True)
 413:         self.drag_visual.attributes('-alpha', 0.8)
 414:         
 415:         # Make drag visual ignore mouse events (so they pass through to drop zones)
 416:         try:
 417:             # This makes the window transparent to mouse events
 418:             self.drag_visual.attributes('-transparentcolor', 'black')  
 419:         except:
 420:             pass  # Not all systems support this
 421:         
 422:         # Create drag visual content
 423:         drag_frame = tk.Frame(self.drag_visual, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=2)
 424:         drag_frame.pack(padx=2, pady=2)
 425:         
 426:         tk.Label(drag_frame, text=f"🚀 {link['name']}", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 427:                 font=Fonts.MENU_ITEM, padx=10, pady=5).pack()
 428:         
 429:         # Position at cursor
 430:         self.drag_visual.geometry(f"+{event.x_root + 10}+{event.y_root + 10}")
 431:         
 432:         # Bind motion to follow cursor
 433:         self.bind("<Motion>", self.update_drag_visual)
 434:     
 435:     def update_drag_visual(self, event):
 436:         """Update drag visual position"""
 437:         if self.drag_visual and self.is_dragging_link:
 438:             self.drag_visual.geometry(f"+{event.x_root + 10}+{event.y_root + 10}")
 439:     
 440:     def show_drop_indicators(self):
 441:         """Show visual indicators for valid drop zones"""
 442:         # This would highlight valid drop areas
 443:         # For now, we'll rely on hover effects in the drop zone handlers
 444:         pass
 445:     
 446:     def end_link_drag(self, event, link, index):
 447:         """End link drag operation"""
 448:         print(f"Ending drag for: {link['name']}")
 449:         
 450:         # Try to find drop target at current mouse position
 451:         drop_target = self.find_drop_target_at_position(event.x_root, event.y_root)
 452:         
 453:         if drop_target:
 454:             print(f"Found drop target: {drop_target}")
 455:             self.current_drop_target = drop_target
 456:             self.perform_drop_operation()
 457:         else:
 458:             print("No valid drop target found")
 459:         
 460:         self.is_dragging_link = False
 461:         
 462:         # Clean up drag visual
 463:         if self.drag_visual:
 464:             self.drag_visual.destroy()
 465:             self.drag_visual = None
 466:         
 467:         # Unbind motion events
 468:         self.unbind("<Motion>")
 469:         
 470:         # Hide drop indicators
 471:         self.hide_drop_indicators()
 472:         
 473:         print(f"Ended dragging: {link['name']}")
 474:     
 475:     def hide_drop_indicators(self):
 476:         """Hide drop zone indicators"""
 477:         # Clean up any drop indicators
 478:         for indicator in self.drop_indicators:
 479:             try:
 480:                 indicator.destroy()
 481:             except:
 482:                 pass
 483:         self.drop_indicators.clear()
 484:     
 485:     # Drop Zone Event Handlers
 486:     def on_drop_zone_enter(self, event, link, index):
 487:         """Handle mouse entering a link drop zone"""
 488:         if self.is_dragging_link and self.dragged_link_index != index:
 489:             event.widget.configure(bg=Colors.HOVER_GREEN)
 490:             self.current_drop_target = {'type': 'reorder', 'link': link, 'index': index}
 491:     
 492:     def on_drop_zone_leave(self, event, link, index):
 493:         """Handle mouse leaving a link drop zone"""
 494:         if self.is_dragging_link:
 495:             event.widget.configure(bg=Colors.LIGHT_GREEN)
 496:             if hasattr(self, 'current_drop_target'):
 497:                 delattr(self, 'current_drop_target')
 498:     
 499:     def on_category_drop_zone_enter(self, event, category):
 500:         """Handle mouse entering a category drop zone"""
 501:         if self.is_dragging_link and self.dragged_link_data['category'] != category:
 502:             event.widget.configure(bg=Colors.MEDIUM_GREEN)
 503:             self.current_drop_target = {'type': 'move', 'category': category}
 504:     
 505:     def on_category_drop_zone_leave(self, event, category):
 506:         """Handle mouse leaving a category drop zone"""
 507:         if self.is_dragging_link:
 508:             event.widget.configure(bg=Colors.LIGHT_GREEN)
 509:             if hasattr(self, 'current_drop_target'):
 510:                 delattr(self, 'current_drop_target')
 511:     
 512:     def on_empty_category_enter(self, event, category):
 513:         """Handle mouse entering an empty category"""
 514:         if self.is_dragging_link and self.dragged_link_data['category'] != category:
 515:             event.widget.configure(bg=Colors.MEDIUM_GREEN)
 516:             self.current_drop_target = {'type': 'move', 'category': category}
 517:     
 518:     def on_empty_category_leave(self, event, category):
 519:         """Handle mouse leaving an empty category"""
 520:         if self.is_dragging_link:
 521:             event.widget.configure(bg=Colors.LIGHT_GREEN)
 522:             if hasattr(self, 'current_drop_target'):
 523:                 delattr(self, 'current_drop_target')
 524:     
 525:     def perform_drop_operation(self):
 526:         """Perform the actual drop operation based on current target"""
 527:         print(f"Performing drop operation...")
 528:         
 529:         if not hasattr(self, 'current_drop_target'):
 530:             print("No current_drop_target found")
 531:             return False
 532:             
 533:         if not self.dragged_link_data or self.dragged_link_index is None:
 534:             print("No dragged link data found")
 535:             return False
 536:         
 537:         target = self.current_drop_target
 538:         success = False
 539:         
 540:         print(f"Drop target: {target}")
 541:         print(f"Dragged link: {self.dragged_link_data['name']} (index: {self.dragged_link_index})")
 542:         
 543:         if target['type'] == 'move':
 544:             # Move to different category
 545:             print(f"Attempting to move to category: {target['category']}")
 546:             success = self.links_manager.move_link_to_category(self.dragged_link_index, target['category'])
 547:             if success:
 548:                 print(f"✅ Moved '{self.dragged_link_data['name']}' to category '{target['category']}'")
 549:             else:
 550:                 print(f"❌ Failed to move '{self.dragged_link_data['name']}' to category '{target['category']}'")
 551:         
 552:         elif target['type'] == 'reorder':
 553:             # Reorder within same category
 554:             dragged_category = self.dragged_link_data['category']
 555:             dragged_pos = self.links_manager.get_link_position_in_category(self.dragged_link_index)
 556:             target_pos = self.links_manager.get_link_position_in_category(target['index'])
 557:             
 558:             print(f"Attempting to reorder in category: {dragged_category}")
 559:             print(f"From position {dragged_pos} to position {target_pos}")
 560:             
 561:             if dragged_pos != -1 and target_pos != -1:
 562:                 success = self.links_manager.reorder_links_in_category(dragged_category, dragged_pos, target_pos)
 563:                 if success:
 564:                     print(f"✅ Reordered '{self.dragged_link_data['name']}' in category '{dragged_category}'")
 565:                 else:
 566:                     print(f"❌ Failed to reorder '{self.dragged_link_data['name']}' in category '{dragged_category}'")
 567:             else:
 568:                 print(f"❌ Invalid positions: dragged_pos={dragged_pos}, target_pos={target_pos}")
 569:         
 570:         if success:
 571:             # Refresh the menu to show changes
 572:             print("Refreshing menu...")
 573:             self.refresh_menu()
 574:         else:
 575:             print("Drop operation failed")
 576:         
 577:         return success
 578:     
 579:     def refresh_menu(self):
 580:         """Refresh the menu display after drag and drop operations"""
 581:         # Store current position
 582:         current_x = self.winfo_x()
 583:         current_y = self.winfo_y()
 584:         current_height = self.winfo_height()
 585:         
 586:         # Recreate the column layout
 587:         for widget in self.content_frame.winfo_children():
 588:             widget.destroy()
 589:         
 590:         self.create_column_layout()
 591:         
 592:         # Restore position and size
 593:         self.geometry(f"{self.menu_width}x{current_height}+{current_x}+{current_y}")
 594:         
 595:         print("Menu refreshed after drag and drop")
 596:     
 597:     def find_drop_target_at_position(self, x, y):
 598:         """Find what widget/drop target is at the given screen coordinates"""
 599:         try:
 600:             # Get widget at position relative to this window
 601:             widget_at_pos = self.winfo_containing(x, y)
 602:             
 603:             if not widget_at_pos:
 604:                 return None
 605:                 
 606:             print(f"Widget at position: {widget_at_pos}")
 607:             
 608:             # Check if it's a link (for reordering)
 609:             if hasattr(widget_at_pos, 'link_data') and hasattr(widget_at_pos, 'link_index'):
 610:                 link_data = widget_at_pos.link_data
 611:                 link_index = widget_at_pos.link_index
 612:                 
 613:                 # Don't allow dropping on self
 614:                 if link_index == self.dragged_link_index:
 615:                     return None
 616:                     
 617:                 return {
 618:                     'type': 'reorder', 
 619:                     'link': link_data, 
 620:                     'index': link_index
 621:                 }
 622:             
 623:             # Check if it's a category area (for moving to different category)
 624:             if hasattr(widget_at_pos, 'category'):
 625:                 category = widget_at_pos.category
 626:                 
 627:                 # Don't allow dropping in same category (unless it's for reordering)
 628:                 if category != self.dragged_link_data['category']:
 629:                     return {
 630:                         'type': 'move', 
 631:                         'category': category
 632:                     }
 633:             
 634:             # Check parent widgets for category info
 635:             parent = widget_at_pos
 636:             while parent and parent != self:
 637:                 if hasattr(parent, 'category'):
 638:                     category = parent.category
 639:                     if category != self.dragged_link_data['category']:
 640:                         return {
 641:                             'type': 'move', 
 642:                             'category': category
 643:                         }
 644:                 parent = parent.master
 645:                 
 646:             return None
 647:             
 648:         except Exception as e:
 649:             print(f"Error finding drop target: {e}")
 650:             return None
 651: 
 652: class AddEditLinkDialog(CustomDialog):
 653:     """Dialog for adding or editing links"""
 654:     
 655:     def __init__(self, parent, links_manager, taskbar_instance, edit_mode=False, link_data=None, link_index=None):
 656:         title = "Edit Link" if edit_mode else "Add New Link"
 657:         super().__init__(parent, title, width=450, height=280)
 658:         
 659:         self.links_manager = links_manager
 660:         self.taskbar_instance = taskbar_instance
 661:         self.edit_mode = edit_mode
 662:         self.link_data = link_data
 663:         self.link_index = link_index
 664:         
 665:         self.create_form()
 666:         self.add_buttons()
 667:         
 668:         # Prefill data if editing
 669:         if edit_mode and link_data:
 670:             self.name_field.set(link_data['name'])
 671:             self.path_field.set(link_data['path'])
 672:             self.category_field.set(link_data['category'])
 673:     
 674:     def create_form(self):
 675:         """Create the form fields"""
 676:         # Name field
 677:         self.name_field = FormField(self.dialog_content, "Name:", width=35)
 678:         self.name_field.pack(fill=tk.X, pady=5)
 679:         
 680:         # Path field with browse button
 681:         path_frame = tk.Frame(self.dialog_content, bg=Colors.LIGHT_GREEN)
 682:         path_frame.pack(fill=tk.X, pady=5)
 683:         
 684:         self.path_field = FormField(path_frame, "Path/URL:", width=25)
 685:         self.path_field.pack(side=tk.LEFT, fill=tk.X, expand=True)
 686:         
 687:         browse_btn = tk.Button(path_frame, text="Browse...", command=self.browse_path,
 688:                               bg=Colors.MEDIUM_GREEN, font=Fonts.DIALOG_LABEL)
 689:         browse_btn.pack(side=tk.RIGHT, padx=(5, 0))
 690:         
 691:         # Category field
 692:         self.category_field = FormField(
 693:             self.dialog_content, "Category:", 
 694:             field_type='combobox',
 695:             values=self.links_manager.get_categories(),
 696:         )
 697:         self.category_field.pack(fill=tk.X, pady=5)
 698:         
 699:         # Set default category to "Quick Links"
 700:         categories = self.links_manager.get_categories()
 701:         if "Quick Links" in categories:
 702:             self.category_field.set("Quick Links")
 703:         elif categories:
 704:             self.category_field.set(categories[0])
 705:     
 706:     def browse_path(self):
 707:         """Browse for file or folder"""
 708:         import os
 709:         
 710:         self.grab_release()
 711:         choice = BrowseChoiceDialog.ask(self)
 712:         
 713:         if choice == "file":
 714:             path = filedialog.askopenfilename(parent=self)
 715:         elif choice == "folder":
 716:             path = filedialog.askdirectory(parent=self)
 717:         else:
 718:             # Restore grab and focus when canceling
 719:             self.grab_set()
 720:             self.focus_force()
 721:             return
 722:         
 723:         if path:
 724:             self.path_field.set(path)
 725:             
 726:             # Auto-populate name field if it's empty
 727:             if not self.name_field.get().strip():
 728:                 if choice == "file":
 729:                     # Extract filename without extension
 730:                     filename = os.path.basename(path)
 731:                     name_without_ext = os.path.splitext(filename)[0]
 732:                     self.name_field.set(name_without_ext)
 733:                 elif choice == "folder":
 734:                     # Extract folder name
 735:                     folder_name = os.path.basename(path.rstrip(os.sep))
 736:                     self.name_field.set(folder_name)
 737:         
 738:         # Always restore grab and focus after browse operation
 739:         self.grab_set()
 740:         self.focus_force()
 741:     
 742:     def add_buttons(self):
 743:         """Add Save and Cancel buttons"""
 744:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 745:         button_container.pack(expand=True)
 746:         
 747:         save_btn = tk.Button(button_container, text="Save", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 748:                             command=self.save_link, width=Dimensions.DIALOG_BUTTON_WIDTH,
 749:                             font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 750:         save_btn.pack(side=tk.LEFT, padx=10)
 751:         
 752:         cancel_btn = tk.Button(button_container, text="Cancel", bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 753:                               command=self.cancel, width=Dimensions.DIALOG_BUTTON_WIDTH,
 754:                               font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 755:         cancel_btn.pack(side=tk.LEFT, padx=10)
 756:     
 757:     def save_link(self):
 758:         """Save the link"""
 759:         name = self.name_field.get().strip()
 760:         path = self.path_field.get().strip()
 761:         category = self.category_field.get()
 762:         
 763:         if not name or not path:
 764:             WarningDialog.show(self, "Invalid Input", "Please enter both name and path.")
 765:             return
 766:         
 767:         if self.edit_mode:
 768:             # Update existing link
 769:             icon = self.link_data.get('icon', '📄') if self.link_data else '📄'
 770:             success = self.links_manager.update_link(self.link_index, name, path, category, icon)
 771:         else:
 772:             # Add new link
 773:             success = self.links_manager.add_link(name, path, category)
 774:         
 775:         if success:
 776:             self.destroy()
 777:             # Refresh menu
 778:             self.taskbar_instance.show_links_menu(None)
 779:         else:
 780:             ErrorDialog.show(self, "Error", "Failed to save link.")
 781:     
 782:     @classmethod
 783:     def show_add_dialog(cls, parent, links_manager, taskbar_instance):
 784:         """Show dialog to add a new link"""
 785:         dialog = cls(parent, links_manager, taskbar_instance)
 786:         dialog.lift()
 787:         dialog.focus_force()
 788:         return dialog
 789:     
 790:     @classmethod
 791:     def show_edit_dialog(cls, parent, links_manager, taskbar_instance, link_data, link_index):
 792:         """Show dialog to edit an existing link"""
 793:         dialog = cls(parent, links_manager, taskbar_instance, True, link_data, link_index)
 794:         dialog.lift()
 795:         dialog.focus_force()
 796:         return dialog
 797: 
 798: class BrowseChoiceDialog(CustomDialog):
 799:     """Custom dialog for choosing between file or folder browsing"""
 800:     
 801:     def __init__(self, parent):
 802:         super().__init__(parent, "Browse Options", width=300, height=180)
 803:         
 804:         # Icon and message
 805:         icon_label = tk.Label(self.dialog_content, text="📁", bg=Colors.LIGHT_GREEN,
 806:                              fg=Colors.BLACK, font=('Arial', 24))
 807:         icon_label.pack(pady=10)
 808:         
 809:         message_label = tk.Label(self.dialog_content, text="What would you like to browse for?", 
 810:                                bg=Colors.LIGHT_GREEN, fg=Colors.BLACK, font=Fonts.DIALOG_LABEL)
 811:         message_label.pack(pady=5)
 812:         
 813:         # Add buttons
 814:         self.add_choice_buttons()
 815:         
 816:         # Bind keys
 817:         self.bind('<Escape>', lambda e: self.cancel())
 818:     
 819:     def add_choice_buttons(self):
 820:         """Add File, Folder, and Cancel buttons"""
 821:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 822:         button_container.pack(expand=True)
 823:         
 824:         # File button
 825:         file_btn = tk.Button(button_container, text="File", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 826:                            command=self.choose_file, width=8,
 827:                            font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 828:         file_btn.pack(side=tk.LEFT, padx=5)
 829:         
 830:         # Folder button
 831:         folder_btn = tk.Button(button_container, text="Folder", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 832:                              command=self.choose_folder, width=8,
 833:                              font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 834:         folder_btn.pack(side=tk.LEFT, padx=5)
 835:         
 836:         # Cancel button
 837:         cancel_btn = tk.Button(button_container, text="Cancel", bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 838:                              command=self.cancel, width=8,
 839:                              font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 840:         cancel_btn.pack(side=tk.LEFT, padx=5)
 841:         
 842:         # Focus on File button as default
 843:         file_btn.focus_set()
 844:     
 845:     def choose_file(self):
 846:         """File button clicked"""
 847:         self.result = "file"
 848:         self.destroy()
 849:     
 850:     def choose_folder(self):
 851:         """Folder button clicked"""
 852:         self.result = "folder"
 853:         self.destroy()
 854:     
 855:     @classmethod
 856:     def ask(cls, parent):
 857:         """Show browse choice dialog and return result"""
 858:         dialog = cls(parent)
 859:         dialog.lift()
 860:         dialog.focus_force()
 861:         try:
 862:             parent.wait_window(dialog)
 863:             return dialog.result
 864:         finally:
 865:             # Ensure parent regains focus after dialog closes
 866:             if parent and parent.winfo_exists():
 867:                 parent.focus_force()

────────────────────────────────────────────────────────────────────────────────
FILE: restore_deskop.py
────────────────────────────────────────────────────────────────────────────────
Path: restore_deskop.py
Size: 1.5 KB
Lines: 41 total, 33 non-empty
Characters: 1,488
Type: Desktop restoration utilities
────────────────────────────────────────────────────────────────────────────────

   1: import ctypes
   2: from ctypes import wintypes
   3: import time
   4: 
   5: def fix_desktop_space():
   6:     """Force restore desktop working area"""
   7:     user32 = ctypes.windll.user32
   8:     
   9:     # Method 1: Get actual screen size and restore
  10:     screen_width = user32.GetSystemMetrics(0)
  11:     screen_height = user32.GetSystemMetrics(1)
  12:     
  13:     print(f"Screen size: {screen_width}x{screen_height}")
  14:     
  15:     # Method 2: Force full screen work area
  16:     full_area = wintypes.RECT(0, 0, screen_width, screen_height)
  17:     result = user32.SystemParametersInfoW(0x002F, 0, ctypes.byref(full_area), 0)
  18:     print(f"Full restore attempt: {'Success' if result else 'Failed'}")
  19:     
  20:     # Method 3: Broadcast change to all windows
  21:     HWND_BROADCAST = 0xFFFF
  22:     WM_SETTINGCHANGE = 0x001A
  23:     user32.SendMessageW(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0)
  24:     
  25:     # Method 4: Try with SPIF_SENDCHANGE flag
  26:     SPIF_SENDCHANGE = 0x0002
  27:     SPIF_UPDATEINIFILE = 0x0001
  28:     result2 = user32.SystemParametersInfoW(0x002F, 0, ctypes.byref(full_area), SPIF_SENDCHANGE | SPIF_UPDATEINIFILE)
  29:     print(f"Restore with flags: {'Success' if result2 else 'Failed'}")
  30:     
  31:     # Method 5: Explorer restart (most aggressive)
  32:     print("\nRestarting Explorer to force refresh...")
  33:     import os
  34:     os.system("taskkill /f /im explorer.exe")
  35:     time.sleep(1)
  36:     os.system("start explorer.exe")
  37: 
  38: if __name__ == "__main__":
  39:     fix_desktop_space()
  40:     print("\nDesktop space should be restored!")
  41:     print("If not, try logging out and back in.")

────────────────────────────────────────────────────────────────────────────────
FILE: simple_window_factory.py
────────────────────────────────────────────────────────────────────────────────
Path: simple_window_factory.py
Size: 44.3 KB
Lines: 1093 total, 882 non-empty
Characters: 44,267
Type: Comprehensive window factory with filtering, simple windows, inventory views, and dialogs
────────────────────────────────────────────────────────────────────────────────

   1: # simple_window_factory.py
   2: """
   3: Window Factory - Creates custom windows with green styling and advanced functionality
   4: Includes simple windows, inventory view windows, and dialog components
   5: Using inheritance approach for cleaner API
   6: """
   7: 
   8: import tkinter as tk
   9: from tkinter import ttk, messagebox
  10: from datetime import datetime
  11: from typing import Any
  12: 
  13: # Import config components (with fallback if not available)
  14: try:
  15:     from config import Colors, Fonts, Dimensions
  16: except ImportError:
  17:     # Fallback colors/fonts if config not available
  18:     class Colors:
  19:         DARK_GREEN = "#2d5a2d"
  20:         LIGHT_GREEN = "#e8f5e8"
  21:         MEDIUM_GREEN = "#4a7c4a"
  22:         HOVER_GREEN = "#3d6a3d"
  23:         BLACK = "#000000"
  24:         WHITE = "#ffffff"
  25:         INACTIVE_GRAY = "#666666"
  26:     
  27:     class Fonts:
  28:         DIALOG_TITLE = ("Arial", 12, "bold")
  29:         DIALOG_LABEL = ("Arial", 10)
  30:         DIALOG_BUTTON = ("Arial", 10)
  31:         MENU_HEADER = ("Arial", 10, "bold")
  32:         MENU_ITEM = ("Arial", 9)
  33:     
  34:     class Dimensions:
  35:         DIALOG_BUTTON_WIDTH = 10
  36: 
  37: # No longer need to import CustomDialog since FilterMenuDialog now uses SimpleWindow
  38: 
  39: class SimpleWindow(tk.Toplevel):
  40:     def __init__(self, parent, title="Window", resize_handles=None):
  41:         """
  42:         Create a custom window with green styling
  43:         
  44:         Args:
  45:             parent: Parent window (required)
  46:             title: Window title text
  47:             resize_handles: List of sides that can be resized 
  48:                           ["left", "right", "top", "bottom"] or None for no resizing
  49:         """
  50:         # Initialize Toplevel
  51:         super().__init__(parent)
  52:         
  53:         # Remove default title bar
  54:         self.overrideredirect(True)
  55:         
  56:         # Store configuration
  57:         self.title_text = title
  58:         self.resize_handles = resize_handles or []
  59:         
  60:         # Colors - matching the mockup
  61:         self.border_color = "#2d5a2d"
  62:         self.header_bg = "#2d5a2d"
  63:         self.content_bg = "#e8f5e8"
  64:         self.text_color = "white"
  65:         self.border_width = 4
  66:         
  67: 
  68: 
  69:         # Window state
  70:         self._drag_start_x = 0
  71:         self._drag_start_y = 0
  72:         self._resize_start_x = 0
  73:         self._resize_start_y = 0
  74:         self._resize_start_width = 0
  75:         self._resize_start_height = 0
  76:         self._resizing = False
  77:         self._resize_side = None
  78:         
  79:         # Build the window
  80:         self._create_window()
  81:         
  82:     def _create_window(self):
  83:         """Build the window structure"""
  84:         # Configure window background
  85:         self.configure(bg=self.content_bg)
  86:         
  87:         # Main container with border
  88:         self.main_frame = tk.Frame(self, bg=self.border_color)
  89:         self.main_frame.pack(fill="both", expand=True)
  90:         
  91:         # Inner container
  92:         self.inner_frame = tk.Frame(self.main_frame, bg=self.content_bg)
  93:         self.inner_frame.place(x=self.border_width, y=self.border_width, 
  94:                               relwidth=1, relheight=1, 
  95:                               width=-2*self.border_width, 
  96:                               height=-2*self.border_width)
  97:         
  98:         # Header bar
  99:         self.header_frame = tk.Frame(self.inner_frame, bg=self.header_bg, height=32)
 100:         self.header_frame.pack(fill="x", side="top")
 101:         self.header_frame.pack_propagate(False)
 102:         
 103:         # Title label
 104:         self.title_label = tk.Label(self.header_frame, text=self.title_text, 
 105:                                    bg=self.header_bg, fg=self.text_color,
 106:                                    font=("Arial", 10), anchor="w")
 107:         self.title_label.pack(side="left", padx=8, fill="y")
 108:         
 109:         # Close button
 110:         self.close_button = tk.Button(self.header_frame, text="✕", 
 111:                                      bg=self.header_bg, fg=self.text_color,
 112:                                      font=("Arial", 12), bd=0,
 113:                                      activebackground=self.header_bg,
 114:                                      activeforeground=self.text_color,
 115:                                      command=self.close_window)
 116:         self.close_button.pack(side="right", padx=8)
 117:         
 118:         # Content area
 119:         self.content_frame = tk.Frame(self.inner_frame, bg=self.content_bg)
 120:         self.content_frame.pack(fill="both", expand=True)
 121:         
 122:         # Bind window dragging to header
 123:         self.header_frame.bind("<Button-1>", self._start_drag)
 124:         self.header_frame.bind("<B1-Motion>", self._drag_window)
 125:         self.title_label.bind("<Button-1>", self._start_drag)
 126:         self.title_label.bind("<B1-Motion>", self._drag_window)
 127:         
 128:         # Set up resize bindings
 129:         self._setup_resize_bindings()
 130:         
 131:     def _setup_resize_bindings(self):
 132:         """Set up mouse bindings for resizing"""
 133:         if not self.resize_handles:
 134:             return
 135:             
 136:         # Bind mouse motion to detect when over resize areas
 137:         self.bind("<Motion>", self._on_mouse_motion)
 138:         self.bind("<Button-1>", self._start_resize)
 139:         self.bind("<B1-Motion>", self._do_resize)
 140:         self.bind("<ButtonRelease-1>", self._stop_resize)
 141:         
 142:     def _on_mouse_motion(self, event):
 143:         """Change cursor when over resize areas"""
 144:         if self._resizing:
 145:             return
 146:             
 147:         x, y = event.x, event.y
 148:         width, height = self.winfo_width(), self.winfo_height()
 149:         
 150:         cursor = ""
 151:         if "left" in self.resize_handles and x < self.border_width:
 152:             cursor = "sb_h_double_arrow"
 153:         elif "right" in self.resize_handles and x > width - self.border_width:
 154:             cursor = "sb_h_double_arrow"
 155:         elif "top" in self.resize_handles and y < self.border_width:
 156:             cursor = "sb_v_double_arrow"
 157:         elif "bottom" in self.resize_handles and y > height - self.border_width:
 158:             cursor = "sb_v_double_arrow"
 159:         
 160:         self.config(cursor=cursor)
 161:         
 162:     def _start_resize(self, event):
 163:         """Start resizing if clicked on a resize area"""
 164:         x, y = event.x, event.y
 165:         width, height = self.winfo_width(), self.winfo_height()
 166:         
 167:         self._resize_side = None
 168:         if "left" in self.resize_handles and x < self.border_width:
 169:             self._resize_side = "left"
 170:         elif "right" in self.resize_handles and x > width - self.border_width:
 171:             self._resize_side = "right"
 172:         elif "top" in self.resize_handles and y < self.border_width:
 173:             self._resize_side = "top"
 174:         elif "bottom" in self.resize_handles and y > height - self.border_width:
 175:             self._resize_side = "bottom"
 176:             
 177:         if self._resize_side:
 178:             self._resizing = True
 179:             self._resize_start_x = event.x_root
 180:             self._resize_start_y = event.y_root
 181:             self._resize_start_width = width
 182:             self._resize_start_height = height
 183:             self._resize_start_left = self.winfo_x()
 184:             self._resize_start_top = self.winfo_y()
 185:             
 186:     def _do_resize(self, event):
 187:         """Perform the resize"""
 188:         if not self._resizing or not self._resize_side:
 189:             return
 190:             
 191:         dx = event.x_root - self._resize_start_x
 192:         dy = event.y_root - self._resize_start_y
 193:         
 194:         if self._resize_side == "left":
 195:             new_width = self._resize_start_width - dx
 196:             new_x = self._resize_start_left + dx
 197:             if new_width > 100:  # Minimum width
 198:                 self.geometry(f"{new_width}x{self._resize_start_height}+{new_x}+{self._resize_start_top}")
 199:                 
 200:         elif self._resize_side == "right":
 201:             new_width = self._resize_start_width + dx
 202:             if new_width > 100:
 203:                 self.geometry(f"{new_width}x{self._resize_start_height}")
 204:                 
 205:         elif self._resize_side == "top":
 206:             new_height = self._resize_start_height - dy
 207:             new_y = self._resize_start_top + dy
 208:             if new_height > 100:  # Minimum height
 209:                 self.geometry(f"{self._resize_start_width}x{new_height}+{self._resize_start_left}+{new_y}")
 210:                 
 211:         elif self._resize_side == "bottom":
 212:             new_height = self._resize_start_height + dy
 213:             if new_height > 100:
 214:                 self.geometry(f"{self._resize_start_width}x{new_height}")
 215:                 
 216:     def _stop_resize(self, event):
 217:         """Stop resizing"""
 218:         self._resizing = False
 219:         self._resize_side = None
 220:         
 221:     def _start_drag(self, event):
 222:         """Start dragging the window"""
 223:         self._drag_start_x = event.x_root
 224:         self._drag_start_y = event.y_root
 225:         
 226:     def _drag_window(self, event):
 227:         """Drag the window"""
 228:         x = self.winfo_x() + (event.x_root - self._drag_start_x)
 229:         y = self.winfo_y() + (event.y_root - self._drag_start_y)
 230:         self.geometry(f"+{x}+{y}")
 231:         self._drag_start_x = event.x_root
 232:         self._drag_start_y = event.y_root
 233:         
 234:     def close_window(self):
 235:         """Close the window"""
 236:         self.destroy()
 237:         
 238:     def get_content_frame(self):
 239:         """Return the content frame for adding widgets"""
 240:         return self.content_frame
 241: 
 242: 
 243: class InventoryViewWindow(tk.Toplevel):
 244:     """
 245:     Reusable interactive window for viewing any tabular data with Excel-like filtering
 246:     
 247:     Args:
 248:         parent: Parent window
 249:         data: List of dictionaries containing the data to display
 250:         window_config: Configuration dictionary with:
 251:             - title: Window title (default: "Data View")
 252:             - columns: List of column configurations, each with:
 253:                 - key: Dictionary key for this column
 254:                 - header: Display name for column header
 255:                 - width: Column width (default: 100)
 256:                 - type: Data type ('text', 'number', 'date') for sorting (default: 'text')
 257:             - on_item_click: Callback function(item) when item is clicked
 258:             - on_item_double_click: Callback function(item) when item is double-clicked
 259:             - show_stats: Whether to show statistics (default: True)
 260:             - allow_export: Whether to allow Excel export (default: True)
 261:             - window_width: Initial window width (default: 1000)
 262:             - window_height: Initial window height (default: 700)
 263:             - additional_info: Dict of additional info to display in header
 264:     """
 265:     
 266:     def __init__(self, parent, data: list[dict[str, Any]], window_config: dict | None = None):
 267:         super().__init__(parent)
 268:         self.parent = parent
 269:         self.original_data = data.copy() if data else []
 270:         self.filtered_data = self.original_data.copy()
 271:         
 272:         # Parse configuration
 273:         config = window_config or {}
 274:         self.window_title = config.get('title', 'Data View')
 275:         self.column_configs = config.get('columns', self._auto_generate_columns())
 276:         self.on_item_click = config.get('on_item_click')
 277:         self.on_item_double_click = config.get('on_item_double_click')
 278:         self.show_stats = config.get('show_stats', True)
 279:         self.allow_export = config.get('allow_export', True)
 280:         self.window_width = config.get('window_width', 1000)
 281:         self.window_height = config.get('window_height', 700)
 282:         self.additional_info = config.get('additional_info', {})
 283:         
 284:         # Extract column information
 285:         self.columns = [col['key'] for col in self.column_configs]
 286:         self.column_headers = {col['key']: col.get('header', col['key']) for col in self.column_configs}
 287:         self.column_widths = {col['key']: col.get('width', 100) for col in self.column_configs}
 288:         self.column_types = {col['key']: col.get('type', 'text') for col in self.column_configs}
 289:         
 290:         # Filter state tracking
 291:         self.active_filters = {}
 292:         self.column_unique_values = {}
 293:         
 294:         # Window setup
 295:         self.overrideredirect(True)
 296:         self.configure(bg=Colors.DARK_GREEN)
 297:         self.attributes('-topmost', True)
 298:         self.geometry(f"{self.window_width}x{self.window_height}")
 299:         
 300:         # Initialize drag variables
 301:         self.is_dragging = False
 302:         self.drag_start_x = 0
 303:         self.drag_start_y = 0
 304:         
 305:         # Main container
 306:         self.main_frame = tk.Frame(self, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=2)
 307:         self.main_frame.pack(fill=tk.BOTH, expand=True, padx=3, pady=3)
 308:         
 309:         # Create UI components
 310:         self.create_custom_title_bar()
 311:         self.content_frame = tk.Frame(self.main_frame, bg=Colors.LIGHT_GREEN)
 312:         self.content_frame.pack(fill=tk.BOTH, expand=True)
 313:         
 314:         self.create_header()
 315:         self.create_data_grid()
 316:         self.create_footer()
 317:         
 318:         # Populate and center
 319:         self.populate_grid()
 320:         self.update_stats()
 321:         self.center_window()
 322:         
 323:         # Bind close event
 324:         self.protocol("WM_DELETE_WINDOW", self.on_closing)
 325:     
 326:     def _auto_generate_columns(self) -> list[dict]:
 327:         """Auto-generate column configuration from data"""
 328:         if not self.original_data:
 329:             return []
 330:         
 331:         # Get all unique keys from data
 332:         all_keys = set()
 333:         for item in self.original_data:
 334:             all_keys.update(item.keys())
 335:         
 336:         # Create column config for each key
 337:         columns = []
 338:         for key in sorted(all_keys):
 339:             columns.append({
 340:                 'key': key,
 341:                 'header': key.replace('_', ' ').title(),
 342:                 'width': 150,
 343:                 'type': self._guess_column_type(key)
 344:             })
 345:         
 346:         return columns
 347:     
 348:     def _guess_column_type(self, key: str) -> str:
 349:         """Guess column type based on key name and sample data"""
 350:         key_lower = key.lower()
 351:         
 352:         # Check key name patterns
 353:         if any(word in key_lower for word in ['date', 'time', 'created', 'modified', 'updated']):
 354:             return 'date'
 355:         elif any(word in key_lower for word in ['count', 'number', 'size', 'bytes', 'id', 'qty', 'quantity']):
 356:             return 'number'
 357:         
 358:         # Check sample data
 359:         sample_values = []
 360:         for item in self.original_data[:10]:  # Check first 10 items
 361:             if key in item and item[key] is not None:
 362:                 sample_values.append(item[key])
 363:         
 364:         if sample_values:
 365:             # Check if all values are numeric
 366:             try:
 367:                 for val in sample_values:
 368:                     float(str(val).replace(',', ''))
 369:                 return 'number'
 370:             except:
 371:                 pass
 372:         
 373:         return 'text'
 374:     
 375:     def create_custom_title_bar(self):
 376:         """Create custom title bar matching other windows' style"""
 377:         self.title_frame = tk.Frame(self.main_frame, bg=Colors.DARK_GREEN, height=25)
 378:         self.title_frame.pack(fill=tk.X)
 379:         self.title_frame.pack_propagate(False)
 380:         
 381:         # Drag handle
 382:         drag_handle = tk.Label(self.title_frame, text="⋮⋮⋮", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 383:                               font=('Arial', 8), cursor='fleur')
 384:         drag_handle.pack(side=tk.LEFT, padx=3, pady=3)
 385:         
 386:         # Title with icon
 387:         icon = "📊" if "email" in self.window_title.lower() else "📁"
 388:         title_label = tk.Label(self.title_frame, text=f"{icon} {self.window_title}", 
 389:                               bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 390:                               font=Fonts.DIALOG_TITLE, cursor='fleur')
 391:         title_label.pack(side=tk.LEFT, padx=5, pady=3)
 392:         
 393:         # Close button
 394:         close_btn = tk.Label(self.title_frame, text="×", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 395:                             font=('Arial', 12, 'bold'), cursor='hand2')
 396:         close_btn.pack(side=tk.RIGHT, padx=5)
 397:         close_btn.bind("<Button-1>", lambda e: self.on_closing())
 398:         
 399:         # Bind drag events
 400:         for widget in [self.title_frame, drag_handle, title_label]:
 401:             widget.bind("<Button-1>", self.start_drag)
 402:             widget.bind("<B1-Motion>", self.do_drag)
 403:             widget.bind("<ButtonRelease-1>", self.end_drag)
 404:     
 405:     def create_header(self):
 406:         """Create header with information"""
 407:         header_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN, relief=tk.RAISED, bd=1)
 408:         header_frame.pack(fill=tk.X, padx=2, pady=2)
 409:         
 410:         # Title
 411:         title_label = tk.Label(header_frame, text=self.window_title, 
 412:                               bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 413:                               font=('Arial', 14, 'bold'))
 414:         title_label.pack(pady=5)
 415:         
 416:         # Additional information
 417:         if self.additional_info:
 418:             info_frame = tk.Frame(header_frame, bg=Colors.LIGHT_GREEN)
 419:             info_frame.pack(pady=5)
 420:             
 421:             col = 0
 422:             for key, value in self.additional_info.items():
 423:                 tk.Label(info_frame, text=f"{key}:", bg=Colors.LIGHT_GREEN, 
 424:                         fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).grid(row=0, column=col, sticky='w', padx=5)
 425:                 tk.Label(info_frame, text=str(value), bg=Colors.LIGHT_GREEN, 
 426:                         fg=Colors.DARK_GREEN, font=Fonts.DIALOG_LABEL).grid(row=0, column=col+1, sticky='w', padx=5)
 427:                 col += 2
 428:         
 429:         # Stats label
 430:         if self.show_stats:
 431:             self.stats_label = tk.Label(header_frame, text="", bg=Colors.LIGHT_GREEN, 
 432:                                        fg=Colors.BLACK, font=Fonts.DIALOG_LABEL)
 433:             self.stats_label.pack(pady=5)
 434:     
 435:     def create_data_grid(self):
 436:         """Create the main data grid with filtering"""
 437:         grid_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN, relief=tk.SUNKEN, bd=1)
 438:         grid_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
 439:         
 440:         # Create Treeview
 441:         self.tree = ttk.Treeview(grid_frame, show='tree headings')
 442:         self.tree['columns'] = self.columns
 443:         
 444:         # Configure columns
 445:         self.tree.column('#0', width=0, stretch=False)
 446:         self.tree.heading('#0', text='')
 447:         
 448:         for col in self.columns:
 449:             self.tree.column(col, width=self.column_widths.get(col, 100), anchor='w')
 450:             header_text = self.column_headers.get(col, col)
 451:             self.tree.heading(col, text=header_text, command=lambda c=col: self.show_filter_menu(c))
 452:         
 453:         # Scrollbars
 454:         v_scrollbar = ttk.Scrollbar(grid_frame, orient=tk.VERTICAL, command=self.tree.yview)
 455:         h_scrollbar = ttk.Scrollbar(grid_frame, orient=tk.HORIZONTAL, command=self.tree.xview)
 456:         self.tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
 457:         
 458:         # Pack components
 459:         self.tree.grid(row=0, column=0, sticky='nsew')
 460:         v_scrollbar.grid(row=0, column=1, sticky='ns')
 461:         h_scrollbar.grid(row=1, column=0, sticky='ew')
 462:         
 463:         grid_frame.grid_rowconfigure(0, weight=1)
 464:         grid_frame.grid_columnconfigure(0, weight=1)
 465:         
 466:         # Style
 467:         style = ttk.Style()
 468:         style.configure('Treeview', background=Colors.LIGHT_GREEN, 
 469:                        foreground=Colors.BLACK, fieldbackground=Colors.LIGHT_GREEN)
 470:         style.configure('Treeview.Heading', background=Colors.MEDIUM_GREEN,
 471:                        foreground=Colors.BLACK, font=Fonts.MENU_HEADER)
 472:         
 473:         # Bind click events
 474:         if self.on_item_click:
 475:             self.tree.bind('<ButtonRelease-1>', self._handle_item_click)
 476:         if self.on_item_double_click:
 477:             self.tree.bind('<Double-Button-1>', self._handle_item_double_click)
 478:     
 479:     def _handle_item_click(self, event):
 480:         """Handle single click on item with column detection"""
 481:         selection = self.tree.selection()
 482:         if selection and self.on_item_click:
 483:             item_id = selection[0]
 484:             item_index = self.tree.index(item_id)
 485:             
 486:             if 0 <= item_index < len(self.filtered_data):
 487:                 # Determine which column was clicked
 488:                 column_id = self.tree.identify_column(event.x)
 489:                 
 490:                 # Convert column id (#1, #2, etc.) to column index
 491:                 if column_id:
 492:                     try:
 493:                         col_index = int(column_id.replace('#', '')) - 1
 494:                         if 0 <= col_index < len(self.columns):
 495:                             column_key = self.columns[col_index]
 496:                             # Pass both item and column to callback
 497:                             if hasattr(self.on_item_click, '__code__') and self.on_item_click.__code__.co_argcount > 2:
 498:                                 # New style callback with column info
 499:                                 self.on_item_click(self.filtered_data[item_index], column_key)
 500:                             else:
 501:                                 # Old style callback without column info
 502:                                 self.on_item_click(self.filtered_data[item_index])
 503:                     except:
 504:                         # Fallback to just item
 505:                         self.on_item_click(self.filtered_data[item_index])
 506:     
 507:     def _handle_item_double_click(self, event):
 508:         """Handle double click on item"""
 509:         selection = self.tree.selection()
 510:         if selection and self.on_item_double_click:
 511:             item_id = selection[0]
 512:             item_index = self.tree.index(item_id)
 513:             if 0 <= item_index < len(self.filtered_data):
 514:                 self.on_item_double_click(self.filtered_data[item_index])
 515:     
 516:     def create_footer(self):
 517:         """Create footer with action buttons and filter status"""
 518:         footer_frame = tk.Frame(self.content_frame, bg=Colors.DARK_GREEN, height=50)
 519:         footer_frame.pack(fill=tk.X, side=tk.BOTTOM, padx=2, pady=2)
 520:         footer_frame.pack_propagate(False)
 521:         
 522:         # Filter status
 523:         filter_frame = tk.Frame(footer_frame, bg=Colors.DARK_GREEN)
 524:         filter_frame.pack(side=tk.LEFT, fill=tk.Y)
 525:         
 526:         self.filter_status_label = tk.Label(filter_frame, text="No filters applied", 
 527:                                            bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 528:                                            font=Fonts.MENU_ITEM)
 529:         self.filter_status_label.pack(side=tk.LEFT, padx=10, pady=5)
 530:         
 531:         # Action buttons
 532:         button_frame = tk.Frame(footer_frame, bg=Colors.DARK_GREEN)
 533:         button_frame.pack(side=tk.RIGHT, fill=tk.Y)
 534:         
 535:         # Clear Filters
 536:         clear_btn = tk.Button(button_frame, text="Clear All Filters", 
 537:                              bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 538:                              relief=tk.RAISED, bd=1, cursor='hand2',
 539:                              font=Fonts.MENU_ITEM, padx=10,
 540:                              command=self.clear_all_filters)
 541:         clear_btn.pack(side=tk.LEFT, padx=5, pady=5)
 542:         
 543:         # Export to Excel (if enabled)
 544:         if self.allow_export:
 545:             export_btn = tk.Button(button_frame, text="Export to Excel", 
 546:                                   bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 547:                                   relief=tk.RAISED, bd=1, cursor='hand2',
 548:                                   font=Fonts.MENU_ITEM, padx=10,
 549:                                   command=self.export_to_excel)
 550:             export_btn.pack(side=tk.LEFT, padx=5, pady=5)
 551:         
 552:         # Close button
 553:         close_btn = tk.Button(button_frame, text="Close", 
 554:                              bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 555:                              relief=tk.RAISED, bd=1, cursor='hand2',
 556:                              font=Fonts.MENU_ITEM, padx=10,
 557:                              command=self.on_closing)
 558:         close_btn.pack(side=tk.LEFT, padx=5, pady=5)
 559:     
 560:     def populate_grid(self):
 561:         """Populate the grid with current filtered data"""
 562:         # Clear existing items
 563:         for item in self.tree.get_children():
 564:             self.tree.delete(item)
 565:         
 566:         # Add filtered data
 567:         for item in self.filtered_data:
 568:             values = []
 569:             for col in self.columns:
 570:                 value = item.get(col, '')
 571:                 # Format based on type
 572:                 if self.column_types.get(col) == 'number' and value != '':
 573:                     try:
 574:                         # Format numbers with commas
 575:                         if isinstance(value, (int, float)):
 576:                             value = f"{value:,}"
 577:                     except:
 578:                         pass
 579:                 values.append(str(value))
 580:             
 581:             self.tree.insert('', 'end', values=values)
 582:         
 583:         # Calculate unique values
 584:         self.calculate_unique_values()
 585:     
 586:     def calculate_unique_values(self):
 587:         """Calculate unique values for each column from filtered data"""
 588:         self.column_unique_values = {}
 589:         
 590:         for col in self.columns:
 591:             unique_vals = set()
 592:             for item in self.filtered_data:
 593:                 val = item.get(col, '')
 594:                 if val != '':
 595:                     unique_vals.add(str(val))
 596:             self.column_unique_values[col] = sorted(list(unique_vals))
 597:     
 598:     def show_filter_menu(self, column):
 599:         """Show filter menu for a specific column"""
 600:         available_values = self.get_available_values_for_column(column)
 601:         FilterMenuDialog(self, column, self.column_headers.get(column, column),
 602:                         available_values, 
 603:                         self.active_filters.get(column, set()), 
 604:                         self.apply_filter)
 605:     
 606:     def get_available_values_for_column(self, column):
 607:         """Get all possible values for a column considering OTHER column filters"""
 608:         available_values = set()
 609:         
 610:         temp_filters = self.active_filters.copy()
 611:         if column in temp_filters:
 612:             del temp_filters[column]
 613:         
 614:         for item in self.original_data:
 615:             include_item = True
 616:             
 617:             for filter_col, filter_values in temp_filters.items():
 618:                 item_value = str(item.get(filter_col, ''))
 619:                 if item_value not in filter_values:
 620:                     include_item = False
 621:                     break
 622:             
 623:             if include_item:
 624:                 val = item.get(column, '')
 625:                 if val != '':
 626:                     available_values.add(str(val))
 627:         
 628:         return sorted(list(available_values))
 629:     
 630:     def apply_filter(self, column, selected_values):
 631:         """Apply filter to a specific column"""
 632:         if selected_values:
 633:             self.active_filters[column] = set(selected_values)
 634:         else:
 635:             if column in self.active_filters:
 636:                 del self.active_filters[column]
 637:         
 638:         self.filter_data()
 639:         self.update_display()
 640:         self.update_filter_status()
 641:         self.update_column_headers()
 642:     
 643:     def filter_data(self):
 644:         """Apply all active filters to the data"""
 645:         self.filtered_data = []
 646:         
 647:         for item in self.original_data:
 648:             include_item = True
 649:             
 650:             for filter_col, filter_values in self.active_filters.items():
 651:                 item_value = str(item.get(filter_col, ''))
 652:                 if item_value not in filter_values:
 653:                     include_item = False
 654:                     break
 655:             
 656:             if include_item:
 657:                 self.filtered_data.append(item)
 658:     
 659:     def update_display(self):
 660:         """Update the grid display with filtered data"""
 661:         self.populate_grid()
 662:         self.update_stats()
 663:     
 664:     def update_stats(self):
 665:         """Update the statistics display"""
 666:         if not self.show_stats or not hasattr(self, 'stats_label'):
 667:             return
 668:             
 669:         total_original = len(self.original_data)
 670:         total_filtered = len(self.filtered_data)
 671:         
 672:         if total_filtered == total_original:
 673:             stats_text = f"Total Items: {total_original:,}"
 674:         else:
 675:             stats_text = f"Showing: {total_filtered:,} of {total_original:,} items"
 676:         
 677:         self.stats_label.config(text=stats_text)
 678:     
 679:     def update_filter_status(self):
 680:         """Update the filter status display"""
 681:         if not self.active_filters:
 682:             self.filter_status_label.config(text="No filters applied")
 683:         else:
 684:             filter_count = len(self.active_filters)
 685:             filter_text = f"{filter_count} filter{'s' if filter_count > 1 else ''} applied"
 686:             self.filter_status_label.config(text=filter_text)
 687:     
 688:     def update_column_headers(self):
 689:         """Update column headers to show filter indicators"""
 690:         for col in self.columns:
 691:             header_text = self.column_headers.get(col, col)
 692:             if col in self.active_filters:
 693:                 self.tree.heading(col, text=f"{header_text} ▼")
 694:             else:
 695:                 self.tree.heading(col, text=header_text)
 696:     
 697:     def clear_all_filters(self):
 698:         """Clear all active filters"""
 699:         self.active_filters = {}
 700:         self.filtered_data = self.original_data.copy()
 701:         self.update_display()
 702:         self.update_filter_status()
 703:         self.update_column_headers()
 704:     
 705:     def export_to_excel(self):
 706:         """Export the current filtered data to Excel"""
 707:         try:
 708:             from openpyxl import Workbook
 709:             from openpyxl.styles import Font, PatternFill
 710:             import tempfile
 711:             import os
 712:             from datetime import datetime
 713:             
 714:             # Create workbook
 715:             wb = Workbook()
 716:             ws = wb.active
 717:             ws.title = "Data Export"
 718:             
 719:             # Header
 720:             ws['A1'] = self.window_title
 721:             ws['A1'].font = Font(bold=True, size=14)
 722:             ws['A2'] = f"Exported: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
 723:             ws['A3'] = f"Total Items: {len(self.filtered_data):,}"
 724:             
 725:             # Column headers
 726:             for col_idx, col_key in enumerate(self.columns, 1):
 727:                 cell = ws.cell(row=5, column=col_idx, value=self.column_headers.get(col_key, col_key))
 728:                 cell.font = Font(bold=True)
 729:                 cell.fill = PatternFill(start_color="90EE90", end_color="90EE90", fill_type="solid")
 730:             
 731:             # Data rows
 732:             for row_idx, item in enumerate(self.filtered_data, 6):
 733:                 for col_idx, col_key in enumerate(self.columns, 1):
 734:                     value = item.get(col_key, '')
 735:                     ws.cell(row=row_idx, column=col_idx, value=value)
 736:             
 737:             # Auto-adjust column widths
 738:             for column in ws.columns:
 739:                 max_length = 0
 740:                 column_letter = column[0].column_letter
 741:                 for cell in column:
 742:                     try:
 743:                         if len(str(cell.value)) > max_length:
 744:                             max_length = len(str(cell.value))
 745:                     except:
 746:                         pass
 747:                 adjusted_width = min(max_length + 2, 50)
 748:                 ws.column_dimensions[column_letter].width = adjusted_width
 749:             
 750:             # Save and open
 751:             temp_dir = tempfile.gettempdir()
 752:             timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
 753:             filename = f"{self.window_title.replace(' ', '_')}_{timestamp}.xlsx"
 754:             filepath = os.path.join(temp_dir, filename)
 755:             
 756:             wb.save(filepath)
 757:             os.startfile(filepath)
 758:             
 759:             messagebox.showinfo("Export Complete", f"Data exported to:\n{filepath}")
 760:             
 761:         except Exception as e:
 762:             messagebox.showerror("Export Error", f"Failed to export to Excel:\n{str(e)}")
 763:     
 764:     # Drag and window management methods
 765:     def start_drag(self, event):
 766:         """Start dragging the window"""
 767:         self.is_dragging = True
 768:         self.drag_start_x = event.x_root
 769:         self.drag_start_y = event.y_root
 770:         self.title_frame.configure(bg=Colors.HOVER_GREEN)
 771:     
 772:     def do_drag(self, event):
 773:         """Handle drag motion"""
 774:         if not self.is_dragging:
 775:             return
 776:         
 777:         delta_x = event.x_root - self.drag_start_x
 778:         delta_y = event.y_root - self.drag_start_y
 779:         
 780:         new_x = self.winfo_x() + delta_x
 781:         new_y = self.winfo_y() + delta_y
 782:         
 783:         self.geometry(f"+{new_x}+{new_y}")
 784:         
 785:         self.drag_start_x = event.x_root
 786:         self.drag_start_y = event.y_root
 787:     
 788:     def end_drag(self, event):
 789:         """End dragging operation"""
 790:         self.is_dragging = False
 791:         self.title_frame.configure(bg=Colors.DARK_GREEN)
 792:     
 793:     def center_window(self):
 794:         """Center the window on screen"""
 795:         self.update_idletasks()
 796:         width = self.winfo_width()
 797:         height = self.winfo_height()
 798:         x = (self.winfo_screenwidth() // 2) - (width // 2)
 799:         y = (self.winfo_screenheight() // 2) - (height // 2)
 800:         self.geometry(f"{width}x{height}+{x}+{y}")
 801:     
 802:     def on_closing(self):
 803:         """Handle window closing"""
 804:         self.destroy()
 805: 
 806: 
 807: class FilterMenuDialog(SimpleWindow):
 808:     """Dialog for selecting filter values for a column"""
 809:     
 810:     def __init__(self, parent, column_key, column_header, unique_values, current_selection, apply_callback):
 811:         super().__init__(parent, f"Filter: {column_header}", resize_handles=None)
 812:         
 813:         # Set window size
 814:         self.geometry("350x400")
 815:         
 816:         # Center on parent
 817:         self.update_idletasks()
 818:         if parent:
 819:             parent.update_idletasks()
 820:             x = parent.winfo_x() + (parent.winfo_width() - 350) // 2
 821:             y = parent.winfo_y() + (parent.winfo_height() - 400) // 2
 822:             self.geometry(f"350x400+{x}+{y}")
 823:         
 824:         # Set background color
 825:         self.content_frame.configure(bg=Colors.LIGHT_GREEN)
 826:         
 827:         self.column_key = column_key
 828:         self.column_header = column_header
 829:         self.unique_values = unique_values
 830:         self.current_selection = current_selection.copy()
 831:         self.apply_callback = apply_callback
 832:         self.parent_window = parent
 833:         
 834:         # Check if filter exists
 835:         self.has_existing_filter = column_key in parent.active_filters
 836:         
 837:         # Default to all selected if no current selection
 838:         if not self.current_selection and not self.has_existing_filter:
 839:             self.current_selection = set(unique_values)
 840:         
 841:         self.create_filter_interface()
 842:         self.create_action_buttons()
 843:     
 844:     def create_filter_interface(self):
 845:         """Create the filter selection interface"""
 846:         # Clear Filter button
 847:         if self.has_existing_filter:
 848:             clear_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
 849:             clear_frame.pack(fill=tk.X, pady=(0, 10), padx=10)
 850:             
 851:             clear_filter_btn = tk.Button(clear_frame, text="Clear Filter for This Column", 
 852:                                        bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 853:                                        command=self.clear_column_filter, 
 854:                                        font=Fonts.DIALOG_LABEL,
 855:                                        cursor='hand2', relief=tk.RAISED, bd=1)
 856:             clear_filter_btn.pack(pady=5)
 857:         
 858:         # Search box
 859:         search_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
 860:         search_frame.pack(fill=tk.X, pady=5, padx=10)
 861:         
 862:         tk.Label(search_frame, text="Search:", bg=Colors.LIGHT_GREEN, 
 863:                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL).pack(side=tk.LEFT)
 864:         
 865:         self.search_var = tk.StringVar()
 866:         self.search_var.trace('w', self.filter_list)
 867:         search_entry = tk.Entry(search_frame, textvariable=self.search_var, 
 868:                                font=Fonts.DIALOG_LABEL)
 869:         search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
 870:         
 871:         # Select All / None buttons
 872:         select_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
 873:         select_frame.pack(fill=tk.X, pady=5, padx=10)
 874:         
 875:         select_all_btn = tk.Button(select_frame, text="Select All", 
 876:                                   bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 877:                                   command=self.select_all, font=Fonts.DIALOG_LABEL)
 878:         select_all_btn.pack(side=tk.LEFT, padx=5)
 879:         
 880:         select_none_btn = tk.Button(select_frame, text="Select None", 
 881:                                    bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 882:                                    command=self.select_none, font=Fonts.DIALOG_LABEL)
 883:         select_none_btn.pack(side=tk.LEFT, padx=5)
 884:         
 885:         # Listbox with checkboxes
 886:         list_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
 887:         list_frame.pack(fill=tk.BOTH, expand=True, pady=5, padx=10)
 888:         
 889:         self.filter_tree = ttk.Treeview(list_frame, show='tree', height=12)
 890:         self.filter_tree.column('#0', width=300)
 891:         
 892:         filter_scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, 
 893:                                         command=self.filter_tree.yview)
 894:         self.filter_tree.configure(yscrollcommand=filter_scrollbar.set)
 895:         
 896:         self.filter_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
 897:         filter_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
 898:         
 899:         self.populate_filter_list()
 900:         
 901:         # Bind click events
 902:         self.filter_tree.bind('<Button-1>', self.on_click)
 903:         self.filter_tree.bind('<Return>', self.toggle_item)
 904:     
 905:     def clear_column_filter(self):
 906:         """Clear the filter for this specific column"""
 907:         self.apply_callback(self.column_key, [])
 908:         self.close_window()
 909:     
 910:     def on_click(self, event):
 911:         """Handle click on items"""
 912:         item = self.filter_tree.identify('item', event.x, event.y)
 913:         if item:
 914:             self.filter_tree.selection_set(item)
 915:             self.toggle_item()
 916:     
 917:     def populate_filter_list(self, search_text=""):
 918:         """Populate the filter list"""
 919:         for item in self.filter_tree.get_children():
 920:             self.filter_tree.delete(item)
 921:         
 922:         filtered_values = [val for val in self.unique_values 
 923:                           if search_text.lower() in val.lower()] if search_text else self.unique_values
 924:         
 925:         for value in filtered_values:
 926:             checkbox = "☑" if value in self.current_selection else "☐"
 927:             display_text = f"{checkbox} {value}"
 928:             self.filter_tree.insert('', 'end', text=display_text, values=[value])
 929:     
 930:     def filter_list(self, *args):
 931:         """Filter the list based on search"""
 932:         self.populate_filter_list(self.search_var.get())
 933:     
 934:     def toggle_item(self, event=None):
 935:         """Toggle selection of an item"""
 936:         selected_item = self.filter_tree.selection()
 937:         if not selected_item:
 938:             return
 939:         
 940:         item_id = selected_item[0]
 941:         values = self.filter_tree.item(item_id, 'values')
 942:         if values:
 943:             value = values[0]
 944:             
 945:             if value in self.current_selection:
 946:                 self.current_selection.remove(value)
 947:             else:
 948:                 self.current_selection.add(value)
 949:             
 950:             self.populate_filter_list(self.search_var.get())
 951:     
 952:     def select_all(self):
 953:         """Select all visible items"""
 954:         search_text = self.search_var.get()
 955:         filtered_values = [val for val in self.unique_values 
 956:                           if search_text.lower() in val.lower()] if search_text else self.unique_values
 957:         
 958:         for value in filtered_values:
 959:             self.current_selection.add(value)
 960:         
 961:         self.populate_filter_list(search_text)
 962:     
 963:     def select_none(self):
 964:         """Deselect all visible items"""
 965:         search_text = self.search_var.get()
 966:         filtered_values = [val for val in self.unique_values 
 967:                           if search_text.lower() in val.lower()] if search_text else self.unique_values
 968:         
 969:         for value in filtered_values:
 970:             self.current_selection.discard(value)
 971:         
 972:         self.populate_filter_list(search_text)
 973:     
 974:     def create_action_buttons(self):
 975:         """Create OK and Cancel buttons"""
 976:         button_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
 977:         button_frame.pack(side=tk.BOTTOM, pady=10, padx=10)
 978:         
 979:         button_container = tk.Frame(button_frame, bg=Colors.LIGHT_GREEN)
 980:         button_container.pack()
 981:         
 982:         ok_btn = tk.Button(button_container, text="OK", 
 983:                           bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 984:                           command=self.apply_filter, width=Dimensions.DIALOG_BUTTON_WIDTH,
 985:                           font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 986:         ok_btn.pack(side=tk.LEFT, padx=10)
 987:         
 988:         cancel_btn = tk.Button(button_container, text="Cancel", 
 989:                               bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 990:                               command=self.cancel, width=Dimensions.DIALOG_BUTTON_WIDTH,
 991:                               font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 992:         cancel_btn.pack(side=tk.LEFT, padx=10)
 993:         
 994:         ok_btn.focus_set()
 995:     
 996:     def apply_filter(self):
 997:         """Apply the selected filter"""
 998:         self.apply_callback(self.column_key, list(self.current_selection))
 999:         self.close_window()
1000:     
1001:     def cancel(self):
1002:         """Cancel without applying changes"""
1003:         self.close_window()
1004: 
1005: 
1006: # Factory functions
1007: def create_window(parent, title="Window", resize_handles=None):
1008:     """
1009:     Create a simple custom window
1010:     
1011:     Args:
1012:         parent: Parent window (required)
1013:         title: Window title
1014:         resize_handles: List of ["left", "right", "top", "bottom"] or None
1015:         
1016:     Returns:
1017:         SimpleWindow instance
1018:     """
1019:     return SimpleWindow(parent, title=title, resize_handles=resize_handles)
1020: 
1021: 
1022: def create_inventory_window(parent, data, window_config=None):
1023:     """
1024:     Create an inventory view window for displaying tabular data with filtering
1025:     
1026:     Args:
1027:         parent: Parent window (required)
1028:         data: List of dictionaries containing the data to display
1029:         window_config: Configuration dictionary (optional)
1030:         
1031:     Returns:
1032:         InventoryViewWindow instance
1033:     """
1034:     return InventoryViewWindow(parent, data, window_config)
1035: 
1036: 
1037: def create_filter_dialog(parent, column_key, column_header, unique_values, current_selection, apply_callback):
1038:     """
1039:     Create a filter dialog for column filtering
1040:     
1041:     Args:
1042:         parent: Parent window (required)
1043:         column_key: Key of the column being filtered
1044:         column_header: Display name of the column
1045:         unique_values: List of unique values for filtering
1046:         current_selection: Currently selected values
1047:         apply_callback: Callback function to apply filter
1048:         
1049:     Returns:
1050:         FilterMenuDialog instance
1051:     """
1052:     return FilterMenuDialog(parent, column_key, column_header, unique_values, current_selection, apply_callback)
1053: 
1054: 
1055: def create_data_view_window(parent, data, title="Data View", columns=None, **kwargs):
1056:     """
1057:     Create a data view window for displaying any tabular data with filtering
1058:     
1059:     Args:
1060:         parent: Parent window (required)
1061:         data: List of dictionaries containing the data to display
1062:         title: Window title
1063:         columns: List of column configurations (optional, auto-generated if not provided)
1064:         **kwargs: Additional configuration options for InventoryViewWindow
1065:         
1066:     Returns:
1067:         InventoryViewWindow instance
1068:     """
1069:     window_config = kwargs.copy()
1070:     window_config['title'] = title
1071:     if columns:
1072:         window_config['columns'] = columns
1073:     
1074:     return InventoryViewWindow(parent, data, window_config)
1075: 
1076: 
1077: # Example usage
1078: if __name__ == "__main__":
1079:     # Create root window
1080:     root = tk.Tk()
1081:     root.withdraw()  # Hide the root window
1082:     
1083:     # Create a window that can be resized from left and right
1084:     window = create_window(root, "Test Window", resize_handles=["left", "right"])
1085:     
1086:     # Add some content
1087:     label = tk.Label(window.get_content_frame(), 
1088:                     text="This window can be resized\nfrom the left and right edges",
1089:                     bg="#e8f5e8", fg="#2d5a2d")
1090:     label.pack(pady=20)
1091:     
1092:     # Start the app
1093:     root.mainloop()

────────────────────────────────────────────────────────────────────────────────
FILE: snip_feature.py
────────────────────────────────────────────────────────────────────────────────
Path: snip_feature.py
Size: 16.1 KB
Lines: 410 total, 331 non-empty
Characters: 16,062
Type: Screenshot and snipping functionality
────────────────────────────────────────────────────────────────────────────────

   1: # snip_feature.py
   2: """
   3: Screen capture and document integration feature for SuiteView Taskbar
   4: Handles taking screenshots and inserting them into Word documents or Outlook emails
   5: """
   6: 
   7: import os
   8: import tempfile
   9: import time
  10: from datetime import datetime
  11: from PIL import ImageGrab
  12: import win32com.client
  13: import pythoncom
  14: from config import Colors, Fonts
  15: from ui_components import ErrorDialog, WarningDialog
  16: import tkinter as tk
  17: 
  18: class SnippingManager:
  19:     """Manages screen capture and document integration"""
  20:     
  21:     def __init__(self, parent_window=None):
  22:         self.parent_window = parent_window
  23:         self.current_word_app = None
  24:         self.current_word_doc = None
  25:         self.current_outlook_app = None
  26:         self.current_outlook_item = None
  27:         self.temp_image_counter = 0
  28:         
  29:         # Create temp directory for screenshots
  30:         self.temp_dir = os.path.join(tempfile.gettempdir(), "SuiteView_Screenshots")
  31:         self.ensure_temp_directory()
  32:     
  33:     def ensure_temp_directory(self):
  34:         """Ensure temporary directory exists for storing screenshots"""
  35:         try:
  36:             if not os.path.exists(self.temp_dir):
  37:                 os.makedirs(self.temp_dir)
  38:         except Exception as e:
  39:             print(f"Warning: Could not create temp directory: {e}")
  40:             self.temp_dir = tempfile.gettempdir()
  41:     
  42:     def capture_primary_screen(self):
  43:         """Capture screenshot of primary monitor and save to temp file"""
  44:         try:
  45:             # Capture the primary screen
  46:             screenshot = ImageGrab.grab()
  47:             
  48:             # Generate unique filename
  49:             timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
  50:             self.temp_image_counter += 1
  51:             filename = f"screenshot_{timestamp}_{self.temp_image_counter}.png"
  52:             filepath = os.path.join(self.temp_dir, filename)
  53:             
  54:             # Save screenshot
  55:             screenshot.save(filepath, "PNG")
  56:             print(f"Screenshot saved: {filepath}")
  57:             return filepath
  58:             
  59:         except Exception as e:
  60:             self._show_error("Screenshot Error", f"Failed to capture screenshot: {str(e)}")
  61:             return None
  62:     
  63:     def snip_to_target(self, target_app="Word"):
  64:         """Main method to handle snipping to specified application"""
  65:         try:
  66:             # Capture screenshot first
  67:             image_path = self.capture_primary_screen()
  68:             if not image_path:
  69:                 return False
  70:             
  71:             # Route to appropriate handler
  72:             if target_app.lower() == "word":
  73:                 return self.snip_to_word(image_path)
  74:             elif target_app.lower() == "outlook":
  75:                 return self.snip_to_outlook(image_path)
  76:             else:
  77:                 self._show_error("Invalid Target", f"Unknown target application: {target_app}")
  78:                 return False
  79:                 
  80:         except Exception as e:
  81:             self._show_error("Snip Error", f"Failed to complete snip operation: {str(e)}")
  82:             return False
  83:     
  84:     def snip_to_word(self, image_path):
  85:         """Insert screenshot into Word document"""
  86:         try:
  87:             # Check if we have an active Word document
  88:             if not self._is_word_document_active():
  89:                 # Create new Word document
  90:                 if not self._create_new_word_document():
  91:                     return False
  92:             
  93:             # Insert image into document
  94:             if self._insert_image_to_word(image_path):
  95:                 print("Successfully added screenshot to Word document")
  96:                 return True
  97:             else:
  98:                 return False
  99:                 
 100:         except Exception as e:
 101:             self._show_error("Word Error", f"Failed to add screenshot to Word: {str(e)}")
 102:             return False
 103:     
 104:     def snip_to_outlook(self, image_path):
 105:         """Insert screenshot into Outlook email"""
 106:         try:
 107:             # Check if we have an active Outlook email
 108:             if not self._is_outlook_email_active():
 109:                 # Create new Outlook email
 110:                 if not self._create_new_outlook_email():
 111:                     return False
 112:             
 113:             # Insert image into email
 114:             if self._insert_image_to_outlook(image_path):
 115:                 print("Successfully added screenshot to Outlook email")
 116:                 return True
 117:             else:
 118:                 return False
 119:                 
 120:         except Exception as e:
 121:             self._show_error("Outlook Error", f"Failed to add screenshot to Outlook: {str(e)}")
 122:             return False
 123:     
 124:     def _is_word_document_active(self):
 125:         """Check if the current Word document is still active"""
 126:         try:
 127:             if not self.current_word_app or not self.current_word_doc:
 128:                 return False
 129:             
 130:             # Try to access the document - this will fail if it's closed
 131:             _ = self.current_word_doc.Name
 132:             
 133:             # Check if the document is still in the application's documents collection
 134:             for doc in self.current_word_app.Documents:
 135:                 if doc.Name == self.current_word_doc.Name:
 136:                     return True
 137:             
 138:             return False
 139:             
 140:         except Exception:
 141:             # If any error occurs, assume document is no longer active
 142:             self.current_word_doc = None
 143:             return False
 144:     
 145:     def _is_outlook_email_active(self):
 146:         """Check if the current Outlook email is still active"""
 147:         try:
 148:             if not self.current_outlook_app or not self.current_outlook_item:
 149:                 return False
 150:             
 151:             # Try to access the email item - this will fail if it's closed/sent
 152:             _ = self.current_outlook_item.Subject
 153:             return True
 154:             
 155:         except Exception:
 156:             # If any error occurs, assume email is no longer active
 157:             self.current_outlook_item = None
 158:             return False
 159:     
 160:     def _create_new_word_document(self):
 161:         """Create a new Word document"""
 162:         try:
 163:             # Initialize COM
 164:             pythoncom.CoInitialize()
 165:             
 166:             # Connect to or create Word application
 167:             try:
 168:                 self.current_word_app = win32com.client.GetActiveObject("Word.Application")
 169:             except:
 170:                 self.current_word_app = win32com.client.Dispatch("Word.Application")
 171:             
 172:             # Make Word visible
 173:             self.current_word_app.Visible = True
 174:             
 175:             # Create new document
 176:             self.current_word_doc = self.current_word_app.Documents.Add()
 177:             
 178:             # Add a title
 179:             title_range = self.current_word_doc.Range(0, 0)
 180:             title_range.Text = f"Screenshots - {datetime.now().strftime('%Y-%m-%d %I:%M %p')}\n\n"
 181:             title_range.Font.Bold = True
 182:             title_range.Font.Size = 14
 183:             
 184:             # Move cursor to end for image insertion
 185:             # Use numeric constant instead of named constant to avoid import issues
 186:             self.current_word_doc.Range().Collapse(0)  # 0 = wdCollapseEnd
 187:             
 188:             print("Created new Word document")
 189:             return True
 190:             
 191:         except Exception as e:
 192:             self._show_error("Word Creation Error", f"Failed to create Word document: {str(e)}")
 193:             self.current_word_app = None
 194:             self.current_word_doc = None
 195:             return False
 196:     
 197:     def _create_new_outlook_email(self):
 198:         """Create a new Outlook email"""
 199:         try:
 200:             # Initialize COM
 201:             pythoncom.CoInitialize()
 202:             
 203:             # Connect to Outlook
 204:             try:
 205:                 self.current_outlook_app = win32com.client.GetActiveObject("Outlook.Application")
 206:             except:
 207:                 self.current_outlook_app = win32com.client.Dispatch("Outlook.Application")
 208:             
 209:             # Create new mail item
 210:             self.current_outlook_item = self.current_outlook_app.CreateItem(0)  # 0 = olMailItem
 211:             
 212:             # Set email properties
 213:             self.current_outlook_item.Subject = f"Screenshots - {datetime.now().strftime('%Y-%m-%d %I:%M %p')}"
 214:             self.current_outlook_item.Body = "Screenshots captured:\n\n"
 215:             
 216:             # Display the email
 217:             self.current_outlook_item.Display()
 218:             
 219:             print("Created new Outlook email")
 220:             return True
 221:             
 222:         except Exception as e:
 223:             self._show_error("Outlook Creation Error", f"Failed to create Outlook email: {str(e)}")
 224:             self.current_outlook_app = None
 225:             self.current_outlook_item = None
 226:             return False
 227:     
 228:     def _insert_image_to_word(self, image_path):
 229:         """Insert image into the current Word document"""
 230:         try:
 231:             if not self.current_word_doc:
 232:                 return False
 233:             
 234:             # Always position at the end of the document to preserve the title
 235:             doc_end = self.current_word_doc.Range()
 236:             doc_end.Collapse(0)  # 0 = wdCollapseEnd
 237:             doc_end.Select()
 238:             
 239:             # Get the selection at the end of the document
 240:             selection = self.current_word_app.Selection
 241:             
 242:             # Add timestamp before image
 243:             timestamp_text = f"Screenshot taken: {datetime.now().strftime('%I:%M:%S %p')}\n"
 244:             selection.TypeText(timestamp_text)
 245:             
 246:             # Insert the image
 247:             inline_shape = selection.InlineShapes.AddPicture(
 248:                 FileName=image_path,
 249:                 LinkToFile=False,
 250:                 SaveWithDocument=True
 251:             )
 252:             
 253:             # Scale image to fit page width (optional)
 254:             page_width = self.current_word_doc.PageSetup.PageWidth - \
 255:                         self.current_word_doc.PageSetup.LeftMargin - \
 256:                         self.current_word_doc.PageSetup.RightMargin
 257:             
 258:             if inline_shape.Width > page_width:
 259:                 scale_factor = page_width / inline_shape.Width
 260:                 inline_shape.Width = page_width
 261:                 inline_shape.Height = inline_shape.Height * scale_factor
 262:             
 263:             # Add some space after the image
 264:             selection.TypeText("\n\n")
 265:             
 266:             # Clean up temp file
 267:             self._cleanup_temp_file(image_path)
 268:             
 269:             return True
 270:             
 271:         except Exception as e:
 272:             print(f"Error inserting image to Word: {e}")
 273:             return False
 274:     
 275:     def _insert_image_to_outlook(self, image_path):
 276:         """Insert image into the current Outlook email"""
 277:         try:
 278:             if not self.current_outlook_item:
 279:                 return False
 280:             
 281:             # Get the current body and add timestamp
 282:             current_body = self.current_outlook_item.Body if self.current_outlook_item.Body else ""
 283:             timestamp_text = f"Screenshot taken: {datetime.now().strftime('%I:%M:%S %p')}\n"
 284:             
 285:             # Add the image as an attachment and embed it
 286:             attachment = self.current_outlook_item.Attachments.Add(image_path)
 287:             
 288:             # For HTML emails, we could embed the image inline, but for simplicity
 289:             # we'll just attach it and add a note in the body
 290:             self.current_outlook_item.Body = current_body + timestamp_text + "[Screenshot attached]\n\n"
 291:             
 292:             # Clean up temp file
 293:             self._cleanup_temp_file(image_path)
 294:             
 295:             return True
 296:             
 297:         except Exception as e:
 298:             print(f"Error inserting image to Outlook: {e}")
 299:             return False
 300:     
 301:     def _cleanup_temp_file(self, filepath):
 302:         """Clean up temporary image file"""
 303:         try:
 304:             # Wait a moment to ensure file is not locked
 305:             time.sleep(0.1)
 306:             if os.path.exists(filepath):
 307:                 os.remove(filepath)
 308:         except Exception as e:
 309:             print(f"Warning: Could not delete temp file {filepath}: {e}")
 310:     
 311:     def _show_error(self, title, message):
 312:         """Show error dialog to user"""
 313:         print(f"Error - {title}: {message}")
 314:         if self.parent_window:
 315:             try:
 316:                 ErrorDialog.show(self.parent_window, title, message)
 317:             except:
 318:                 pass  # Fallback to console output only
 319:     
 320:     def cleanup_temp_directory(self):
 321:         """Clean up old temporary files"""
 322:         try:
 323:             if os.path.exists(self.temp_dir):
 324:                 for filename in os.listdir(self.temp_dir):
 325:                     if filename.startswith("screenshot_"):
 326:                         filepath = os.path.join(self.temp_dir, filename)
 327:                         # Delete files older than 1 hour
 328:                         if time.time() - os.path.getctime(filepath) > 3600:
 329:                             os.remove(filepath)
 330:         except Exception as e:
 331:             print(f"Warning: Could not clean temp directory: {e}")
 332:     
 333:     def force_new_document(self, target_app="Word"):
 334:         """Force creation of a new document (useful for manual reset)"""
 335:         if target_app.lower() == "word":
 336:             self.current_word_doc = None
 337:             self.current_word_app = None
 338:         elif target_app.lower() == "outlook":
 339:             self.current_outlook_item = None
 340:             self.current_outlook_app = None
 341: 
 342: class SnipUI:
 343:     """UI components for the Snip feature"""
 344:     
 345:     @staticmethod
 346:     def create_snip_button(parent, snipping_manager, target_var):
 347:         """Create the Snip button"""
 348:         def on_snip_click():
 349:             target = target_var.get()
 350:             success = snipping_manager.snip_to_target(target)
 351:             if success:
 352:                 print(f"Screenshot successfully added to {target}")
 353:         
 354:         snip_btn = tk.Button(parent, text="Snip", 
 355:                            bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 356:                            relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, 
 357:                            cursor='hand2', activebackground=Colors.HOVER_GREEN, 
 358:                            bd=0, padx=15, command=on_snip_click)
 359:         return snip_btn
 360:     
 361:     @staticmethod
 362:     def create_target_combobox(parent, default_value="Word"):
 363:         """Create the target application combobox"""
 364:         from tkinter import ttk
 365:         
 366:         target_var = tk.StringVar(value=default_value)
 367:         combo = ttk.Combobox(parent, textvariable=target_var, 
 368:                            values=["Word", "Outlook"],
 369:                            state='readonly', width=8)
 370:         
 371:         # Style the combobox to match the app theme
 372:         style = ttk.Style()
 373:         style.theme_use('default')
 374:         style.configure('Snip.TCombobox', 
 375:                        fieldbackground=Colors.MEDIUM_GREEN, 
 376:                        background=Colors.MEDIUM_GREEN)
 377:         combo.configure(style='Snip.TCombobox')
 378:         
 379:         return combo, target_var
 380: 
 381: # Integration helper functions for taskbar.py
 382: def add_snip_feature_to_taskbar(taskbar_instance):
 383:     """Add Snip feature to the existing taskbar"""
 384:     
 385:     # Create snipping manager
 386:     snipping_manager = SnippingManager(taskbar_instance.root)
 387:     
 388:     # Create frame for snip controls
 389:     snip_frame = tk.Frame(taskbar_instance.main_frame, bg=Colors.DARK_GREEN)
 390:     snip_frame.pack(side=tk.LEFT, padx=10)
 391:     
 392:     # Create target selection combobox
 393:     combo, target_var = SnipUI.create_target_combobox(snip_frame)
 394:     combo.pack(side=tk.LEFT, padx=(0, 5))
 395:     
 396:     # Create snip button
 397:     snip_btn = SnipUI.create_snip_button(snip_frame, snipping_manager, target_var)
 398:     snip_btn.pack(side=tk.LEFT)
 399:     
 400:     # Store reference for cleanup
 401:     taskbar_instance.snipping_manager = snipping_manager
 402:     
 403:     # Schedule periodic cleanup of temp files
 404:     def cleanup_temp_files():
 405:         snipping_manager.cleanup_temp_directory()
 406:         taskbar_instance.root.after(300000, cleanup_temp_files)  # Every 5 minutes
 407:     
 408:     taskbar_instance.root.after(300000, cleanup_temp_files)
 409:     
 410:     return snipping_manager

────────────────────────────────────────────────────────────────────────────────
FILE: taskbar.py
────────────────────────────────────────────────────────────────────────────────
Path: taskbar.py
Size: 23.1 KB
Lines: 555 total, 441 non-empty
Characters: 23,083
Type: Core taskbar functionality and UI
────────────────────────────────────────────────────────────────────────────────

   1: # taskbar.py (UPDATED)
   2: """
   3: Core taskbar window and layout for SuiteView Taskbar Application
   4: """
   5: 
   6: import tkinter as tk
   7: from tkinter import ttk
   8: import sys
   9: from ctypes import wintypes
  10: 
  11: from config import Colors, Fonts, Dimensions, Settings
  12: from utils import WindowsUtils, UIUtils
  13: from links_manager import LinksManager
  14: from quick_links import QuickLinksMenu
  15: from snip_feature import add_snip_feature_to_taskbar
  16: from folder_inventory import FolderInventoryDialog, FolderInventoryWindow
  17: 
  18: from window_manager import WindowManager
  19: from windows_menu import WindowsMenu
  20: from pinned_windows import PinnedWindowsSection
  21: 
  22: 
  23: class SuiteViewTaskbar:
  24:     """Main taskbar application window"""
  25:     
  26:     def __init__(self):
  27:         self.root = tk.Tk()
  28:         self.links_manager = LinksManager()
  29:         self.window_manager = WindowManager()
  30: 
  31:         # Initialize these BEFORE creating UI
  32:         self.links_menu = None
  33:         self.windows_menu = None
  34:         self.pinned_section = None  # Initialize to None
  35:         self.windows_menu_geometry = None
  36:         self.email_options_menu = None  # Initialize email options menu tracker
  37:         self.email_menu_closing = False  # Flag to prevent immediate reopen
  38:         self.emails_btn = None
  39:         
  40:         # Store original work area for restoration
  41:         self.original_work_area = WindowsUtils.get_work_area()
  42:         
  43:         # Get screen dimensions
  44:         self.screen_width, self.screen_height = WindowsUtils.get_screen_dimensions()
  45:         
  46:         # Get Windows taskbar height for better positioning
  47:         self.windows_taskbar_height = WindowsUtils.get_windows_taskbar_height()
  48:         
  49:         # Position the custom taskbar above Windows taskbar
  50:         self.y_position = self.screen_height - self.windows_taskbar_height - Dimensions.TASKBAR_HEIGHT
  51:         
  52:         # Setup the window
  53:         self.setup_window()
  54:         
  55:         # Create taskbar content
  56:         self.create_taskbar_content()
  57:         
  58:         # Setup event bindings
  59:         self.bind_events()
  60:         
  61:         # Apply Windows API modifications
  62:         self.setup_windows_integration()
  63:         
  64:     def setup_window(self):
  65:         """Configure the main window properties"""
  66:         # Remove window decorations
  67:         self.root.overrideredirect(True)
  68:         
  69:         # Set window attributes
  70:         self.root.attributes('-topmost', True)
  71:         self.root.attributes('-alpha', Settings.TASKBAR_OPACITY)
  72:         
  73:         # Configure window geometry
  74:         self.root.geometry(f"{self.screen_width}x{Dimensions.TASKBAR_HEIGHT}+0+{self.y_position}")
  75:         
  76:         # Set background color to dark green
  77:         self.root.configure(bg=Colors.DARK_GREEN)
  78:     
  79:     def create_taskbar_content(self):
  80:         """Create the taskbar UI elements"""
  81:         # Create main frame
  82:         self.main_frame = tk.Frame(self.root, bg=Colors.DARK_GREEN, highlightthickness=0)
  83:         self.main_frame.pack(fill=tk.BOTH, expand=True)
  84:         
  85:         # SuiteView Logo/Title
  86:         self.create_logo_section()
  87:         
  88:         # Separator
  89:         separator = UIUtils.create_separator(self.main_frame, Colors.DARK_GREEN, width=2)
  90:         separator.pack(side=tk.LEFT, fill=tk.Y, padx=10)
  91:         
  92:         # Main buttons
  93:         self.create_main_buttons()
  94:         
  95:         # Right side elements
  96:         self.create_right_side_elements()
  97:     
  98:     def create_logo_section(self):
  99:         """Create the SuiteView logo/title section"""
 100:         logo_frame = tk.Frame(self.main_frame, bg=Colors.DARK_GREEN)
 101:         logo_frame.pack(side=tk.LEFT, padx=10)
 102:         
 103:         # Logo text with styling
 104:         logo_label = tk.Label(logo_frame, text=Settings.APP_NAME, bg=Colors.DARK_GREEN, 
 105:                              fg=Colors.WHITE, font=Fonts.TASKBAR_TITLE)
 106:         logo_label.pack()
 107:         logo_label.bind("<Button-3>", self.show_links_menu)
 108:     
 109:     def create_main_buttons(self):
 110:         """Create the main taskbar buttons"""
 111:         # Existing buttons
 112:         buttons_data = [
 113:             ("Get Policy", None),
 114:             ("Cyber", None),
 115:             ("TAI", None)
 116:         ]
 117:         
 118:         for text, command in buttons_data:
 119:             btn = tk.Button(self.main_frame, text=text, bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 120:                         relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, cursor='hand2',
 121:                         activebackground=Colors.HOVER_GREEN, bd=0, padx=15)
 122:             btn.pack(side=tk.LEFT, padx=5)
 123:             btn.bind("<Button-3>", self.show_links_menu)
 124:             if command:
 125:                 btn.configure(command=command)
 126:         
 127:         # Add separator before new features
 128:         separator = UIUtils.create_separator(self.main_frame, Colors.DARK_GREEN, width=2)
 129:         separator.pack(side=tk.LEFT, fill=tk.Y, padx=10)
 130:         
 131:         # Add Inventory feature
 132:         #inventory_btn = add_folder_inventory_to_taskbar(self)
 133:         #inventory_btn.pack(side=tk.LEFT, padx=5)
 134:         #inventory_btn.bind("<Button-3>", self.show_links_menu)
 135:         
 136:         # Add separator before Snip feature
 137:         separator2 = UIUtils.create_separator(self.main_frame, Colors.DARK_GREEN, width=2)
 138:         separator2.pack(side=tk.LEFT, fill=tk.Y, padx=10)
 139: 
 140:         # Inventory button
 141:         inventory_btn = tk.Button(self.main_frame, text="Inventory", 
 142:                                 bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 143:                                 relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, 
 144:                                 cursor='hand2', activebackground=Colors.HOVER_GREEN, 
 145:                                 bd=0, padx=15, command=self.show_inventory_dialog)
 146:         inventory_btn.pack(side=tk.LEFT, padx=5)
 147: 
 148:         # Add separator before Snip feature
 149:         separator3 = UIUtils.create_separator(self.main_frame, Colors.DARK_GREEN, width=2)
 150:         separator3.pack(side=tk.LEFT, fill=tk.Y, padx=10)
 151: 
 152:         # Add Snip feature
 153:         self.snipping_manager = add_snip_feature_to_taskbar(self)
 154:         
 155:         # Add separator before pinned windows section
 156:         separator3 = UIUtils.create_separator(self.main_frame, Colors.DARK_GREEN, width=2)
 157:         separator3.pack(side=tk.LEFT, fill=tk.Y, padx=10)
 158:         
 159:         # Create and store pinned windows section
 160:         print(f"Creating pinned section...")
 161:         self.pinned_section = PinnedWindowsSection(self.main_frame, self.window_manager, self.on_windows_pinned)
 162:         self.pinned_section.pack(side=tk.LEFT, fill=tk.Y)  # Remove padx, let it grow as needed
 163:         
 164:         # Debug to confirm it's created and assigned
 165:         #print(f"Pinned section created and assigned: {self.pinned_section}")
 166:         #print(f"self.pinned_section is not None: {self.pinned_section is not None}")
 167:     
 168:     def create_right_side_elements(self):
 169:         """Create the right side elements of the taskbar"""
 170:         
 171:         # X close button
 172:         close_btn = tk.Label(self.main_frame, text="X", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 173:                             font=(Fonts.TASKBAR_BUTTON[0], Fonts.TASKBAR_BUTTON[1], 'bold'), 
 174:                             cursor='hand2')
 175:         close_btn.pack(side=tk.RIGHT, padx=5)
 176:         close_btn.bind("<Button-1>", self.close_app)
 177:     
 178:         #Windows button
 179:         windows_btn = tk.Button(self.main_frame, text="Windows", 
 180:                             bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 181:                             relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, 
 182:                             cursor='hand2', activebackground=Colors.HOVER_GREEN, 
 183:                             bd=0, padx=15, command=self.toggle_windows_menu)
 184:         windows_btn.pack(side=tk.RIGHT, padx=5)
 185: 
 186:         
 187:         # Add Emails button
 188:         self.emails_btn = tk.Button(self.main_frame, text="Emails", 
 189:                         bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 190:                         relief=tk.FLAT, font=Fonts.TASKBAR_BUTTON, 
 191:                         cursor='hand2', activebackground=Colors.HOVER_GREEN, 
 192:                         bd=0, padx=15, command=self.show_email_options_menu)
 193:         self.emails_btn.pack(side=tk.LEFT, padx=5)
 194: 
 195: 
 196:     def bind_events(self):
 197:         """Bind event handlers"""
 198:         # Main window events
 199:         self.root.bind("<Button-3>", self.show_links_menu)
 200:         self.main_frame.bind("<Button-3>", self.show_links_menu)
 201:         
 202:         # Emergency exit keys
 203:         self.root.bind("<Escape>", self.close_app)
 204:         self.root.bind("<Control-q>", self.close_app)
 205:         self.root.bind("<Control-Q>", self.close_app)
 206:         self.root.bind("<Alt-F4>", self.close_app)
 207:     
 208:     def setup_windows_integration(self):
 209:         """Setup Windows API integration"""
 210:         # Keep window on top using Windows API
 211:         self.set_always_on_top()
 212:         
 213:         # Adjust desktop working area
 214:         self.adjust_work_area()
 215:         
 216:     def show_links_menu(self, event):
 217:         """Show the right-click links menu positioned above the taskbar"""
 218:         if self.links_menu:
 219:             self.links_menu.destroy()
 220:         
 221:         # Create the menu at a temporary position first
 222:         temp_x, temp_y = 0, 0
 223:         self.links_menu = QuickLinksMenu(self.root, self, temp_x, temp_y)
 224:         
 225:         # Get cursor position or use center position
 226:         if event:
 227:             x = self.root.winfo_pointerx() - 200  # Offset to center menu on cursor
 228:         else:
 229:             x = self.screen_width // 2 - 200  # Center horizontally
 230:         
 231:         # Calculate proper position above YOUR custom taskbar
 232:         final_y = self.y_position - self.links_menu.menu_height - 5  # 5px gap above YOUR taskbar
 233:         final_x = x
 234:         
 235:         # Reposition the menu to the correct location
 236:         self.links_menu.geometry(f"+{final_x}+{final_y}")
 237:         
 238:         # Debug output
 239:         print(f"Estimated height: {self.links_menu.menu_height}")
 240:         print(f"Positioned menu at: {final_x}, {final_y}")
 241:         print(f"Menu bottom should be at: {final_y + self.links_menu.menu_height}")
 242:        
 243:     def show_windows_menu(self, event=None):
 244:         """Show the windows management menu - toggle if already open"""
 245:         if self.windows_menu and self.windows_menu.winfo_exists():
 246:             # If menu exists and is open, close it
 247:             self.windows_menu.close_window()
 248:             self.windows_menu = None
 249:         else:
 250:             # Otherwise, create and show it
 251:             # Get screen dimensions
 252:             screen_width = self.root.winfo_screenwidth()
 253:             
 254:             # Position the menu above the taskbar, centered on screen
 255:             x = (screen_width - 700) // 2  # Center a 700px wide menu
 256:             y = self.y_position - 600  # Default height assumption
 257:             
 258:     def set_always_on_top(self):
 259:         """Force window to stay on top using Windows API"""
 260:         WindowsUtils.set_window_topmost(self.root.winfo_id())
 261:     
 262:     def adjust_work_area(self):
 263:         """Adjust desktop work area to make room for taskbar"""
 264:         if self.original_work_area:
 265:             work_area = wintypes.RECT()
 266:             work_area.left = self.original_work_area.left
 267:             work_area.top = self.original_work_area.top
 268:             work_area.right = self.original_work_area.right
 269:             work_area.bottom = self.y_position
 270:             
 271:             success = WindowsUtils.set_work_area(work_area)
 272:             if not success:
 273:                 print("Could not adjust work area. May require admin privileges.")
 274:     
 275:     def close_app(self, event=None):
 276:         """Close the application"""
 277:         try:
 278:             self.window_manager.unhide_all_windows()
 279:             self.restore_work_area()
 280:         except:
 281:             pass  # Don't fail if restore doesn't work
 282:         
 283:         # Clean up snipping manager if it exists
 284:         if hasattr(self, 'snipping_manager'):
 285:             try:
 286:                 self.snipping_manager.cleanup_temp_directory()
 287:             except:
 288:                 pass
 289:         
 290:         # Force kill any open dialogs
 291:         for child in self.root.winfo_children():
 292:             if isinstance(child, tk.Toplevel):
 293:                 child.destroy()
 294:         
 295:         self.root.quit()
 296:         self.root.destroy()
 297:         sys.exit(0)
 298:     
 299:     def restore_work_area(self):
 300:         """Restore original work area"""
 301:         if self.original_work_area:
 302:             WindowsUtils.restore_work_area(self.original_work_area)
 303:     
 304:     def run(self):
 305:         """Start the application"""
 306:         """Start the application"""
 307:         
 308:         # Start the periodic topmost maintenance
 309:         #self.root.after(Settings.AUTO_REFRESH_INTERVAL, self.maintain_topmost)
 310:         
 311:         # Start window state monitoring
 312:         self.root.after(1000, self.start_window_monitoring)  # Start after 1 second
 313: 
 314:         # Start the main event loop
 315:         self.root.mainloop()
 316:     
 317:     def maintain_topmost(self):
 318:         """Periodically ensure window stays on top"""
 319:         self.set_always_on_top()
 320: 
 321:         # # Update pinned window button states
 322:         # if self.pinned_section:
 323:         #     self.pinned_section.update_window_states()
 324: 
 325:         self.root.after(Settings.AUTO_REFRESH_INTERVAL, self.maintain_topmost)
 326: 
 327:     def toggle_windows_menu(self):
 328:         """Toggle the windows management menu"""
 329:         if self.windows_menu and hasattr(self.windows_menu, 'winfo_exists'):
 330:             try:
 331:                 if self.windows_menu.winfo_exists():
 332:                     # Store current geometry BEFORE closing
 333:                     self.windows_menu_geometry = self.windows_menu.get_current_geometry()
 334:                     print(f"Storing geometry: {self.windows_menu_geometry}")  # Debug
 335:                     self.windows_menu.close_window()
 336:                     self.windows_menu = None
 337:                     return
 338:             except:
 339:                 self.windows_menu = None
 340:         
 341:         # Create new windows menu
 342:         print(f"Class: {type(self).__name__}")  # Debug
 343:         self.windows_menu = WindowsMenu(self, self.window_manager, 
 344:                                     self.on_windows_pinned,
 345:                                     self.windows_menu_geometry)
 346:     
 347:     def on_windows_pinned(self):
 348:         """Callback when windows are pinned/unpinned"""
 349:         #print(f"\n=== ON_WINDOWS_PINNED CALLED ===")
 350:         #print(f"Pinned section: {self.pinned_section}")
 351:         
 352:         if self.pinned_section:
 353:             print(f"Refreshing pinned section...")
 354:             self.pinned_section.refresh()
 355:         else:
 356:             print(f"ERROR: pinned_section is None!")
 357:         
 358:         # Always refresh the Windows Manager if it's open to update the list
 359:         if self.windows_menu and hasattr(self.windows_menu, 'winfo_exists'):
 360:             try:
 361:                 if self.windows_menu.winfo_exists():
 362:                     print(f"Refreshing Windows Manager...")
 363:                     self.windows_menu.refresh_window_list()
 364:                 else:
 365:                     print(f"Windows Manager exists but window is destroyed")
 366:             except Exception as e:
 367:                 print(f"Error refreshing Windows Manager: {e}")
 368:                 self.windows_menu = None
 369:         else:
 370:             print(f"Windows Manager is not open")
 371:             
 372:         #print(f"=== END ON_WINDOWS_PINNED ===\n")
 373: 
 374: 
 375:     def start_window_monitoring(self):
 376:         """Start monitoring for closed windows"""
 377:         self.check_window_states()
 378:         
 379:     def check_window_states(self):
 380:         """Periodically check if pinned windows still exist"""
 381:         try:
 382:             if hasattr(self, 'pinned_section') and self.pinned_section:
 383:                 # Get current pinned windows
 384:                 pinned_windows = self.window_manager.get_pinned_windows()
 385:                 windows_to_unpin = []
 386:                 
 387:                 for window in pinned_windows:
 388:                     # Check if window still exists
 389:                     if not window.is_valid():
 390:                         print(f"Window {window.display_name} no longer exists, unpinning...")
 391:                         windows_to_unpin.append(window)
 392:                 
 393:                 # Unpin any closed windows
 394:                 if windows_to_unpin:
 395:                     for window in windows_to_unpin:
 396:                         self.window_manager.unpin_window(window)
 397:                     
 398:                     # Refresh the pinned section
 399:                     self.pinned_section.refresh()
 400:                     
 401:                     # Also refresh Windows Manager if it's open
 402:                     if hasattr(self, 'windows_menu') and self.windows_menu:
 403:                         try:
 404:                             if self.windows_menu.winfo_exists():
 405:                                 self.windows_menu.refresh_window_list()
 406:                         except:
 407:                             pass
 408:         
 409:         except Exception as e:
 410:             print(f"Error checking window states: {e}")
 411:         
 412:         # Schedule next check (every 2 seconds)
 413:         self.root.after(2000, self.check_window_states)
 414: 
 415:     def verify_setup(self):
 416:         """Verify all components are properly initialized"""
 417:         print(f"\n=== VERIFYING TASKBAR SETUP ===")
 418:         print(f"Window manager: {self.window_manager}")
 419:         print(f"Pinned section: {self.pinned_section}")
 420:         print(f"Pinned section type: {type(self.pinned_section)}")
 421:         if self.pinned_section:
 422:             print(f"Pinned section parent: {self.pinned_section.master}")
 423:             print(f"Pinned section visible: {self.pinned_section.winfo_exists()}")
 424:         print(f"=== END VERIFICATION ===\n")
 425:     
 426:     def check_window_states(self):
 427:         """Periodically check for closed windows, new windows, and title changes"""
 428:         try:
 429:             # Get current window list
 430:             current_windows = self.window_manager.get_relevant_windows()
 431:             current_hwnds = {w.hwnd for w in current_windows}
 432:             
 433:             # Check for closed pinned windows
 434:             if hasattr(self, 'pinned_section') and self.pinned_section:
 435:                 pinned_windows = self.window_manager.get_pinned_windows()
 436:                 windows_to_unpin = []
 437:                 
 438:                 for window in pinned_windows:
 439:                     if not window.is_valid():
 440:                         print(f"Window {window.display_name} no longer exists, unpinning...")
 441:                         windows_to_unpin.append(window)
 442:                 
 443:                 if windows_to_unpin:
 444:                     for window in windows_to_unpin:
 445:                         self.window_manager.unpin_window(window)
 446:                     self.pinned_section.refresh()
 447:             
 448:             # Initialize tracking dictionaries if they don't exist
 449:             if not hasattr(self, '_previous_hwnds'):
 450:                 self._previous_hwnds = current_hwnds
 451:                 self._window_titles = {}
 452:             
 453:             # Check for new windows
 454:             new_hwnds = current_hwnds - self._previous_hwnds
 455:             if new_hwnds:
 456:                 print(f"Detected {len(new_hwnds)} new window(s)")
 457:                 self._refresh_windows_menu()
 458:             
 459:             # Check for title changes in existing windows
 460:             title_changed = False
 461:             for window in current_windows:
 462:                 hwnd = window.hwnd
 463:                 current_title = window.title
 464:                 
 465:                 # Store or compare title
 466:                 if hwnd in self._window_titles:
 467:                     if self._window_titles[hwnd] != current_title:
 468:                         #print(f"Title changed for {window.app_name}: '{self._window_titles[hwnd]}' -> '{current_title}'")
 469:                         title_changed = True
 470:                         self._window_titles[hwnd] = current_title
 471:                         
 472:                         # Update the window's display name
 473:                         window.display_name = window._create_display_name()
 474:                         
 475:                         # Update pinned button if this window is pinned
 476:                         if window.is_pinned and hasattr(self, 'pinned_section') and self.pinned_section:
 477:                             self.pinned_section.update_window_title(window)
 478:                 else:
 479:                     self._window_titles[hwnd] = current_title
 480:             
 481:             # Clean up titles for closed windows
 482:             closed_hwnds = set(self._window_titles.keys()) - current_hwnds
 483:             for hwnd in closed_hwnds:
 484:                 del self._window_titles[hwnd]
 485:             
 486:             # Refresh Windows menu if titles changed
 487:             if title_changed:
 488:                 self._refresh_windows_menu()
 489:             
 490:             # Update previous list for next check
 491:             self._previous_hwnds = current_hwnds
 492:         
 493:         except Exception as e:
 494:             print(f"Error checking window states: {e}")
 495:         
 496:         # Schedule next check (every 1 second for responsive updates)
 497:         self.root.after(1000, self.check_window_states)
 498: 
 499:     def _refresh_windows_menu(self):
 500:         """Helper method to refresh Windows menu if it's open"""
 501:         if hasattr(self, 'windows_menu') and self.windows_menu:
 502:             try:
 503:                 if self.windows_menu.winfo_exists():
 504:                     print("Refreshing Windows Manager...")
 505:                     self.windows_menu.refresh_window_list()
 506:             except:
 507:                 pass
 508: 
 509:     
 510:     def show_inventory_dialog(self):
 511:         """Show the folder inventory dialog"""
 512:         dialog = FolderInventoryDialog(self.root)
 513:         dialog.lift()
 514:         dialog.focus_force()
 515:         
 516:     def show_email_options_menu(self):
 517:         """Show the email options popup menu - toggle if already open"""
 518:         from email_options_menu import EmailOptionsMenu
 519:         
 520:         # # Check if we're in the process of closing (prevents immediate reopen)
 521:         # if hasattr(self, 'email_menu_closing') and self.email_menu_closing:
 522:         #     return
 523:         
 524:         # # Check if email options menu is already open
 525:         # if hasattr(self, 'email_options_menu') and self.email_options_menu is not None:
 526:         #     try:
 527:         #         # Note: Need to check self.email_options_menu.root since that's the actual window
 528:         #         if self.email_options_menu.root.winfo_exists():
 529:         #             # Menu is open, close it
 530:         #             self.email_options_menu.root.destroy()
 531:         #             self.email_options_menu = None
 532:         #             return
 533:         #     except:
 534:         #         self.email_options_menu = None
 535:         
 536:         
 537:         if self.emails_btn:
 538:             # Create and show the options menu
 539:             self.email_options_menu = EmailOptionsMenu(self.root, self.emails_btn, self)
 540:             
 541:             # Position menu above taskbar
 542:             menu_height = 150  # Approximate height for 2 menu items
 543:             x = self.emails_btn.winfo_rootx()
 544:             taskbar_top = self.root.winfo_rooty()
 545:             y = taskbar_top - menu_height
 546:             
 547:             # Set the position
 548:             self.email_options_menu.geometry(f"{200}x{menu_height}+{x}+{y}")
 549:             
 550:             # Set up cleanup when menu is destroyed
 551:             def cleanup():
 552:                 self.email_options_menu = None
 553:             
 554:             self.email_options_menu.bind("<Destroy>", lambda e: cleanup())
 555: 

────────────────────────────────────────────────────────────────────────────────
FILE: ui_components.py
────────────────────────────────────────────────────────────────────────────────
Path: ui_components.py
Size: 19.0 KB
Lines: 525 total, 405 non-empty
Characters: 19,390
Type: Reusable UI components and dialogs
────────────────────────────────────────────────────────────────────────────────

   1: # ui_components.py
   2: """
   3: Shared UI components for SuiteView Taskbar Application
   4: Contains reusable dialogs, custom widgets, and styling functions
   5: Updated to use SimpleWindow
   6: """
   7: 
   8: import tkinter as tk
   9: from tkinter import ttk
  10: from config import Colors, Fonts, Dimensions
  11: from utils import UIUtils
  12: from simple_window_factory import SimpleWindow
  13: 
  14: class CustomDialog(SimpleWindow):
  15:     """Base class for custom dialogs with consistent styling using SimpleWindow"""
  16:     
  17:     def __init__(self, parent, title, width=400, height=300, resizable=False, x=None, y=None):
  18:         # Initialize SimpleWindow without resize handles
  19:         super().__init__(parent, title, resize_handles=None)
  20:         
  21:         self.parent = parent
  22:         self.result = None
  23:         
  24:         # Set window size
  25:         self.geometry(f"{width}x{height}")
  26:         
  27:         # Set background color
  28:         self.content_frame.configure(bg=Colors.LIGHT_GREEN)
  29:         
  30:         # Position window
  31:         if x is not None and y is not None:
  32:             self.geometry(f"{width}x{height}+{x}+{y}")
  33:         else:
  34:             # Center on parent
  35:             self.update_idletasks()
  36:             parent_x = parent.winfo_x()
  37:             parent_y = parent.winfo_y()
  38:             parent_width = parent.winfo_width()
  39:             parent_height = parent.winfo_height()
  40:             x = parent_x + (parent_width - width) // 2
  41:             y = parent_y + (parent_height - height) // 2
  42:             self.geometry(f"{width}x{height}+{x}+{y}")
  43:         
  44:         # Make modal
  45:         self.transient(parent)
  46:         self.grab_set()
  47:         
  48:         # Create dialog structure
  49:         self._create_dialog_structure()
  50:         
  51:         # Pause parent's topmost maintenance if it has it
  52:         if hasattr(parent, 'pause_topmost_maintenance'):
  53:             parent.pause_topmost_maintenance()
  54:         
  55:         # Bind escape key
  56:         self.bind('<Escape>', lambda e: self.cancel())
  57:         
  58:         # Focus
  59:         self.focus_set()
  60:     
  61:     def _create_dialog_structure(self):
  62:         """Create the standard dialog structure"""
  63:         # Main content area - using the inherited content_frame
  64:         self.dialog_content = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
  65:         self.dialog_content.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
  66:         
  67:         # Button frame at bottom
  68:         self.button_frame = tk.Frame(self.content_frame, bg=Colors.LIGHT_GREEN)
  69:         self.button_frame.pack(fill=tk.X, pady=(0, 20))
  70:     
  71:     def ok(self):
  72:         """OK button clicked"""
  73:         self.result = True
  74:         self.destroy()
  75:     
  76:     def cancel(self):
  77:         """Cancel button clicked"""
  78:         self.result = None
  79:         self.destroy()
  80:     
  81:     def destroy(self):
  82:         """Override destroy to clean up properly"""
  83:         # Resume parent's topmost maintenance
  84:         if hasattr(self.parent, 'resume_topmost_maintenance'):
  85:             self.parent.resume_topmost_maintenance()
  86:         super().destroy()
  87: 
  88: 
  89: class ConfirmationDialog(CustomDialog):
  90:     """Confirmation dialog with Yes/No buttons"""
  91:     
  92:     def __init__(self, parent, title, message, icon="⚠️"):
  93:         super().__init__(parent, title, width=350, height=200)
  94:         
  95:         # Icon and message
  96:         icon_label = tk.Label(self.dialog_content, text=icon, bg=Colors.LIGHT_GREEN,
  97:                              fg=Colors.BLACK, font=Fonts.WARNING_ICON)
  98:         icon_label.pack(pady=10)
  99:         
 100:         message_label = tk.Label(self.dialog_content, text=message, bg=Colors.LIGHT_GREEN,
 101:                                fg=Colors.BLACK, font=Fonts.DIALOG_LABEL, wraplength=300)
 102:         message_label.pack(pady=5)
 103:         
 104:         # Buttons
 105:         self.add_buttons()
 106:         
 107:         # Bind keys
 108:         self.bind('<Return>', lambda e: self.yes())
 109:         self.bind('<Escape>', lambda e: self.no())
 110:     
 111:     def add_buttons(self):
 112:         """Add Yes/No buttons"""
 113:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 114:         button_container.pack(expand=True)
 115:         
 116:         yes_btn = tk.Button(button_container, text="Yes", bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 117:                            command=self.yes, width=Dimensions.DIALOG_BUTTON_WIDTH,
 118:                            font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 119:         yes_btn.pack(side=tk.LEFT, padx=10)
 120:         
 121:         no_btn = tk.Button(button_container, text="No", bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 122:                           command=self.no, width=Dimensions.DIALOG_BUTTON_WIDTH,
 123:                           font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 124:         no_btn.pack(side=tk.LEFT, padx=10)
 125:         
 126:         # Focus on No button (safer default)
 127:         no_btn.focus_set()
 128:     
 129:     def yes(self):
 130:         """Yes button clicked"""
 131:         self.result = True
 132:         self.destroy()
 133:     
 134:     def no(self):
 135:         """No button clicked"""
 136:         self.result = False
 137:         self.destroy()
 138:     
 139:     @classmethod
 140:     def ask(cls, parent, title, message, icon="⚠️"):
 141:         """Show confirmation dialog and return result"""
 142:         dialog = cls(parent, title, message, icon)
 143:         dialog.lift()
 144:         dialog.focus_force()
 145:         parent.wait_window(dialog)
 146:         return dialog.result
 147: 
 148: 
 149: class LoadingDialog(SimpleWindow):
 150:     """Simple loading dialog using SimpleWindow"""
 151:     
 152:     def __init__(self, parent, message="Loading..."):
 153:         # Initialize SimpleWindow without resize handles
 154:         super().__init__(parent, "Please Wait", resize_handles=None)
 155:         
 156:         # Set window size
 157:         self.geometry("300x150")
 158:         
 159:         # Center on parent
 160:         self.update_idletasks()
 161:         parent.update_idletasks()
 162:         x = parent.winfo_x() + (parent.winfo_width() - 300) // 2
 163:         y = parent.winfo_y() + (parent.winfo_height() - 150) // 2
 164:         self.geometry(f"300x150+{x}+{y}")
 165:         
 166:         # Set background color
 167:         self.content_frame.configure(bg=Colors.LIGHT_GREEN)
 168:         
 169:         # Create content
 170:         self.message = message
 171:         self._create_content()
 172:         
 173:         # Make modal
 174:         self.transient(parent)
 175:         self.grab_set()
 176:         
 177:         # Start animation
 178:         self.animate_progress()
 179:     
 180:     def _create_content(self):
 181:         """Create the loading dialog content"""
 182:         content = self.content_frame
 183:         
 184:         # Loading message
 185:         self.msg_label = tk.Label(content, text=self.message,
 186:                                  bg=Colors.LIGHT_GREEN, fg=Colors.BLACK,
 187:                                  font=Fonts.DIALOG_LABEL)
 188:         self.msg_label.pack(pady=20)
 189:         
 190:         # Progress indicator (simple animation)
 191:         self.progress_label = tk.Label(content, text="⏳",
 192:                                       bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 193:                                       font=('Arial', 24))
 194:         self.progress_label.pack(pady=10)
 195:     
 196:     def animate_progress(self):
 197:         """Simple progress animation"""
 198:         current = self.progress_label.cget("text")
 199:         if current == "⏳":
 200:             self.progress_label.config(text="⌛")
 201:         else:
 202:             self.progress_label.config(text="⏳")
 203:         
 204:         self.after(500, self.animate_progress)
 205:     
 206:     def update_message(self, new_message):
 207:         """Update the loading message"""
 208:         self.msg_label.config(text=new_message)
 209: 
 210: 
 211: class WarningDialog(CustomDialog):
 212:     """Warning dialog with OK button"""
 213:     
 214:     def __init__(self, parent, title, message, icon="⚠️"):
 215:         super().__init__(parent, title, width=380, height=220)
 216:         
 217:         # Icon and message
 218:         icon_label = tk.Label(self.dialog_content, text=icon, bg=Colors.LIGHT_GREEN,
 219:                              fg=Colors.BLACK, font=('Arial', 24))
 220:         icon_label.pack(pady=10)
 221:         
 222:         message_label = tk.Label(self.dialog_content, text=message, bg=Colors.LIGHT_GREEN,
 223:                                fg=Colors.BLACK, font=Fonts.DIALOG_LABEL, wraplength=320)
 224:         message_label.pack(pady=5)
 225:         
 226:         # Buttons
 227:         self.add_buttons()
 228:         
 229:         # Bind keys
 230:         self.bind('<Return>', lambda e: self.ok())
 231:         self.bind('<Escape>', lambda e: self.ok())
 232:     
 233:     def add_buttons(self):
 234:         """Add OK button"""
 235:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 236:         button_container.pack(expand=True)
 237:         
 238:         ok_btn = tk.Button(button_container, text="OK", bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 239:                           command=self.ok, width=Dimensions.DIALOG_BUTTON_WIDTH,
 240:                           font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 241:         ok_btn.pack(padx=10)
 242:         ok_btn.focus_set()
 243:     
 244:     @classmethod
 245:     def show(cls, parent, title, message, icon="⚠️"):
 246:         """Show warning dialog"""
 247:         dialog = cls(parent, title, message, icon)
 248:         dialog.lift()
 249:         dialog.focus_force()
 250:         dialog.attributes('-topmost', True)
 251:         parent.wait_window(dialog)
 252:         return dialog.result
 253: 
 254: 
 255: class ErrorDialog(CustomDialog):
 256:     """Error dialog with OK button"""
 257:     
 258:     def __init__(self, parent, title, message, icon="❌"):
 259:         super().__init__(parent, title, width=400, height=240)
 260:         
 261:         # Icon and message
 262:         icon_label = tk.Label(self.dialog_content, text=icon, bg=Colors.LIGHT_GREEN,
 263:                              fg=Colors.BLACK, font=('Arial', 24))
 264:         icon_label.pack(pady=10)
 265:         
 266:         message_label = tk.Label(self.dialog_content, text=message, bg=Colors.LIGHT_GREEN,
 267:                                fg=Colors.BLACK, font=Fonts.DIALOG_LABEL, wraplength=340)
 268:         message_label.pack(pady=5)
 269:         
 270:         # Buttons
 271:         self.add_buttons()
 272:         
 273:         # Bind keys
 274:         self.bind('<Return>', lambda e: self.ok())
 275:         self.bind('<Escape>', lambda e: self.ok())
 276:     
 277:     def add_buttons(self):
 278:         """Add OK button"""
 279:         button_container = tk.Frame(self.button_frame, bg=Colors.LIGHT_GREEN)
 280:         button_container.pack(expand=True)
 281:         
 282:         ok_btn = tk.Button(button_container, text="OK", bg=Colors.INACTIVE_GRAY, fg=Colors.WHITE,
 283:                           command=self.ok, width=Dimensions.DIALOG_BUTTON_WIDTH,
 284:                           font=Fonts.DIALOG_BUTTON, relief=tk.RAISED, bd=1)
 285:         ok_btn.pack(padx=10)
 286:         ok_btn.focus_set()
 287:     
 288:     @classmethod
 289:     def show(cls, parent, title, message, icon="❌"):
 290:         """Show error dialog"""
 291:         dialog = cls(parent, title, message, icon)
 292:         dialog.lift()
 293:         dialog.focus_force()
 294:         dialog.attributes('-topmost', True)
 295:         parent.wait_window(dialog)
 296:         return dialog.result
 297: 
 298: 
 299: # Helper Components (not dialogs, so don't change these)
 300: 
 301: class FormField:
 302:     """Helper class for creating form fields with clipboard support"""
 303:     
 304:     def __init__(self, parent, label_text, field_type='entry', layout='side-by-side', **kwargs):
 305:         self.frame = tk.Frame(parent, bg=Colors.LIGHT_GREEN)
 306:         self.layout = layout
 307:         
 308:         if layout == 'stacked':
 309:             # Label on top, widget below
 310:             self.label = tk.Label(self.frame, text=label_text, bg=Colors.LIGHT_GREEN, 
 311:                                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL)
 312:             self.label.pack(anchor='w', pady=(0, 2))
 313:             
 314:             if field_type == 'entry':
 315:                 self.widget = tk.Entry(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 316:                 self._bind_clipboard_operations()
 317:             elif field_type == 'combobox':
 318:                 self.widget = ttk.Combobox(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 319:                 self._bind_combobox_clipboard_operations()
 320:             elif field_type == 'text':
 321:                 self.widget = tk.Text(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 322:                 self._bind_text_clipboard_operations()
 323:             
 324:             self.widget.pack(fill=tk.X)
 325:         else:
 326:             # Side-by-side layout
 327:             self.label = tk.Label(self.frame, text=label_text, bg=Colors.LIGHT_GREEN, 
 328:                                 fg=Colors.BLACK, font=Fonts.DIALOG_LABEL)
 329:             self.label.pack(side=tk.LEFT, padx=(0, 10))
 330:             
 331:             if field_type == 'entry':
 332:                 self.widget = tk.Entry(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 333:                 self._bind_clipboard_operations()
 334:             elif field_type == 'combobox':
 335:                 self.widget = ttk.Combobox(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 336:                 self._bind_combobox_clipboard_operations()
 337:             elif field_type == 'text':
 338:                 self.widget = tk.Text(self.frame, font=Fonts.DIALOG_LABEL, **kwargs)
 339:                 self._bind_text_clipboard_operations()
 340:             
 341:             self.widget.pack(side=tk.LEFT, fill=tk.X, expand=True)
 342:     
 343:     def _bind_clipboard_operations(self):
 344:         """Bind standard clipboard operations for Entry widgets"""
 345:         self.widget.bind('<Control-a>', lambda e: self.widget.select_range(0, 'end'))
 346:         self.widget.bind('<Control-A>', lambda e: self.widget.select_range(0, 'end'))
 347:         # Ctrl+C and Ctrl+V are automatically handled by tkinter Entry
 348:     
 349:     def _bind_combobox_clipboard_operations(self):
 350:         """Bind clipboard operations for Combobox widgets"""
 351:         # Combobox uses an internal Entry widget
 352:         self.widget.bind('<Control-a>', lambda e: self.widget.event_generate('<<SelectAll>>'))
 353:         self.widget.bind('<Control-A>', lambda e: self.widget.event_generate('<<SelectAll>>'))
 354:     
 355:     def _bind_text_clipboard_operations(self):
 356:         """Bind clipboard operations for Text widgets"""
 357:         self.widget.bind('<Control-a>', lambda e: self.widget.tag_add('sel', '1.0', 'end'))
 358:         self.widget.bind('<Control-A>', lambda e: self.widget.tag_add('sel', '1.0', 'end'))
 359:     
 360:     def pack(self, **kwargs):
 361:         """Pack the form field frame"""
 362:         self.frame.pack(**kwargs)
 363:     
 364:     def grid(self, **kwargs):
 365:         """Grid the form field frame"""
 366:         self.frame.grid(**kwargs)
 367:     
 368:     def get(self):
 369:         """Get the widget value"""
 370:         if isinstance(self.widget, tk.Text):
 371:             return self.widget.get('1.0', 'end-1c')
 372:         else:
 373:             return self.widget.get()
 374:     
 375:     def set(self, value):
 376:         """Set the widget value"""
 377:         if isinstance(self.widget, tk.Text):
 378:             self.widget.delete('1.0', 'end')
 379:             self.widget.insert('1.0', value)
 380:         elif isinstance(self.widget, ttk.Combobox):
 381:             self.widget.set(value)
 382:         else:
 383:             self.widget.delete(0, 'end')
 384:             self.widget.insert(0, value)
 385:     
 386:     def focus_set(self):
 387:         """Set focus to the widget"""
 388:         self.widget.focus_set()
 389: 
 390: 
 391: class CategoryHeader(tk.Frame):
 392:     """Styled category header for menus and dialogs"""
 393:     
 394:     def __init__(self, parent, text, bg_color=Colors.DARK_GREEN, fg_color=Colors.WHITE):
 395:         super().__init__(parent, bg=bg_color, height=25)
 396:         self.pack_propagate(False)
 397:         
 398:         self.label = tk.Label(self, text=text, bg=bg_color, fg=fg_color,
 399:                              font=Fonts.MENU_HEADER, anchor='w')
 400:         self.label.pack(side=tk.LEFT, padx=10, fill=tk.X, expand=True)
 401: 
 402: 
 403: class SectionDivider(tk.Frame):
 404:     """Horizontal divider for visual separation"""
 405:     
 406:     def __init__(self, parent, color=Colors.MEDIUM_GREEN, height=2):
 407:         super().__init__(parent, bg=color, height=height)
 408: 
 409: 
 410: class ScrollableFrame(tk.Frame):
 411:     """Frame with scrollbar support"""
 412:     
 413:     def __init__(self, parent, bg_color=Colors.LIGHT_GREEN, **kwargs):
 414:         container = tk.Frame(parent, bg=bg_color)
 415:         container.pack(fill=tk.BOTH, expand=True, **kwargs)
 416:         
 417:         # Create canvas and scrollbar
 418:         self.canvas = tk.Canvas(container, bg=bg_color, highlightthickness=0)
 419:         scrollbar = ttk.Scrollbar(container, orient="vertical", command=self.canvas.yview)
 420:         
 421:         # Create the scrollable frame
 422:         super().__init__(self.canvas, bg=bg_color)
 423:         self.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
 424:         
 425:         # Create window in canvas
 426:         self.canvas_window = self.canvas.create_window((0, 0), window=self, anchor="nw")
 427:         self.canvas.configure(yscrollcommand=scrollbar.set)
 428:         
 429:         # Pack elements
 430:         self.canvas.pack(side="left", fill="both", expand=True)
 431:         scrollbar.pack(side="right", fill="y")
 432:         
 433:         # Bind mousewheel
 434:         self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
 435:         
 436:         # Store reference to canvas
 437:         self.parent_canvas = self.canvas
 438:     
 439:     def _on_mousewheel(self, event):
 440:         """Handle mouse wheel scrolling"""
 441:         self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
 442:     
 443:     def update_scroll_region(self):
 444:         """Update the scroll region to encompass all widgets"""
 445:         self.canvas.configure(scrollregion=self.canvas.bbox("all"))
 446: 
 447: 
 448: class ToolTip:
 449:     """Simple tooltip implementation"""
 450:     
 451:     def __init__(self, widget, text):
 452:         self.widget = widget
 453:         self.text = text
 454:         self.tooltip = None
 455:         self.widget.bind("<Enter>", self.show_tooltip)
 456:         self.widget.bind("<Leave>", self.hide_tooltip)
 457:     
 458:     def show_tooltip(self, event=None):
 459:         """Show the tooltip"""
 460:         x, y, _, _ = self.widget.bbox("insert")
 461:         x += self.widget.winfo_rootx() + 25
 462:         y += self.widget.winfo_rooty() + 25
 463:         
 464:         self.tooltip = tk.Toplevel(self.widget)
 465:         self.tooltip.wm_overrideredirect(True)
 466:         self.tooltip.wm_geometry(f"+{x}+{y}")
 467:         
 468:         label = tk.Label(self.tooltip, text=self.text, bg=Colors.LIGHT_GREEN,
 469:                         fg=Colors.BLACK, relief=tk.SOLID, borderwidth=1,
 470:                         font=("Arial", 9))
 471:         label.pack()
 472:     
 473:     def hide_tooltip(self, event=None):
 474:         """Hide the tooltip"""
 475:         if self.tooltip:
 476:             self.tooltip.destroy()
 477:             self.tooltip = None
 478: 
 479: 
 480: # Utility functions
 481: 
 482: class UIUtils:
 483:     """Static utility methods for UI operations"""
 484:     
 485:     @staticmethod
 486:     def center_window(window, width=None, height=None):
 487:         """Center a window on screen"""
 488:         window.update_idletasks()
 489:         
 490:         # Get window size
 491:         if width is None:
 492:             width = window.winfo_width()
 493:         if height is None:
 494:             height = window.winfo_height()
 495:         
 496:         # Calculate position
 497:         x = (window.winfo_screenwidth() // 2) - (width // 2)
 498:         y = (window.winfo_screenheight() // 2) - (height // 2)
 499:         
 500:         window.geometry(f"{width}x{height}+{x}+{y}")
 501:     
 502:     @staticmethod
 503:     def create_hover_effect(widget, enter_bg, leave_bg, enter_fg=None, leave_fg=None):
 504:         """Create hover effect for a widget"""
 505:         def on_enter(event):
 506:             widget.config(bg=enter_bg)
 507:             if enter_fg:
 508:                 widget.config(fg=enter_fg)
 509:         
 510:         def on_leave(event):
 511:             widget.config(bg=leave_bg)
 512:             if leave_fg:
 513:                 widget.config(fg=leave_fg)
 514:         
 515:         widget.bind("<Enter>", on_enter)
 516:         widget.bind("<Leave>", on_leave)
 517:         
 518:         return on_enter, on_leave
 519:     
 520:     @staticmethod
 521:     def create_separator(parent, bg_color, width=2):
 522:         """Create a vertical separator"""
 523:         import tkinter as tk
 524:         separator = tk.Frame(parent, bg=bg_color, width=width)
 525:         return separator

────────────────────────────────────────────────────────────────────────────────
FILE: utils.py
────────────────────────────────────────────────────────────────────────────────
Path: utils.py
Size: 7.0 KB
Lines: 211 total, 182 non-empty
Characters: 6,974
Type: Utility functions and helper classes
────────────────────────────────────────────────────────────────────────────────

   1: # utils.py
   2: """
   3: Utility functions for SuiteView Taskbar Application
   4: Contains Windows API calls, file operations, and common helper functions
   5: """
   6: 
   7: import ctypes
   8: from ctypes import wintypes
   9: import os
  10: import webbrowser
  11: from pathlib import Path
  12: from config import WindowsAPI
  13: 
  14: class WindowsUtils:
  15:     """Windows-specific utility functions"""
  16:     
  17:     @staticmethod
  18:     def get_windows_taskbar_height():
  19:         """Get the height of Windows taskbar"""
  20:         try:
  21:             work_area = wintypes.RECT()
  22:             ctypes.windll.user32.SystemParametersInfoW(
  23:                 WindowsAPI.SPI_GETWORKAREA, 0, ctypes.byref(work_area), 0
  24:             )
  25:             screen_height = ctypes.windll.user32.GetSystemMetrics(1)  # SM_CYSCREEN
  26:             taskbar_height = screen_height - work_area.bottom
  27:             return taskbar_height if taskbar_height > 0 else 40
  28:         except:
  29:             return 40
  30:     
  31:     @staticmethod
  32:     def get_screen_dimensions():
  33:         """Get screen width and height"""
  34:         try:
  35:             width = ctypes.windll.user32.GetSystemMetrics(0)   # SM_CXSCREEN
  36:             height = ctypes.windll.user32.GetSystemMetrics(1)  # SM_CYSCREEN
  37:             return width, height
  38:         except:
  39:             # Fallback values
  40:             return 1920, 1080
  41:     
  42:     @staticmethod
  43:     def set_window_topmost(window_id):
  44:         """Force window to stay on top using Windows API"""
  45:         try:
  46:             hwnd = ctypes.windll.user32.GetParent(window_id)
  47:             ctypes.windll.user32.SetWindowPos(
  48:                 hwnd, WindowsAPI.HWND_TOPMOST, 0, 0, 0, 0, 
  49:                 WindowsAPI.SWP_NOMOVE | WindowsAPI.SWP_NOSIZE
  50:             )
  51:         except:
  52:             pass
  53:     
  54:     @staticmethod
  55:     def get_work_area():
  56:         """Get current desktop work area"""
  57:         work_area = wintypes.RECT()
  58:         try:
  59:             ctypes.windll.user32.SystemParametersInfoW(
  60:                 WindowsAPI.SPI_GETWORKAREA, 0, ctypes.byref(work_area), 0
  61:             )
  62:             return work_area
  63:         except:
  64:             return None
  65:     
  66:     @staticmethod
  67:     def set_work_area(rect):
  68:         """Set desktop work area"""
  69:         try:
  70:             ctypes.windll.user32.SystemParametersInfoW(
  71:                 WindowsAPI.SPI_SETWORKAREA, 0, ctypes.byref(rect), 0
  72:             )
  73:             return True
  74:         except:
  75:             return False
  76:     
  77:     @staticmethod
  78:     def restore_work_area(original_rect):
  79:         """Restore original work area with proper flags"""
  80:         try:
  81:             ctypes.windll.user32.SystemParametersInfoW(
  82:                 WindowsAPI.SPI_SETWORKAREA, 0, ctypes.byref(original_rect), 
  83:                 WindowsAPI.SPIF_SENDCHANGE
  84:             )
  85:             return True
  86:         except:
  87:             return False
  88: 
  89: class FileUtils:
  90:     """File and path utility functions"""
  91:     
  92:     @staticmethod
  93:     def normalize_path(path):
  94:         """
  95:         Convert any path to Windows format with backslashes
  96:         Handles forward slashes, mixed slashes, and Path objects
  97:         """
  98:         if not path:
  99:             return ""
 100:         
 101:         # Convert Path object to string first
 102:         if isinstance(path, Path):
 103:             path = str(path)
 104:         
 105:         # Convert string paths
 106:         path_str = str(path).strip()
 107:         
 108:         # Skip URLs
 109:         if path_str.startswith(('http://', 'https://', 'www.')):
 110:             return path_str
 111:         
 112:         # Convert forward slashes to backslashes and normalize
 113:         normalized = os.path.normpath(path_str.replace('/', '\\'))
 114:         
 115:         return normalized
 116:     
 117:     @staticmethod
 118:     def open_path(path, parent=None):
 119:         """Open a file, folder, or URL"""
 120:         try:
 121:             # Normalize the path first
 122:             normalized_path = FileUtils.normalize_path(path)
 123:             
 124:             if normalized_path.startswith(('http://', 'https://', 'www.')):
 125:                 webbrowser.open(normalized_path)
 126:                 return True
 127:             elif os.path.exists(normalized_path):
 128:                 os.startfile(normalized_path)
 129:                 return True
 130:             else:
 131:                 FileUtils._show_error(parent, "Error", f"Path not found: {normalized_path}")
 132:                 return False
 133:         except Exception as e:
 134:             FileUtils._show_error(parent, "Error", f"Could not open: {str(e)}")
 135:             return False
 136:     
 137:     @staticmethod
 138:     def _show_error(parent, title, message):
 139:         """Show error dialog - uses custom dialog if parent provided, fallback to messagebox"""
 140:         if parent:
 141:             try:
 142:                 # Import here to avoid circular imports
 143:                 from ui_components import ErrorDialog
 144:                 ErrorDialog.show(parent, title, message)
 145:             except ImportError:
 146:                 # Fallback to standard messagebox if ui_components not available
 147:                 from tkinter import messagebox
 148:                 messagebox.showerror(title, message)
 149:         else:
 150:             # No parent provided, use console output
 151:             print(f"{title}: {message}")
 152:     
 153:     @staticmethod
 154:     def validate_path(path):
 155:         """Validate if a path exists or is a valid URL"""
 156:         if not path or not path.strip():
 157:             return False
 158:         
 159:         path = path.strip()
 160:         
 161:         # Check if it's a URL
 162:         if path.startswith(('http://', 'https://', 'www.')):
 163:             return True
 164:         
 165:         # Check if file/folder exists
 166:         return os.path.exists(path)
 167: 
 168: class UIUtils:
 169:     """UI-related utility functions"""
 170:     
 171:     @staticmethod
 172:     def center_window(window, width, height):
 173:         """Center a window on screen"""
 174:         screen_width = window.winfo_screenwidth()
 175:         screen_height = window.winfo_screenheight()
 176:         x = (screen_width - width) // 2
 177:         y = (screen_height - height) // 2
 178:         window.geometry(f"{width}x{height}+{x}+{y}")
 179:     
 180:     @staticmethod
 181:     def apply_hover_effect(widget, normal_bg, hover_bg, normal_fg='black', hover_fg='white'):
 182:         """Apply hover effect to a widget"""
 183:         def on_enter(e):
 184:             widget.configure(bg=hover_bg, fg=hover_fg)
 185:             # Apply to children if they exist
 186:             for child in widget.winfo_children():
 187:                 try:
 188:                     child.configure(bg=hover_bg, fg=hover_fg)
 189:                 except:
 190:                     pass
 191:         
 192:         def on_leave(e):
 193:             widget.configure(bg=normal_bg, fg=normal_fg)
 194:             # Apply to children if they exist
 195:             for child in widget.winfo_children():
 196:                 try:
 197:                     child.configure(bg=normal_bg, fg=normal_fg)
 198:                 except:
 199:                     pass
 200:         
 201:         widget.bind("<Enter>", on_enter)
 202:         widget.bind("<Leave>", on_leave)
 203:         
 204:         return on_enter, on_leave
 205:     
 206:     @staticmethod
 207:     def create_separator(parent, bg_color, width=2):
 208:         """Create a vertical separator"""
 209:         import tkinter as tk
 210:         separator = tk.Frame(parent, bg=bg_color, width=width)
 211:         return separator

────────────────────────────────────────────────────────────────────────────────
FILE: window_factory.py
────────────────────────────────────────────────────────────────────────────────
Path: window_factory.py
Size: 23.0 KB
Lines: 657 total, 545 non-empty
Characters: 22,898
Type: Window factory for creating UI elements
────────────────────────────────────────────────────────────────────────────────

   1: # window_factory.py
   2: """
   3: Window Factory for SuiteView Taskbar Application
   4: Provides base classes and factory functions for creating consistent windows
   5: Updated with proper click-outside detection
   6: """
   7: 
   8: import tkinter as tk
   9: from abc import ABC, abstractmethod
  10: from config import Colors, Fonts
  11: 
  12: # Window type behavior definitions
  13: WINDOW_BEHAVIORS = {
  14:     "context_menu": {
  15:         "description": "Right-click menus for item-specific actions",
  16:         "modality": "non-modal",
  17:         "focus": "temporary",
  18:         "topmost": "always",
  19:         "draggable": False,
  20:         "resizable": "none",
  21:         "persistence": "none",
  22:         "close_on": ["click_outside", "select_option", "escape"],
  23:         "titlebar": False,
  24:         "dockable": False,
  25:     },
  26:     
  27:     "taskbar_menu": {
  28:         "description": "Popup menus from taskbar buttons",
  29:         "modality": "non-modal",
  30:         "focus": "temporary", 
  31:         "topmost": "always",
  32:         "draggable": False,
  33:         "resizable": "vertical",
  34:         "persistence": "none",
  35:         "close_on": ["click_outside", "select_option", "escape", "toggle_button"],
  36:         "titlebar": False,
  37:         "dockable": False,
  38:     },
  39:     
  40:     "action_dialog": {
  41:         "description": "Modal dialogs requiring user decision",
  42:         "modality": "modal",
  43:         "focus": "blocking",
  44:         "topmost": "always",
  45:         "draggable": True,
  46:         "resizable": "none",
  47:         "persistence": "none",
  48:         "close_on": ["button_action"],
  49:         "titlebar": True,
  50:         "dockable": False,
  51:     },
  52:     
  53:     "notification_dialog": {
  54:         "description": "Non-blocking status/progress windows",
  55:         "modality": "non-modal",
  56:         "focus": "non-stealing",
  57:         "topmost": "never",
  58:         "draggable": True,
  59:         "resizable": "none",
  60:         "persistence": "none",
  61:         "close_on": ["x_button", "auto_complete", "escape"],
  62:         "titlebar": True,
  63:         "dockable": False,
  64:     },
  65:     
  66:     "floating_window": {
  67:         "description": "Independent tool windows",
  68:         "modality": "non-modal",
  69:         "focus": "independent",
  70:         "topmost": "optional",
  71:         "draggable": True,
  72:         "resizable": "all",
  73:         "persistence": "none",
  74:         "close_on": ["x_button", "button_action"],
  75:         "titlebar": True,
  76:         "dockable": False,
  77:     },
  78:     
  79:     "feature_window": {
  80:         "description": "Major feature windows with docking capability",
  81:         "modality": "non-modal",
  82:         "focus": "independent",
  83:         "topmost": "optional",
  84:         "draggable": True,
  85:         "resizable": "all",
  86:         "persistence": "session",
  87:         "close_on": ["x_button", "button_action"],
  88:         "titlebar": True,
  89:         "dockable": True,
  90:     }
  91: }
  92: 
  93: 
  94: class BaseWindow(tk.Toplevel, ABC):
  95:     """
  96:     Base class for all SuiteView windows
  97:     Provides consistent behavior based on window type
  98:     """
  99:     
 100:     # Class variable to track window positions for session persistence
 101:     _saved_positions = {}
 102:     
 103:     def __init__(self, parent, title, window_type, **kwargs):
 104:         """
 105:         Initialize base window
 106:         
 107:         Args:
 108:             parent: Parent window
 109:             title: Window title
 110:             window_type: One of the defined window types
 111:             **kwargs: Additional arguments (x, y, width, height, etc.)
 112:         """
 113:         super().__init__(parent)
 114:         
 115:         # Validate window type
 116:         if window_type not in WINDOW_BEHAVIORS:
 117:             raise ValueError(f"Invalid window type: {window_type}")
 118:         
 119:         # Store references
 120:         self.parent = parent
 121:         self.window_type = window_type
 122:         self.behavior = WINDOW_BEHAVIORS[window_type]
 123:         self.title_text = title
 124:         
 125:         # Extract positioning info from kwargs
 126:         self.initial_x = kwargs.pop('x', None)
 127:         self.initial_y = kwargs.pop('y', None)
 128:         self.initial_width = kwargs.pop('width', None)
 129:         self.initial_height = kwargs.pop('height', None)
 130:         self.trigger_button = kwargs.pop('button', None)
 131:         
 132:         # Window state
 133:         self.is_pinned = False
 134:         self.is_docked = False
 135:         self.is_dragging = False
 136:         self.drag_start_x = 0
 137:         self.drag_start_y = 0
 138:         
 139:         # Click outside detection state
 140:         self._global_click_binding = None
 141:         self._click_detection_active = False
 142:         
 143:         # Store remaining kwargs for subclass use
 144:         self.kwargs = kwargs
 145:         
 146:         # Set window title
 147:         self.title(title)
 148:         
 149:         # Apply window configuration
 150:         self._configure_window()
 151:         
 152:         # Create window structure
 153:         self._create_window_structure()
 154:         
 155:         # Apply window behaviors
 156:         self._apply_behaviors()
 157:         
 158:         # Allow subclasses to create their content
 159:         self.create_content()
 160:         
 161:         # Position the window
 162:         self._position_window()
 163:         
 164:         # Final setup
 165:         self._finalize_setup()
 166:     
 167:     def _configure_window(self):
 168:         """Apply basic window configuration based on behavior"""
 169:         # Remove window decorations if no titlebar
 170:         if not self.behavior["titlebar"]:
 171:             self.overrideredirect(True)
 172:         
 173:         # Set resizable behavior
 174:         resizable = self.behavior["resizable"]
 175:         if resizable == "none":
 176:             self.resizable(False, False)
 177:         elif resizable == "all":
 178:             self.resizable(True, True)
 179:         elif resizable == "horizontal":
 180:             self.resizable(True, False)
 181:         elif resizable == "vertical":
 182:             self.resizable(False, True)
 183:         
 184:         # Set initial size if provided
 185:         if self.initial_width and self.initial_height:
 186:             self.geometry(f"{self.initial_width}x{self.initial_height}")
 187:     
 188:     def _create_window_structure(self):
 189:         """Create the basic window structure"""
 190:         # Create main container
 191:         self.main_container = tk.Frame(self, bg=Colors.DARK_GREEN)
 192:         self.main_container.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
 193:         
 194:         # Create titlebar if needed
 195:         if self.behavior["titlebar"]:
 196:             self._create_custom_titlebar()
 197:         
 198:         # Create content frame
 199:         self.content_frame = tk.Frame(self.main_container, bg=Colors.LIGHT_GREEN)
 200:         self.content_frame.pack(fill=tk.BOTH, expand=True)
 201:     
 202:     def _create_custom_titlebar(self):
 203:         """Create custom titlebar with standard elements"""
 204:         self.titlebar = tk.Frame(self.main_container, bg=Colors.DARK_GREEN, height=30)
 205:         self.titlebar.pack(fill=tk.X)
 206:         self.titlebar.pack_propagate(False)
 207:         
 208:         # Title label
 209:         self.title_label = tk.Label(self.titlebar, text=self.title_text,
 210:                                    bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 211:                                    font=Fonts.DIALOG_TITLE)
 212:         self.title_label.pack(side=tk.LEFT, padx=10, pady=5)
 213:         
 214:         # Close button if needed
 215:         if "x_button" in self.behavior["close_on"]:
 216:             self.close_btn = tk.Label(self.titlebar, text="×",
 217:                                      bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 218:                                      font=("Arial", 16, "bold"), cursor="hand2")
 219:             self.close_btn.pack(side=tk.RIGHT, padx=5)
 220:             self.close_btn.bind("<Button-1>", lambda e: self.close_window())
 221:         
 222:         # Pin button for optional topmost
 223:         if self.behavior["topmost"] == "optional":
 224:             self.pin_btn = tk.Label(self.titlebar, text="📌",
 225:                                    bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 226:                                    font=("Arial", 12), cursor="hand2")
 227:             self.pin_btn.pack(side=tk.RIGHT, padx=5)
 228:             self.pin_btn.bind("<Button-1>", self._toggle_pin)
 229:         
 230:         # Make titlebar draggable if window is draggable
 231:         if self.behavior["draggable"]:
 232:             self._make_draggable(self.titlebar)
 233:             self._make_draggable(self.title_label)
 234:     
 235:     def _apply_behaviors(self):
 236:         """Apply window behaviors based on configuration"""
 237:         # Modality
 238:         if self.behavior["modality"] == "modal":
 239:             self.transient(self.parent)
 240:             self.grab_set()
 241:         
 242:         # Focus behavior
 243:         focus_type = self.behavior["focus"]
 244:         if focus_type == "blocking":
 245:             self.focus_force()
 246:         elif focus_type == "temporary":
 247:             self.focus_set()
 248:         elif focus_type == "independent":
 249:             # Normal focus behavior, no special handling
 250:             pass
 251:         elif focus_type == "non-stealing":
 252:             # Don't take focus at all
 253:             pass
 254:         
 255:         # Topmost behavior
 256:         topmost = self.behavior["topmost"]
 257:         if topmost == "always":
 258:             self.attributes("-topmost", True)
 259:         elif topmost == "never":
 260:             self.attributes("-topmost", False)
 261:         elif topmost == "optional":
 262:             # Start unpinned
 263:             self.attributes("-topmost", False)
 264:         
 265:         # Close handlers
 266:         self._setup_close_handlers()
 267:         
 268:         # Bind Escape key if needed
 269:         if "escape" in self.behavior["close_on"]:
 270:             self.bind("<Escape>", lambda e: self.close_window())
 271:     
 272:     def _setup_close_handlers(self):
 273:         """Set up various close handlers based on behavior"""
 274:         close_on = self.behavior["close_on"]
 275:         
 276:         # Click outside handler - now properly implemented
 277:         if "click_outside" in close_on:
 278:             self._setup_click_outside_detection()
 279:         
 280:         # Window delete protocol
 281:         if self.behavior["titlebar"] and "x_button" in close_on:
 282:             self.protocol("WM_DELETE_WINDOW", self.close_window)
 283:     
 284:     def _setup_click_outside_detection(self):
 285:         """Set up proper click outside detection"""
 286:         # Get the root window (main taskbar window)
 287:         root = self._get_root_window()
 288:         if not root:
 289:             print(f"Warning: Could not set up click outside detection for {self.window_type}")
 290:             return
 291:         
 292:         # Create binding identifier unique to this window
 293:         self._click_binding_id = f"<Button-1>-{id(self)}"
 294:         
 295:         # Bind to root window with a unique identifier
 296:         root.bind("<Button-1>", self._handle_global_click, "+")
 297:         self._global_click_binding = root
 298:         self._click_detection_active = True
 299:         
 300:         # Bind to self to prevent closing when clicking inside
 301:         self.bind("<Button-1>", self._handle_inside_click)
 302:     
 303:     def _get_root_window(self):
 304:         """Get the root window (taskbar) safely"""
 305:         try:
 306:             # Walk up the parent chain to find the root
 307:             window = self.parent
 308:             while window:
 309:                 if isinstance(window, tk.Tk):
 310:                     return window
 311:                 # Check if it has a root attribute (taskbar reference)
 312:                 if hasattr(window, 'root') and isinstance(window.root, tk.Tk):
 313:                     return window.root
 314:                 # Try to go up the chain
 315:                 if hasattr(window, 'parent'):
 316:                     window = window.parent
 317:                 elif hasattr(window, 'master'):
 318:                     window = window.master
 319:                 else:
 320:                     break
 321:             
 322:             # Fallback: try to get the Tk instance
 323:             return self.winfo_toplevel() if hasattr(self, 'winfo_toplevel') else None
 324:             
 325:         except Exception as e:
 326:             print(f"Error getting root window: {e}")
 327:             return None
 328:     
 329:     def _handle_inside_click(self, event):
 330:         """Handle clicks inside the window - prevent propagation"""
 331:         # Stop the event from propagating to the global handler
 332:         return "break"
 333:     
 334:     def _handle_global_click(self, event):
 335:         """Handle global clicks to detect outside clicks"""
 336:         if not self._click_detection_active:
 337:             return
 338:         
 339:         try:
 340:             # Get the widget that was clicked
 341:             clicked_widget = event.widget
 342:             
 343:             # Check if the click was on this window or any of its children
 344:             widget = clicked_widget
 345:             while widget:
 346:                 if widget == self:
 347:                     # Click was inside this window
 348:                     return
 349:                 try:
 350:                     widget = widget.master
 351:                 except:
 352:                     break
 353:             
 354:             # Special handling for trigger button (allows toggle behavior)
 355:             if hasattr(self, 'trigger_button') and self.trigger_button:
 356:                 widget = clicked_widget
 357:                 while widget:
 358:                     if widget == self.trigger_button:
 359:                         # Click was on trigger button
 360:                         self.close_window()
 361:                         return
 362:                     try:
 363:                         widget = widget.master
 364:                     except:
 365:                         break
 366:             
 367:             # Click was outside - close the window
 368:             self.close_window()
 369:             
 370:         except Exception as e:
 371:             print(f"Error in global click handler: {e}")
 372:     
 373:     def _make_draggable(self, widget):
 374:         """Make a widget draggable"""
 375:         widget.bind("<Button-1>", self._start_drag)
 376:         widget.bind("<B1-Motion>", self._drag_window)
 377:         widget.bind("<ButtonRelease-1>", self._stop_drag)
 378:         widget.configure(cursor="fleur")
 379:     
 380:     def _start_drag(self, event):
 381:         """Start dragging the window"""
 382:         if self.behavior["draggable"] and not self.is_docked:
 383:             self.is_dragging = True
 384:             self.drag_start_x = event.x
 385:             self.drag_start_y = event.y
 386:     
 387:     def _drag_window(self, event):
 388:         """Handle window dragging"""
 389:         if self.is_dragging and self.behavior["draggable"]:
 390:             x = self.winfo_x() + (event.x - self.drag_start_x)
 391:             y = self.winfo_y() + (event.y - self.drag_start_y)
 392:             self.geometry(f"+{x}+{y}")
 393:     
 394:     def _stop_drag(self, event):
 395:         """Stop dragging"""
 396:         self.is_dragging = False
 397:         # Check for docking if supported
 398:         if self.behavior["dockable"]:
 399:             self._check_dock_position()
 400:     
 401:     def _toggle_pin(self, event=None):
 402:         """Toggle window pinned state"""
 403:         self.is_pinned = not self.is_pinned
 404:         self.attributes("-topmost", self.is_pinned)
 405:         
 406:         # Update pin button appearance
 407:         if hasattr(self, 'pin_btn'):
 408:             if self.is_pinned:
 409:                 self.pin_btn.config(text="📍", fg=Colors.WHITE)
 410:             else:
 411:                 self.pin_btn.config(text="📌", fg=Colors.WHITE)
 412:     
 413:     def _position_window(self):
 414:         """Position window based on type and parameters"""
 415:         self.update_idletasks()  # Ensure geometry is calculated
 416:         
 417:         # Check for saved position if persistence is enabled
 418:         if self.behavior["persistence"] == "session":
 419:             saved_pos = self._saved_positions.get(self.__class__.__name__)
 420:             if saved_pos:
 421:                 self.geometry(saved_pos)
 422:                 return
 423:         
 424:         # Position based on window type
 425:         if self.window_type == "context_menu":
 426:             self._position_at_cursor()
 427:         elif self.window_type == "taskbar_menu":
 428:             self._position_above_button()
 429:         elif self.window_type in ["action_dialog", "notification_dialog"]:
 430:             if self.behavior["focus"] == "non-stealing":
 431:                 self._position_offset_center()
 432:             else:
 433:                 self._position_center_parent()
 434:         else:  # floating_window, feature_window
 435:             if self.initial_x is not None and self.initial_y is not None:
 436:                 self.geometry(f"+{self.initial_x}+{self.initial_y}")
 437:             else:
 438:                 self._position_center_screen()
 439:     
 440:     def _position_at_cursor(self):
 441:         """Position window at cursor location"""
 442:         x = self.initial_x or self.winfo_pointerx()
 443:         y = self.initial_y or self.winfo_pointery()
 444:         
 445:         # Adjust to keep on screen
 446:         x, y = self._adjust_position_for_screen(x, y)
 447:         self.geometry(f"+{x}+{y}")
 448:     
 449:     def _position_above_button(self):
 450:         """Position window above triggering button"""
 451:         if self.trigger_button:
 452:             btn_x = self.trigger_button.winfo_rootx()
 453:             btn_y = self.trigger_button.winfo_rooty()
 454:             
 455:             # Position above button
 456:             win_height = self.winfo_reqheight()
 457:             x = btn_x
 458:             y = btn_y - win_height
 459:             
 460:             # Adjust to keep on screen
 461:             x, y = self._adjust_position_for_screen(x, y)
 462:             self.geometry(f"+{x}+{y}")
 463:         else:
 464:             self._position_center_screen()
 465:     
 466:     def _position_center_parent(self):
 467:         """Center window over parent"""
 468:         parent_x = self.parent.winfo_rootx()
 469:         parent_y = self.parent.winfo_rooty()
 470:         parent_w = self.parent.winfo_width()
 471:         parent_h = self.parent.winfo_height()
 472:         
 473:         win_w = self.winfo_width()
 474:         win_h = self.winfo_height()
 475:         
 476:         x = parent_x + (parent_w - win_w) // 2
 477:         y = parent_y + (parent_h - win_h) // 2
 478:         
 479:         # Adjust to keep on screen
 480:         x, y = self._adjust_position_for_screen(x, y)
 481:         self.geometry(f"+{x}+{y}")
 482:     
 483:     def _position_center_screen(self):
 484:         """Center window on screen"""
 485:         win_w = self.winfo_width()
 486:         win_h = self.winfo_height()
 487:         screen_w = self.winfo_screenwidth()
 488:         screen_h = self.winfo_screenheight()
 489:         
 490:         x = (screen_w - win_w) // 2
 491:         y = (screen_h - win_h) // 2
 492:         
 493:         self.geometry(f"+{x}+{y}")
 494:     
 495:     def _position_offset_center(self):
 496:         """Position window offset from center"""
 497:         self._position_center_screen()
 498:         
 499:         # Offset slightly
 500:         x = self.winfo_x() + 50
 501:         y = self.winfo_y() - 50
 502:         
 503:         # Adjust to keep on screen
 504:         x, y = self._adjust_position_for_screen(x, y)
 505:         self.geometry(f"+{x}+{y}")
 506:     
 507:     def _adjust_position_for_screen(self, x, y):
 508:         """Adjust position to ensure window stays on screen"""
 509:         win_w = self.winfo_width()
 510:         win_h = self.winfo_height()
 511:         screen_w = self.winfo_screenwidth()
 512:         screen_h = self.winfo_screenheight()
 513:         
 514:         # Adjust x
 515:         if x < 0:
 516:             x = 0
 517:         elif x + win_w > screen_w:
 518:             x = screen_w - win_w
 519:         
 520:         # Adjust y
 521:         if y < 0:
 522:             y = 0
 523:         elif y + win_h > screen_h:
 524:             y = screen_h - win_h
 525:         
 526:         return x, y
 527:     
 528:     def _check_dock_position(self):
 529:         """Check if window should dock to screen edge"""
 530:         if not self.behavior["dockable"]:
 531:             return
 532:         
 533:         x = self.winfo_x()
 534:         y = self.winfo_y()
 535:         screen_w = self.winfo_screenwidth()
 536:         screen_h = self.winfo_screenheight()
 537:         
 538:         dock_threshold = 20  # Pixels from edge to trigger docking
 539:         
 540:         # Check for edge docking
 541:         if x < dock_threshold:
 542:             self.dock_to_edge("left")
 543:         elif x + self.winfo_width() > screen_w - dock_threshold:
 544:             self.dock_to_edge("right")
 545:         elif y < dock_threshold:
 546:             self.dock_to_edge("top")
 547:         elif y + self.winfo_height() > screen_h - dock_threshold:
 548:             self.dock_to_edge("bottom")
 549:     
 550:     def dock_to_edge(self, edge):
 551:         """Dock window to specified screen edge"""
 552:         if not self.behavior["dockable"]:
 553:             return
 554:         
 555:         screen_w = self.winfo_screenwidth()
 556:         screen_h = self.winfo_screenheight()
 557:         win_w = self.winfo_width()
 558:         win_h = self.winfo_height()
 559:         
 560:         if edge == "left":
 561:             self.geometry(f"{win_w}x{screen_h}+0+0")
 562:         elif edge == "right":
 563:             self.geometry(f"{win_w}x{screen_h}+{screen_w-win_w}+0")
 564:         elif edge == "top":
 565:             self.geometry(f"{screen_w}x{win_h}+0+0")
 566:         elif edge == "bottom":
 567:             self.geometry(f"{screen_w}x{win_h}+0+{screen_h-win_h}")
 568:         
 569:         self.is_docked = True
 570:     
 571:     def undock(self):
 572:         """Undock window from edge"""
 573:         self.is_docked = False
 574:         # Restore to previous size/position or center
 575:         self._position_center_screen()
 576:     
 577:     def _finalize_setup(self):
 578:         """Final setup after window is created"""
 579:         # Ensure window is visible
 580:         self.update()
 581:         
 582:         # Apply any final adjustments
 583:         if self.behavior["focus"] == "non-stealing":
 584:             # Ensure parent keeps focus
 585:             self.parent.focus_set()
 586:     
 587:     def close_window(self):
 588:         """Close the window with appropriate cleanup"""
 589:         # Clean up click outside detection first
 590:         self._cleanup_click_detection()
 591:         
 592:         # Save position if persistence is enabled
 593:         if self.behavior["persistence"] == "session":
 594:             self._saved_positions[self.__class__.__name__] = self.geometry()
 595:         
 596:         # Release grab if modal
 597:         if self.behavior["modality"] == "modal":
 598:             try:
 599:                 self.grab_release()
 600:             except:
 601:                 pass
 602:         
 603:         # Call any subclass cleanup
 604:         self.on_closing()
 605:         
 606:         # Destroy window
 607:         self.destroy()
 608:     
 609:     def _cleanup_click_detection(self):
 610:         """Clean up click outside detection bindings"""
 611:         if self._click_detection_active and self._global_click_binding:
 612:             try:
 613:                 # Unbind our global click handler
 614:                 # Note: This unbinds ALL Button-1 handlers, so be careful
 615:                 # In a real app, you'd want a more sophisticated binding management
 616:                 self._global_click_binding.unbind("<Button-1>")
 617:                 self._click_detection_active = False
 618:             except Exception as e:
 619:                 print(f"Error cleaning up click detection: {e}")
 620:     
 621:     def on_closing(self):
 622:         """Override in subclass for cleanup before closing"""
 623:         pass
 624:     
 625:     @abstractmethod
 626:     def create_content(self):
 627:         """
 628:         Subclasses must implement this to create their content
 629:         Content should be added to self.content_frame
 630:         """
 631:         pass
 632: 
 633: 
 634: # Factory function
 635: def create_window(window_type, parent, title, **kwargs):
 636:     """
 637:     Factory function to create a window of specified type
 638:     
 639:     Args:
 640:         window_type: One of the defined window types
 641:         parent: Parent window
 642:         title: Window title
 643:         **kwargs: Additional parameters
 644:     
 645:     Returns:
 646:         BaseWindow subclass instance
 647:     
 648:     Note: This is a convenience function. For complex windows,
 649:     create a proper subclass of BaseWindow instead.
 650:     """
 651:     
 652:     class GenericWindow(BaseWindow):
 653:         def create_content(self):
 654:             # Empty content - should be overridden
 655:             pass
 656:     
 657:     return GenericWindow(parent, title, window_type, **kwargs)

────────────────────────────────────────────────────────────────────────────────
FILE: window_manager.py
────────────────────────────────────────────────────────────────────────────────
Path: window_manager.py
Size: 13.6 KB
Lines: 336 total, 276 non-empty
Characters: 13,540
Type: Window management and visibility controls
────────────────────────────────────────────────────────────────────────────────

   1: # window_manager.py (fixed)
   2: """
   3: Windows detection and management functionality for SuiteView Taskbar
   4: Handles window enumeration, filtering, hiding/showing, and pinning
   5: Fixed to properly restore minimized windows
   6: """
   7: 
   8: import win32gui
   9: import win32api
  10: import win32con
  11: import win32process
  12: import psutil
  13: import re
  14: from config import AppColors
  15: 
  16: class ManagedWindow:
  17:     """Represents a managed window with its state and color coding"""
  18:     
  19:     def __init__(self, hwnd: int, title: str, process_name: str):
  20:         self.hwnd = hwnd
  21:         self.title = title
  22:         self.process_name = process_name
  23:         self.app_name = self._extract_app_name()
  24:         self.display_name = self._create_display_name()
  25:         self.is_hidden = False
  26:         self.is_pinned = False
  27:         self.original_ex_style = win32gui.GetWindowLong(hwnd, win32con.GWL_EXSTYLE)
  28:         
  29:         # Add color support
  30:         from config import AppColors
  31:         self.colors = self._get_window_colors()
  32:     
  33:     def _extract_app_name(self) -> str:
  34:         """Extract application name from process name"""
  35:         # Remove .exe extension
  36:         app = self.process_name.replace('.exe', '')
  37:         
  38:         # Capitalize common apps
  39:         common_apps = {
  40:             'chrome': 'Chrome',
  41:             'firefox': 'Firefox',
  42:             'winword': 'Word',
  43:             'excel': 'Excel',
  44:             'powerpnt': 'PowerPoint',
  45:             'outlook': 'Outlook',
  46:             'notepad': 'Notepad',
  47:             'notepad++': 'Notepad++',
  48:             'code': 'VS Code',
  49:             'devenv': 'Visual Studio',
  50:             'acrobat': 'Acrobat',
  51:             'acrord32': 'Acrobat Reader',
  52:             'explorer': 'File Explorer',
  53:             'cursor': 'Cursor'
  54:         }
  55:         
  56:         return common_apps.get(app.lower(), app.title())
  57:     
  58:     def _create_display_name(self) -> str:
  59:         """Create display name WITHOUT app prefix and with cleaned tab counts"""
  60:         # Remove app name from title if it's at the beginning
  61:         if self.title.startswith(self.app_name + " - "):
  62:             display_name = self.title[len(self.app_name) + 3:]  # Remove "AppName - "
  63:         elif self.title.startswith(self.app_name):
  64:             # Some apps don't use " - " separator
  65:             display_name = self.title[len(self.app_name):].lstrip(" -")
  66:         else:
  67:             display_name = self.title
  68:         
  69:         # For some apps, the title format might be different
  70:         # Remove common patterns
  71:         patterns_to_remove = [
  72:             f" - {self.app_name}",  # "Document - Word"
  73:             f" – {self.app_name}",  # Em dash variant
  74:             f" — {self.app_name}",  # Em dash variant
  75:         ]
  76:         
  77:         for pattern in patterns_to_remove:
  78:             if display_name.endswith(pattern):
  79:                 display_name = display_name[:-len(pattern)]
  80:                 break
  81:         
  82:         # Clean up browser tab counts
  83:         # Replace "and X more tabs" with "(+X)"
  84:         import re
  85:         
  86:         # Pattern to match "and X more tab" or "and X more tabs"
  87:         tab_pattern = r' and (\d+) more tabs?'
  88:         match = re.search(tab_pattern, display_name)
  89:         if match:
  90:             tab_count = match.group(1)
  91:             display_name = re.sub(tab_pattern, f' (+{tab_count})', display_name)
  92:         
  93:         # Also handle other browser patterns like "- X tabs" or "(X tabs)"
  94:         # Chrome sometimes uses different formats
  95:         other_patterns = [
  96:             (r' - (\d+) tabs?$', r' (+\1)'),  # " - 3 tabs" -> " (+3)"
  97:             (r' \((\d+) tabs?\)$', r' (+\1)'),  # " (3 tabs)" -> " (+3)"
  98:         ]
  99:         
 100:         for pattern, replacement in other_patterns:
 101:             display_name = re.sub(pattern, replacement, display_name)
 102:         
 103:         return display_name if display_name else self.title
 104:     
 105:     def _get_window_colors(self):
 106:         """Get appropriate colors for this window"""
 107:         from config import AppColors
 108:         
 109:         # First check if it's a file type that should override the app colors
 110:         file_colors = AppColors.get_colors_for_file_type(self.title)
 111:         if file_colors:
 112:             return file_colors
 113:         
 114:         # Otherwise use app colors
 115:         return AppColors.get_app_colors(self.process_name)
 116:     
 117:     def hide(self) -> bool:
 118:         """Hide the window (remove from Alt+Tab and taskbar)"""
 119:         try:
 120:             # Get current extended style
 121:             ex_style = win32gui.GetWindowLong(self.hwnd, win32con.GWL_EXSTYLE)
 122:             
 123:             # Add WS_EX_TOOLWINDOW to hide from Alt+Tab and taskbar
 124:             new_ex_style = ex_style | win32con.WS_EX_TOOLWINDOW
 125:             
 126:             # Remove WS_EX_APPWINDOW to ensure it's hidden from taskbar
 127:             new_ex_style = new_ex_style & ~win32con.WS_EX_APPWINDOW
 128:             
 129:             # Apply new style
 130:             win32gui.SetWindowLong(self.hwnd, win32con.GWL_EXSTYLE, new_ex_style)
 131:             
 132:             # Hide the window
 133:             win32gui.ShowWindow(self.hwnd, win32con.SW_HIDE)
 134:             
 135:             self.is_hidden = True
 136:             return True
 137:         except Exception as e:
 138:             print(f"Error hiding window {self.display_name}: {e}")
 139:             return False
 140:     
 141:     def show(self) -> bool:
 142:         """Show the window (restore to Alt+Tab and taskbar)"""
 143:         try:
 144:             # Restore original extended style
 145:             win32gui.SetWindowLong(self.hwnd, win32con.GWL_EXSTYLE, self.original_ex_style)
 146:             
 147:             # Show the window
 148:             win32gui.ShowWindow(self.hwnd, win32con.SW_SHOW)
 149:             
 150:             self.is_hidden = False
 151:             return True
 152:         except Exception as e:
 153:             print(f"Error showing window {self.display_name}: {e}")
 154:             return False
 155:     
 156:     def bring_to_front(self) -> bool:
 157:         """Bring window to front and give it focus, restoring from minimized if needed"""
 158:         try:
 159:             if self.is_hidden:
 160:                 self.show()
 161:             
 162:             # Check if window is minimized (iconic)
 163:             if win32gui.IsIconic(self.hwnd):
 164:                 print(f"Window {self.display_name} is minimized, restoring...")
 165:                 # Restore the window from minimized state
 166:                 win32gui.ShowWindow(self.hwnd, win32con.SW_RESTORE)
 167:             elif not win32gui.IsWindowVisible(self.hwnd):
 168:                 # Window is hidden but not minimized
 169:                 win32gui.ShowWindow(self.hwnd, win32con.SW_SHOW)
 170:             
 171:             # Bring window to foreground
 172:             # Sometimes SetForegroundWindow fails, so we try a few methods
 173:             try:
 174:                 win32gui.SetForegroundWindow(self.hwnd)
 175:             except:
 176:                 # Alternative method: simulate alt key to allow focus change
 177:                 win32api.keybd_event(win32con.VK_MENU, 0, 0, 0)
 178:                 win32gui.SetForegroundWindow(self.hwnd)
 179:                 win32api.keybd_event(win32con.VK_MENU, 0, win32con.KEYEVENTF_KEYUP, 0)
 180:             
 181:             # Ensure window is active
 182:             win32gui.SetActiveWindow(self.hwnd)
 183:             
 184:             return True
 185:         except Exception as e:
 186:             print(f"Error bringing window to front {self.display_name}: {e}")
 187:             return False
 188:     
 189:     def is_valid(self) -> bool:
 190:         """Check if window still exists"""
 191:         return win32gui.IsWindow(self.hwnd)
 192: 
 193: class WindowManager:
 194:     """Manages window detection, filtering, and state"""
 195:     
 196:     def __init__(self):
 197:         self.managed_windows: dict[int, ManagedWindow] = {}
 198:         self.excluded_processes = {
 199:             'searchui.exe', 'shellexperiencehost.exe',
 200:             'applicationframehost.exe', 'systemsettings.exe', 'textinputhost.exe',
 201:             'lockapp.exe', 'searchapp.exe', 'startmenuexperiencehost.exe',
 202:             'runtimebroker.exe', 'svchost.exe', 'system', 'registry',
 203:             'smss.exe', 'csrss.exe', 'wininit.exe', 'services.exe',
 204:             'lsass.exe', 'winlogon.exe', 'dwm.exe', 'taskhostw.exe',
 205:             'searchindexer.exe', 'backgroundtaskhost.exe'
 206:         }
 207:     
 208:     def get_relevant_windows(self) -> list[ManagedWindow]:
 209:         """Get all relevant open windows on current desktop"""
 210:         windows = []
 211:         
 212:         def enum_callback(hwnd, _):
 213:             if self._is_relevant_window(hwnd):
 214:                 try:
 215:                     title = win32gui.GetWindowText(hwnd)
 216:                     if title:  # Skip windows with no title
 217:                         _, pid = win32process.GetWindowThreadProcessId(hwnd)
 218:                         process = psutil.Process(pid)
 219:                         process_name = process.name()
 220:                         
 221:                         # Check if we already manage this window
 222:                         if hwnd in self.managed_windows:
 223:                             window = self.managed_windows[hwnd]
 224:                             # Update title in case it changed
 225:                             window.title = title
 226:                             window.display_name = window._create_display_name()
 227:                         else:
 228:                             window = ManagedWindow(hwnd, title, process_name)
 229:                             self.managed_windows[hwnd] = window
 230:                         
 231:                         windows.append(window)
 232:                 except Exception as e:
 233:                     print(f"Error processing window {hwnd}: {e}")
 234:             return True
 235:         
 236:         win32gui.EnumWindows(enum_callback, None)
 237:         
 238:         # Clean up managed windows that no longer exist
 239:         self._cleanup_invalid_windows()
 240:         
 241:         return sorted(windows, key=lambda w: w.display_name.lower())
 242:     
 243:     def _is_relevant_window(self, hwnd: int) -> bool:
 244:         """Check if window is relevant (user-facing, not system)"""
 245:         try:
 246:             # Window must be visible or minimized (but not completely hidden)
 247:             if not win32gui.IsWindowVisible(hwnd) and not win32gui.IsIconic(hwnd):
 248:                 return False
 249:             
 250:             # Get window info
 251:             _, pid = win32process.GetWindowThreadProcessId(hwnd)
 252:             process = psutil.Process(pid)
 253:             process_name = process.name().lower()
 254:             
 255:             # Special handling for explorer.exe - we want File Explorer windows but not the desktop/taskbar
 256:             if process_name == 'explorer.exe':
 257:                 # Get window class name to distinguish File Explorer from desktop/taskbar
 258:                 class_name = win32gui.GetClassName(hwnd)
 259:                 # File Explorer windows have these class names
 260:                 if class_name not in ['CabinetWClass', 'ExploreWClass']:
 261:                     return False
 262:             elif process_name in self.excluded_processes:
 263:                 # Exclude other system processes
 264:                 return False
 265:             
 266:             # Get window style
 267:             style = win32gui.GetWindowLong(hwnd, win32con.GWL_STYLE)
 268:             ex_style = win32gui.GetWindowLong(hwnd, win32con.GWL_EXSTYLE)
 269:             
 270:             # Must be a normal window (not a tool window, unless we made it one)
 271:             if hwnd not in self.managed_windows:
 272:                 if ex_style & win32con.WS_EX_TOOLWINDOW:
 273:                     return False
 274:             
 275:             # Should have a title bar or be a notable window
 276:             if not (style & win32con.WS_CAPTION):
 277:                 # Some apps like Chrome have windows without WS_CAPTION
 278:                 # Check if it's a main window by other criteria
 279:                 if not (ex_style & win32con.WS_EX_APPWINDOW):
 280:                     return False
 281:             
 282:             # Check if it's a main window (not a dialog or popup)
 283:             owner = win32gui.GetWindow(hwnd, win32con.GW_OWNER)
 284:             if owner:
 285:                 return False
 286:             
 287:             return True
 288:             
 289:         except Exception:
 290:             return False
 291:     
 292:     def _cleanup_invalid_windows(self):
 293:         """Remove windows that no longer exist from managed windows"""
 294:         invalid_hwnds = []
 295:         for hwnd, window in self.managed_windows.items():
 296:             if not window.is_valid():
 297:                 invalid_hwnds.append(hwnd)
 298:         
 299:         for hwnd in invalid_hwnds:
 300:             del self.managed_windows[hwnd]
 301:     
 302:     def toggle_window_visibility(self, window: ManagedWindow) -> bool:
 303:         """Toggle window visibility"""
 304:         if window.is_hidden:
 305:             return window.show()
 306:         else:
 307:             return window.hide()
 308:     
 309:     def pin_window(self, window: ManagedWindow):
 310:         """Mark window as pinned"""
 311:         window.is_pinned = True
 312:     
 313:     def unpin_window(self, window: ManagedWindow):
 314:         """Unpin window and ensure it's visible"""
 315:         window.is_pinned = False
 316:         if window.is_hidden:
 317:             window.show()
 318:     
 319:     def unhide_all_windows(self):
 320:         """Unhide all hidden windows (for app cleanup)"""
 321:         for window in self.managed_windows.values():
 322:             if window.is_hidden:
 323:                 window.show()
 324:     
 325:     def get_pinned_windows(self) -> list[ManagedWindow]:
 326:         """Get all currently pinned windows"""
 327:         return [w for w in self.managed_windows.values() if w.is_pinned]
 328:     
 329:     # Close a managed window and remove it from the managed_windows dictionary
 330:     def close_managed_window(self, window: ManagedWindow):
 331:         """Close the window"""
 332:         del self.managed_windows[window.hwnd] 
 333:         win32gui.PostMessage(window.hwnd, win32con.WM_CLOSE, 0, 0)
 334:         
 335:         #Use PostMessage to actually close the window.  The line below will just minimize it
 336:         # win32gui.CloseWindow(window.hwnd)

────────────────────────────────────────────────────────────────────────────────
FILE: windows_menu.py
────────────────────────────────────────────────────────────────────────────────
Path: windows_menu.py
Size: 22.5 KB
Lines: 554 total, 440 non-empty
Characters: 22,505
Type: Windows menu UI and interaction handling
────────────────────────────────────────────────────────────────────────────────

   1: # windows_menu.py (modified)
   2: """
   3: Windows menu UI for SuiteView Taskbar
   4: Shows list of open windows with hide/pin functionality
   5: Now excludes pinned windows from the list
   6: """
   7: 
   8: import tkinter as tk
   9: from config import Colors, Fonts, Dimensions
  10: from window_manager import WindowManager, ManagedWindow
  11: from utils import WindowsUtils
  12: from typing import Callable, Optional
  13: 
  14: class WindowsMenu(tk.Toplevel):
  15:     """Windows management menu"""
  16:     
  17:     def __init__(self, taskbar, window_manager: WindowManager, on_pin_callback: Callable, 
  18:                  stored_geometry: Optional[str] = None):
  19:         super().__init__(taskbar.root)
  20:         self.parent = taskbar
  21: 
  22: 
  23:         self.window_manager = window_manager
  24:         self.on_pin_callback = on_pin_callback
  25:         self.stored_geometry = stored_geometry
  26:                 
  27:         # Window setup
  28:         self.title("")  # No title for custom window
  29:         self.configure(bg=Colors.DARK_GREEN)
  30:         self.attributes('-topmost', True)
  31:         self.attributes('-alpha', 0.98)
  32:         
  33:         # Important: Make window resizable
  34:         self.resizable(True, True)
  35:         
  36:         # Remove default window decorations for custom look
  37:         self.overrideredirect(True)
  38:         
  39:         # Track window items for updates
  40:         self.window_items = {}
  41:         
  42:         # Resize variables
  43:         self.is_resizing = False
  44:         self.resize_edge = None
  45:         self.resize_start_x = 0
  46:         self.resize_start_y = 0
  47:         self.original_geometry = None
  48:         
  49:         # Main container with visible border
  50:         self.main_frame = tk.Frame(self, bg=Colors.DARK_GREEN, relief=tk.RAISED, bd=3)
  51:         self.main_frame.pack(fill=tk.BOTH, expand=True)
  52:         
  53:         # Create header
  54:         self.create_header()
  55:         
  56:         # Create scrollable content area
  57:         self.create_content_area()
  58:         
  59:         # Create resize handles
  60:         self.create_resize_handles()
  61:         
  62:         # Populate with windows
  63:         self.refresh_window_list()
  64:         
  65:         # Apply stored geometry or default size and position
  66:         if stored_geometry:
  67:             self.geometry(stored_geometry)
  68:         else:
  69:             # Set default size and position
  70:             default_width = 400  # Slightly narrower
  71:             
  72:             # Calculate height based on number of windows with smaller item height
  73:             window_count = len([w for w in self.window_manager.get_relevant_windows() if not w.is_pinned])
  74:             base_height = 80   # Minimum height for header and padding
  75:             item_height = 32   # Smaller height per window item
  76:             max_height = 700   # Increased max height to show more items
  77:             default_height = min(base_height + (window_count * item_height), max_height)
  78: 
  79:             screen_width = self.winfo_screenwidth()
  80:             screen_height = self.winfo_screenheight() 
  81: 
  82:             print(f"Windows taskbar height: {WindowsUtils.get_windows_taskbar_height()}")
  83: 
  84:             x = screen_width - default_width - 5
  85:             y = screen_height - default_height -  WindowsUtils.get_windows_taskbar_height()
  86:             
  87:             self.geometry(f"{default_width}x{default_height}+{x}+{y}")
  88:         
  89:         # Bind window close event
  90:         self.protocol("WM_DELETE_WINDOW", self.close_window)
  91:         
  92:         # Ensure window is visible
  93:         self.deiconify()
  94:         self.lift()
  95:     
  96:     def create_header(self):
  97:         """Create menu header"""
  98:         header_frame = tk.Frame(self.main_frame, bg=Colors.DARK_GREEN, height=30)
  99:         header_frame.pack(fill=tk.X, padx=1, pady=1)
 100:         header_frame.pack_propagate(False)
 101:         
 102:         # Make header draggable
 103:         header_frame.bind("<Button-1>", self.start_drag)
 104:         header_frame.bind("<B1-Motion>", self.do_drag)
 105:         
 106:         # Title
 107:         title = tk.Label(header_frame, text="🪟 Windows Manager", 
 108:                         bg=Colors.DARK_GREEN, fg=Colors.WHITE,
 109:                         font=Fonts.MENU_HEADER, cursor='fleur')
 110:         title.pack(side=tk.LEFT, padx=10, pady=5)
 111:         title.bind("<Button-1>", self.start_drag)
 112:         title.bind("<B1-Motion>", self.do_drag)
 113:         
 114:         # Refresh button
 115:         refresh_btn = tk.Button(header_frame, text="↻ Refresh", 
 116:                                bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 117:                                relief=tk.RAISED, bd=1, cursor='hand2',
 118:                                font=Fonts.MENU_ITEM, command=self.refresh_window_list)
 119:         refresh_btn.pack(side=tk.RIGHT, padx=10, pady=5)
 120:         
 121:         # Close button
 122:         close_btn = tk.Button(header_frame, text="X", 
 123:                              bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 124:                              relief=tk.RAISED, bd=1, cursor='hand2',
 125:                              font=Fonts.MENU_ITEM, width=3,
 126:                              command=self.close_window)
 127:         close_btn.pack(side=tk.RIGHT, padx=5, pady=5)
 128:     
 129:     def create_resize_handles(self):
 130:         """Create resize handles for top, left, and right edges"""
 131:         # Top resize handle
 132:         top_handle = tk.Frame(self, cursor='size_ns', height=5)
 133:         top_handle.place(relx=0.0, rely=0.0, relwidth=1.0, anchor='nw')
 134:         top_handle.configure(bg=Colors.DARK_GREEN)
 135:         
 136:         # Bind resize events for top
 137:         top_handle.bind("<Button-1>", lambda e: self.start_resize(e, 't'))
 138:         top_handle.bind("<B1-Motion>", self.do_resize)
 139:         top_handle.bind("<ButtonRelease-1>", self.end_resize)
 140:         
 141:         # Left resize handle
 142:         left_handle = tk.Frame(self, cursor='size_we', width=5)
 143:         left_handle.place(relx=0.0, rely=0.0, relheight=1.0, anchor='nw')
 144:         left_handle.configure(bg=Colors.DARK_GREEN)
 145:         
 146:         # Bind resize events for left
 147:         left_handle.bind("<Button-1>", lambda e: self.start_resize(e, 'l'))
 148:         left_handle.bind("<B1-Motion>", self.do_resize)
 149:         left_handle.bind("<ButtonRelease-1>", self.end_resize)
 150:         
 151:         # Right resize handle
 152:         right_handle = tk.Frame(self, cursor='size_we', width=5)
 153:         right_handle.place(relx=1.0, rely=0.0, relheight=1.0, anchor='ne')
 154:         right_handle.configure(bg=Colors.DARK_GREEN)
 155:         
 156:         # Bind resize events for right
 157:         right_handle.bind("<Button-1>", lambda e: self.start_resize(e, 'r'))
 158:         right_handle.bind("<B1-Motion>", self.do_resize)
 159:         right_handle.bind("<ButtonRelease-1>", self.end_resize)
 160:         
 161:         # Visual feedback on hover
 162:         top_handle.bind("<Enter>", lambda e: self.configure(cursor='size_ns'))
 163:         top_handle.bind("<Leave>", lambda e: self.configure(cursor=''))
 164:         left_handle.bind("<Enter>", lambda e: self.configure(cursor='size_we'))
 165:         left_handle.bind("<Leave>", lambda e: self.configure(cursor=''))
 166:         right_handle.bind("<Enter>", lambda e: self.configure(cursor='size_we'))
 167:         right_handle.bind("<Leave>", lambda e: self.configure(cursor=''))
 168: 
 169:     def start_drag(self, event):
 170:         """Start dragging the window"""
 171:         self.drag_start_x = event.x_root
 172:         self.drag_start_y = event.y_root
 173:         self.original_x = self.winfo_x()
 174:         self.original_y = self.winfo_y()
 175: 
 176:     def do_drag(self, event):
 177:         """Handle window dragging"""
 178:         dx = event.x_root - self.drag_start_x
 179:         dy = event.y_root - self.drag_start_y
 180:         
 181:         new_x = self.original_x + dx
 182:         new_y = self.original_y + dy
 183:         
 184:         # Keep window on screen
 185:         screen_width = self.winfo_screenwidth()
 186:         screen_height = self.winfo_screenheight()
 187:         window_width = self.winfo_width()
 188:         window_height = self.winfo_height()
 189:         
 190:         new_x = max(0, min(new_x, screen_width - window_width))
 191:         new_y = max(0, min(new_y, screen_height - window_height))
 192:         
 193:         self.geometry(f"+{int(new_x)}+{int(new_y)}")
 194:         
 195:         # Update stored geometry in parent
 196:         if hasattr(self.parent, 'windows_menu_geometry'):
 197:             self.parent.windows_menu_geometry = self.get_current_geometry()
 198:     
 199:     def start_resize(self, event, edge):
 200:         """Start resizing operation"""
 201:         self.is_resizing = True
 202:         self.resize_edge = edge
 203:         self.resize_start_x = event.x_root
 204:         self.resize_start_y = event.y_root
 205:         
 206:         # Store original geometry
 207:         self.original_geometry = {
 208:             'x': self.winfo_x(),
 209:             'y': self.winfo_y(),
 210:             'width': self.winfo_width(),
 211:             'height': self.winfo_height()
 212:         }
 213:         
 214:         # Visual feedback
 215:         self.main_frame.configure(relief=tk.SUNKEN)
 216: 
 217:     def do_resize(self, event):
 218:         """Handle resize drag for all edges"""
 219:         if not self.is_resizing or not self.resize_edge:
 220:             return
 221:         
 222:         dx = event.x_root - self.resize_start_x
 223:         dy = event.y_root - self.resize_start_y
 224:         
 225:         x = self.original_geometry['x']
 226:         y = self.original_geometry['y']
 227:         width = self.original_geometry['width']
 228:         height = self.original_geometry['height']
 229:         
 230:         min_width = 400
 231:         min_height = 300
 232:         
 233:         # Handle different edges
 234:         if self.resize_edge == 't':  # Top edge
 235:             new_height = max(min_height, height - dy)
 236:             if new_height != height:
 237:                 y = y + (height - new_height)
 238:                 height = new_height
 239:                 
 240:         elif self.resize_edge == 'l':  # Left edge
 241:             new_width = max(min_width, width - dx)
 242:             if new_width != width:
 243:                 x = x + (width - new_width)
 244:                 width = new_width
 245:                 
 246:         elif self.resize_edge == 'r':  # Right edge
 247:             new_width = max(min_width, width + dx)
 248:             width = new_width
 249:         
 250:         # Apply new geometry
 251:         self.geometry(f"{int(width)}x{int(height)}+{int(x)}+{int(y)}")
 252: 
 253:     def end_resize(self, event):
 254:         """End resizing operation"""
 255:         self.is_resizing = False
 256:         self.resize_edge = None
 257:         
 258:         # Remove visual feedback
 259:         self.main_frame.configure(relief=tk.RAISED)
 260:         
 261:         # Update stored geometry in parent
 262:         if hasattr(self.parent, 'windows_menu_geometry'):
 263:             self.parent.windows_menu_geometry = self.get_current_geometry()
 264:             #print(f"Stored geometry after resize: {self.parent.windows_menu_geometry}")  # Debug
 265:     
 266:     def create_content_area(self):
 267:         """Create scrollable content area with adjusted sizing"""
 268:         # Create canvas and scrollbar for scrolling
 269:         self.canvas = tk.Canvas(self.main_frame, bg=Colors.LIGHT_GREEN, 
 270:                             highlightthickness=0)
 271:         scrollbar = tk.Scrollbar(self.main_frame, orient="vertical", 
 272:                                 command=self.canvas.yview, width=12)
 273:         self.scrollable_frame = tk.Frame(self.canvas, bg=Colors.LIGHT_GREEN)
 274:         
 275:         self.scrollable_frame.bind(
 276:             "<Configure>",
 277:             lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
 278:         )
 279:         
 280:         # Make sure the canvas window fills the width
 281:         canvas_window = self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
 282:         
 283:         # Bind canvas resize to update frame width
 284:         def configure_frame_width(event):
 285:             canvas_width = event.width
 286:             self.canvas.itemconfig(canvas_window, width=canvas_width)
 287:         
 288:         self.canvas.bind('<Configure>', configure_frame_width)
 289:         
 290:         self.canvas.configure(yscrollcommand=scrollbar.set)
 291:         
 292:         self.canvas.pack(side="left", fill="both", expand=True, padx=1, pady=1)
 293:         scrollbar.pack(side="right", fill="y")
 294:         
 295:         # Bind mouse wheel
 296:         self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
 297:     
 298:     def _on_mousewheel(self, event):
 299:         """Handle mouse wheel scrolling"""
 300:         if self.canvas.winfo_exists():
 301:             self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
 302:     
 303:     def refresh_window_list(self):
 304:         """Refresh the list of windows"""
 305:         # Clear existing items
 306:         for widget in self.scrollable_frame.winfo_children():
 307:             widget.destroy()
 308:         self.window_items.clear()
 309:         
 310:         # Get current windows and filter out pinned ones
 311:         all_windows = self.window_manager.get_relevant_windows()
 312:         windows = [w for w in all_windows if not w.is_pinned]  # Exclude pinned windows
 313:         
 314:         if not windows:
 315:             label = tk.Label(self.scrollable_frame, text="No unpinned windows found", 
 316:                            bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 317:                            font=Fonts.MENU_ITEM)
 318:             label.pack(pady=20)
 319:             return
 320:         
 321:         # Create item for each window
 322:         for window in windows:
 323:             self.create_window_item(window)
 324:     
 325:     def create_window_item(self, window: ManagedWindow):
 326:         """Create a single window item with app-named pin button"""
 327:         # Item container - this will stretch full width
 328:         item_frame = tk.Frame(self.scrollable_frame, bg=Colors.LIGHT_GREEN, 
 329:                             relief=tk.RAISED, bd=1)
 330:         item_frame.pack(fill=tk.X, padx=3, pady=1, anchor='e')  # Anchor to east (right)
 331:         
 332:         # Pin button with app name
 333:         try:
 334:             # Check if colors exist, use defaults if not
 335:             if hasattr(window, 'colors'):
 336:                 bg_color = window.colors['bg']
 337:                 fg_color = window.colors['fg']
 338:             else:
 339:                 bg_color = Colors.MEDIUM_GREEN
 340:                 fg_color = Colors.BLACK
 341:             
 342:             # Use app name for button text
 343:             button_text = window.app_name
 344: 
 345:             #Remove .exe from button_text (regardless of case)
 346:             button_text = button_text.replace('.exe', '').replace('.EXE', '').replace('.Exe', '')
 347: 
 348:             
 349:             # Special cases for common abbreviations
 350:             app_name_display = {
 351:                 'File Explorer': 'Explorer',
 352:                 'Visual Studio': 'VS',
 353:                 'VS Code': 'Code',
 354:                 'Acrobat Reader': 'Reader',
 355:                 'Google Chrome': 'Chrome',
 356:                 'Winword': 'Word',
 357:             }.get(button_text, button_text)
 358:             
 359:             pin_btn = tk.Button(item_frame, text=app_name_display, 
 360:                             bg=bg_color, fg=fg_color,
 361:                             relief=tk.RAISED, bd=1, cursor='hand2',
 362:                             font=('Arial', 8), 
 363:                             width=10,  # Wider to accommodate app names
 364:                             wraplength=60,  # Allow text wrapping
 365:                             justify='center',
 366:                             height=1,  # Keep height at 1 as requested
 367:                             command=lambda: self.toggle_pin(window))
 368:             pin_btn.pack(side=tk.LEFT, padx=3, pady=2)
 369:             
 370:         except Exception as e:
 371:             print(f"Error creating pin button: {e}")
 372:             # Fallback pin button
 373:             pin_btn = tk.Button(item_frame, text="Pin", 
 374:                             bg=Colors.MEDIUM_GREEN, fg=Colors.BLACK,
 375:                             relief=tk.RAISED, bd=1, cursor='hand2',
 376:                             font=('Arial', 8), width=10, height=1,
 377:                             command=lambda: self.toggle_pin(window))
 378:             pin_btn.pack(side=tk.LEFT, padx=3, pady=2)
 379:         
 380:         # Add color indicator on right side FIRST (so it appears on the far right)
 381:         try:
 382:             if hasattr(window, 'colors'):
 383:                 color_indicator = tk.Frame(item_frame, bg=window.colors['bg'], width=5)
 384:                 color_indicator.pack(side=tk.RIGHT, fill=tk.Y, padx=(0, 2))
 385:         except:
 386:             pass  # Skip color indicator if there's an issue
 387:         
 388:         # Window name label - pack after color indicator so it fills the middle space
 389:         label_bg = Colors.WINDOW_HIDDEN if window.is_hidden else Colors.WINDOW_VISIBLE
 390:         label_fg = Colors.WHITE if window.is_hidden else Colors.BLACK
 391:         
 392:         # Use the display name
 393:         display_text = window.display_name if hasattr(window, 'display_name') else window.title
 394:         
 395:         # Truncate very long names
 396:         max_chars = 200  # Reduced because button is wider now
 397:         if len(display_text) > max_chars:
 398:             display_text = display_text[:max_chars-3] + "..."
 399:         
 400:         name_label = tk.Label(item_frame, text=display_text, 
 401:                             bg=label_bg, fg=label_fg,
 402:                             font=('Arial', 9), anchor='w',
 403:                             cursor='hand2', padx=5, pady=2)
 404:         name_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
 405:         
 406:         # Bind click events
 407:         name_label.bind("<Button-1>", lambda e: self.show_window(window))
 408:         name_label.bind("<Double-Button-1>", lambda e: self.remove_window(window))
 409:         
 410:         # Store references for updating
 411:         self.window_items[window.hwnd] = {
 412:             'frame': item_frame,
 413:             'label': name_label,
 414:             'pin_btn': pin_btn,
 415:             'window': window
 416:         }
 417:         
 418:         # Force the frame to update
 419:         item_frame.update_idletasks()
 420:     
 421:     def toggle_window_visibility(self, window: ManagedWindow):
 422:         """Toggle window visibility and update UI"""
 423:         if self.window_manager.toggle_window_visibility(window):
 424:             self.update_window_item(window)
 425:     
 426:     def show_window(self, window: ManagedWindow):
 427:         """Show the window"""
 428:         window.show()
 429:         window.bring_to_front()
 430: 
 431:     def update_window_item(self, window: ManagedWindow):
 432:         """Update the UI for a specific window item"""
 433:         if window.hwnd not in self.window_items:
 434:             return
 435:         
 436:         item = self.window_items[window.hwnd]
 437:         
 438:         # Update label color based on visibility
 439:         label_bg = Colors.WINDOW_HIDDEN if window.is_hidden else Colors.WINDOW_VISIBLE
 440:         label_fg = Colors.WHITE if window.is_hidden else Colors.BLACK
 441:         item['label'].configure(bg=label_bg, fg=label_fg)
 442: 
 443:     def remove_window(self, window: ManagedWindow):
 444:         """Close window and remove label button from windows_menu  """
 445:         self.window_manager.close_managed_window(window)
 446:         self.refresh_window_list()
 447: 
 448:     def toggle_pin(self, window: ManagedWindow):
 449:         """Toggle window pin state"""
 450:         print(f"\n=== TOGGLE PIN DEBUG ===")
 451:         print(f"Window: {window.display_name}")
 452:         print(f"Was pinned: {window.is_pinned}")
 453:         
 454:         if window.is_pinned:
 455:             self.window_manager.unpin_window(window)
 456:         else:
 457:             self.window_manager.pin_window(window)
 458:         
 459:         print(f"Now pinned: {window.is_pinned}")
 460:         
 461:         # Notify callback to update taskbar
 462:         if self.on_pin_callback:
 463:             print(f"Calling on_pin_callback: {self.on_pin_callback}")
 464:             self.on_pin_callback()
 465:         else:
 466:             print("ERROR: on_pin_callback is None!")
 467:         
 468:         # Remove this window from the list since it's now pinned
 469:         if window.is_pinned:
 470:             self.refresh_window_list()
 471:         
 472:         # List all pinned windows
 473:         pinned = self.window_manager.get_pinned_windows()
 474:         print(f"Total pinned windows: {len(pinned)}")
 475:         for pw in pinned:
 476:             print(f"  - {pw.display_name}")
 477:         print("=== END DEBUG ===\n")
 478:     
 479:     def get_current_geometry(self):
 480:         """Get current window geometry string"""
 481:         return self.geometry()
 482:     
 483:     def close_window(self):
 484:         """Close the windows menu"""
 485:         # Store geometry before closing
 486:         if hasattr(self.parent, 'windows_menu_geometry'):
 487:             self.parent.stored_geometry = self.get_current_geometry()
 488:             print(f"Storing geometry on close: {self.parent.windows_menu_geometry}")  # Debug
 489:         
 490:         # Unbind mousewheel to prevent errors
 491:         self.canvas.unbind_all("<MouseWheel>")
 492:         self.destroy()
 493: 
 494:     def refresh_window_list(self, only_update_titles=False):
 495:         """Refresh the list of windows or just update titles"""
 496:         if only_update_titles and self.window_items:
 497:             # Just update existing titles without full refresh
 498:             current_windows = self.window_manager.get_relevant_windows()
 499:             
 500:             for window in current_windows:
 501:                 if window.hwnd in self.window_items and not window.is_pinned:
 502:                     self.update_window_title(window)
 503:             
 504:             return
 505:         
 506:         
 507:         # Clear existing items
 508:         for widget in self.scrollable_frame.winfo_children():
 509:             widget.destroy()
 510:         self.window_items.clear()
 511:         
 512:         # Get current windows and filter out pinned ones
 513:         all_windows = self.window_manager.get_relevant_windows()
 514:         windows = [w for w in all_windows if not w.is_pinned]
 515:         
 516:         if not windows:
 517:             label = tk.Label(self.scrollable_frame, text="No unpinned windows found", 
 518:                         bg=Colors.LIGHT_GREEN, fg=Colors.DARK_GREEN,
 519:                         font=Fonts.MENU_ITEM)
 520:             label.pack(pady=20)
 521:             return
 522:         
 523:         # Create item for each window
 524:         for window in windows:
 525:             self.create_window_item(window)
 526:     
 527:     def update_window_title(self, window: ManagedWindow):
 528:         """Update a specific window's title without refreshing entire list"""
 529:         if window.hwnd in self.window_items:
 530:             item = self.window_items[window.hwnd]
 531:             
 532:             # Update the label text
 533:             display_text = window.display_name
 534:             
 535:             # Truncate very long names
 536:             max_chars = 60
 537:             if len(display_text) > max_chars:
 538:                 display_text = display_text[:max_chars-3] + "..."
 539:             
 540:             item['label'].configure(text=display_text)
 541:             
 542:             # Update colors if file type changed (e.g., opened different file type in Notepad)
 543:             if hasattr(window, 'colors'):
 544:                 # Update pin button colors
 545:                 item['pin_btn'].configure(
 546:                     bg=window.colors['bg'], 
 547:                     fg=window.colors['fg']
 548:                 )
 549:                 
 550:                 # Update color indicator if it exists
 551:                 for widget in item['frame'].winfo_children():
 552:                     if isinstance(widget, tk.Frame) and widget.winfo_width() == 3:
 553:                         widget.configure(bg=window.colors['bg'])
 554:                         break

────────────────────────────────────────────────────────────────────────────────
FILE: requirements.txt
────────────────────────────────────────────────────────────────────────────────
Path: requirements.txt
Size: 42.0 B
Lines: 5 total, 5 non-empty
Characters: 38
Type: Python package dependencies
────────────────────────────────────────────────────────────────────────────────

PySide6
pywin32
Pillow
psutil
comtypes


================================================================================
                           EXPORT SUMMARY
================================================================================

Files Processed: 22
Total Size: 330.8 KB
Total Python Lines: 8,387

File Breakdown:
    README.md                  718.0 B (  31 lines)
    browse_choice_dialog.py     7.0 KB ( 187 lines)
    config.py                   7.4 KB ( 186 lines)
    email_manager.py           20.0 KB ( 480 lines)
    email_menu.py              18.2 KB ( 436 lines)
    email_options_menu.py       6.9 KB ( 186 lines)
    explorer_utils.py           8.9 KB ( 226 lines)
    folder_inventory.py        29.7 KB ( 736 lines)
    links_manager.py           10.8 KB ( 306 lines)
    main.py                     1.5 KB (  58 lines)
    pinned_windows.py          13.3 KB ( 338 lines)
    quick_links.py             36.3 KB ( 867 lines)
    restore_deskop.py           1.5 KB (  41 lines)
    simple_window_factory.py   44.3 KB (1093 lines)
    snip_feature.py            16.1 KB ( 410 lines)
    taskbar.py                 23.1 KB ( 555 lines)
    ui_components.py           19.0 KB ( 525 lines)
    utils.py                    7.0 KB ( 211 lines)
    window_factory.py          23.0 KB ( 657 lines)
    window_manager.py          13.6 KB ( 336 lines)
    windows_menu.py            22.5 KB ( 554 lines)
    requirements.txt            42.0 B (   5 lines)

================================================================================
                    END OF SUITEVIEW SOURCE CODE
================================================================================
